<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2022年前端面试收集</title>
    <link href="/articles/2022/01/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%94%B6%E9%9B%86/"/>
    <url>/articles/2022/01/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="cdn-的好处是什么？它的原理有了解过吗？"><a href="#cdn-的好处是什么？它的原理有了解过吗？" class="headerlink" title="cdn 的好处是什么？它的原理有了解过吗？"></a>cdn 的好处是什么？它的原理有了解过吗？</h2><p>没有CDN网站的工作原理:</p><ol><li>用户在自己的浏览器中输入要访问的网站域名。</li><li>浏览器向本地DNS服务器请求对该域名的解析。</li><li>本地DNS服务器中如果缓存有这个域名的解析结果，则直接响应用户的解析请求。</li><li>本地DNS服务器中如果没有关于这个域名的解析结果的缓存，则以递归或迭代方式向整个DNS系统请求解析，获得应答后将结果反馈给浏览器。</li><li>浏览器得到域名解析结果，就是该域名相应的服务设备的IP地址。</li><li>浏览器向服务器请求内容。</li><li>服务器将用户请求内容传送给浏览器。</li></ol><p>CDN工作原理:</p><ol><li>当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。</li><li>CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。</li><li>用户向CDN的全局负载均衡设备发起内容URL访问请求。</li><li>CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。</li><li>区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。</li><li>全局负载均衡设备把服务器的IP地址返回给用户。</li><li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</li></ol><p>好处: </p><ol><li>解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度和成功率。</li><li>尽可能的减少资源在转发、传输、链路抖动等情况下顺利保障信息的连贯性。</li><li>实现跨运营商、跨地域的全网覆盖</li><li>CDN的负载均衡和分布式存储技术，可以加强网站的可靠性，相当无无形中给你的网站添加了一把保护伞，应对绝大部分的互联网攻击事件。防攻击系统也能避免网站遭到恶意攻击。</li><li>当某个服务器发生意外故障时，系统将会调用其他临近的健康服务器节点进行服务，进而提供接近100%的可靠性，这就让你的网站可以做到永不宕机。</li><li>使用CDN加速可以实现网站的全国铺设，你根本不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，也不用为了管理维护技术人员而烦恼，节省了人力、精力和财力。</li></ol><h2 id="webpack-如何将某些指定的包使用cdn加载？"><a href="#webpack-如何将某些指定的包使用cdn加载？" class="headerlink" title="webpack 如何将某些指定的包使用cdn加载？"></a>webpack 如何将某些指定的包使用cdn加载？</h2><p>webpack.config.js 中配置 externals 属性指定哪些包是从 CDN 引入，而不是把它打包，最后在 html 中引入这个cdn链接。<br>一般我们在工程化中，开发环境下我们可能不需要cdn引入，所以我们会动态配置，这种情况我们就需要使用到HtmlWebpackPlugin来动态写入这个cdn链接。</p><h2 id="什么是正向代理？什么是反向代理？-webpackDevserver-是正向代理还是反向代理？"><a href="#什么是正向代理？什么是反向代理？-webpackDevserver-是正向代理还是反向代理？" class="headerlink" title="什么是正向代理？什么是反向代理？ webpackDevserver 是正向代理还是反向代理？"></a>什么是正向代理？什么是反向代理？ webpackDevserver 是正向代理还是反向代理？</h2><p>正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。这种代理其实在生活中是比较常见的，比如访问外国网站技术，其用到的就是代理技术。这种代理方式： pc 端是清楚的知道代理服务器和目标服务器的。</p><p><img src="/images/9bb0wwt9dj.jpeg" alt="img"></p><p>所以，正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。</p><p>正向代理的用途: </p><ol><li>突破访问限制 </li><li>提高访问速度</li><li>隐藏客户端真实IP</li></ol><p>反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。对于常用的场景，就是我们在Web开发中用到的负载均衡服务器，客户端发送请求到负载均衡服务器上，负载均衡服务器再把请求转发给一台真正的服务器来执行，再把执行结果返回给客户端。例如（webpackDevserver中的代理），这种代理方式： pc端不知道真正的服务器的存在</p><p><img src="/images/WX20220107-232051@2x.png" alt="img"></p><p>所以，反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。</p><p>反向代理的用途：</p><ol><li>隐藏服务器真实IP</li><li>负载均衡</li><li>提高访问速度</li><li>提供安全保障（应用层防火墙）</li></ol><p>正向代理和反向代理的区别： </p><p>虽然正向代理服务器和反向代理服务器所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端，但是二者之间还是有一定的差异的。</p><ol><li>正向代理其实是客户端的代理，帮助客户端访问其无法访问的服务器资源。反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等。</li><li>正向代理一般是客户端架设的，比如在自己的机器上安装一个代理软件。而反向代理一般是服务器架设的，比如在自己的机器集群中部署一个反向代理服务器。</li><li>正向代理中，服务器不知道真正的客户端到底是谁，以为访问自己的就是真实的客户端。而在反向代理中，客户端不知道真正的服务器是谁，以为自己访问的就是真实的服务器。</li><li>正向代理和反向代理的作用和目的不同。正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。</li></ol><h2 id="求数组中的最大差值。"><a href="#求数组中的最大差值。" class="headerlink" title="求数组中的最大差值。"></a>求数组中的最大差值。</h2><pre><code class="hljs JS"><span class="hljs-comment">// 方式一 使用 Math 函数。思路： 找到数组中最大值和最小值 , 返回他们的差值</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outputMaxPrice</span>(<span class="hljs-params">array</span>) </span>&#123;    <span class="hljs-keyword">const</span> item1 = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, array)    <span class="hljs-keyword">const</span> item2 = <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-literal">null</span>, array)    <span class="hljs-keyword">return</span> item1 - item2&#125;<span class="hljs-keyword">const</span> a = outputMaxPrice([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">64</span>, <span class="hljs-number">5</span>])<span class="hljs-comment">// 方式二   定义两个变量，分别存贮最大值和最小值</span><span class="hljs-keyword">const</span> getMaxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">let</span> maxNum = arr[<span class="hljs-number">0</span>];    <span class="hljs-keyword">let</span> minNum = arr[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;        <span class="hljs-keyword">if</span> (arr[i] &gt; maxNum) &#123;            maxNum = arr[i];        &#125;        <span class="hljs-keyword">if</span> (arr[i] &lt; minNum) &#123;            minNum = arr[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> maxNum - minNum;&#125;getMaxProfit([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">64</span>, <span class="hljs-number">5</span>]) <span class="hljs-comment">// 62</span></code></pre><h2 id="preload-和-prefetch-是什么？-它们之间有什么区别？"><a href="#preload-和-prefetch-是什么？-它们之间有什么区别？" class="headerlink" title="preload 和 prefetch 是什么？ 它们之间有什么区别？"></a>preload 和 prefetch 是什么？ 它们之间有什么区别？</h2><ul><li>preload 是一个声明式 fetch，可以强制浏览器在不阻塞 document 的 onload 事件的情况下请求资源。preload 顾名思义就是一种预加载的方式，它通过声明向浏览器声明一个需要提交加载的资源，当资源真正被使用的时候立即执行，就无需等待网络的消耗。</li><li>prefetch 告诉浏览器这个资源将来可能需要，但是什么时间加载这个资源是由浏览器来决定的。若能预测到用户的行为，比如懒加载，点击到其它页面等则相当于提前预加载了需要的资源</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue3面试题</title>
    <link href="/articles/2020/12/10/vue3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/articles/2020/12/10/vue3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue3-0里有哪些是值得我们重点关注的点"><a href="#Vue3-0里有哪些是值得我们重点关注的点" class="headerlink" title="Vue3.0里有哪些是值得我们重点关注的点"></a>Vue3.0里有哪些是值得我们重点关注的点</h2><ol><li>性能：<br>Vue.js的发展，向来都是以提高开发与构建的速度为驱动，对比3.0和此前的Vue版本，这一点尤为明显。由于虚拟DOM已被完全重写，因此这个新版本将比以往更快。<br>对于服务器端渲染，Vue.js 3.0.0的性能提高了2倍，速度提高了3倍。同时，组件的初始化现在也更加高效，甚至具有了编译器通知的快速执行路径。</li><li>代码优化（Tree-shaking）：<br>在Vue.js 3.0.0中，提供了“摇树”支持，即通过”摇”我们的JS文件，将其中用不到的代码”摇”掉。具体来说，在 webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。在实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，便可将没有使用的模块摇掉，这样来达到代码优化的目的。现在，Vue中可选的大多数功能都支持“摇树”，例如过渡和v模型。这极大地减小了Vue应用程序的大小，例如一个标准HelloWorld系统现在的文件大小仅为13.5kb（通过使用composition API，它的大小甚至可以降到11.75kb）。“摇树”的出现，允许一个包括了所有运行时功能的项目大小可缩至22.5kb。这意味着即使增加了更多功能，Vue 3.0.0仍然比任何2.x版本都轻盈。</li><li>Composition API<br>Composition API 是一种全新的逻辑重用和代码组织方法。Vue团队主要对当前的Composition API进行了添加和改进，而不是进行重大更新，这让已经熟悉了Vue2语法的人可以更容易上手。此前，我们经常使用“options”API （如data、methods、computed等属性）来构建组件，目的就是为了将逻辑添加到Vue组件中。这种方法最大的缺点是：它本身并不是一个标准的JavaScript代码。因此，您需要确切地知道模板中可以访问哪些属性以及this关键字的行为。在底层，Vue编译器需要将此属性转换为标准代码。正因为如此，我们无法从自动建议或类型检查中获益。所以，Vue团队推出了composition API来解决这些问题，它具备了在Vue组件中使用和重用纯JS函数的灵活性和自由度。使用composition API并不意味着不能使用“options”API。相反，我们可以将 composition API与options API一起使用。（就像在React的钩子中那样）</li><li>Fragments<br>Vue JS将在 3.0.0版本中引入类似React Fragments的功能，该功能的主要需求是因为在之前的版本中Vue模板只能拥有一个根节点，任何Vue组件都需要绑定在单个根节点中，在3.0中将内置允许模板组件拥有多个根节点功能，这一点和React的功能类似。</li><li>Teleport<br>Teleport（以前称为Portal）是将子节点渲染到DOM谱系之外的DOM节点中的安全通道，例如弹出窗口甚至是模式。在此之前，使用CSS通常会遇到很多麻烦，现在Vue允许您使用Teleport 在模板部分中进行处理。我相信Teleport受到React门户的启发，并将随Vue JS的3.0.0版本一起提供。</li><li>Suspense<br>Suspense的提供可以让我们在应用延迟加载一些内容的同时，使加载过程可视化，这个过程可以是一个加载动画或是一个占位符，这样无疑会使用户体验更流畅，也会让程序的性能从感知层面上有一些提升。</li><li>更好的TypeScript支持<br>Vue 3.0版本已经使用了TypeScript重写，对于终端用户来讲，不论用户使用的是TS还是JS，都会获得更好的编程体验，包括静态检查等。即使你用的是JS，你仍然可以得到参数的提示、类型声明，甚至可以跳进类型声明中去看源码， TS与JS在代码和API之间没有太大区别。并且，目前如果你喜欢使用Class组件，它仍受支持。</li></ol><h2 id="Vue3-0-里为什么要用-Proxy-API-替代-defineProperty-API？"><a href="#Vue3-0-里为什么要用-Proxy-API-替代-defineProperty-API？" class="headerlink" title="Vue3.0 里为什么要用 Proxy API 替代 defineProperty API？"></a>Vue3.0 里为什么要用 Proxy API 替代 defineProperty API？</h2><ol><li>Vue2.x中使用 defineProperty 对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter，这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因，在Vue中使用下标的方式直接修改属性的值或者添加一个预先不存在的对象属性是无法做到setter监听的，这是defineProperty的局限性。</li><li>Proxy API的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作， 这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。</li><li>在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗。</li><li>在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减少性能消耗。</li></ol><h2 id="Vue3-0-编译做了哪些优化？（底层，源码）"><a href="#Vue3-0-编译做了哪些优化？（底层，源码）" class="headerlink" title="Vue3.0 编译做了哪些优化？（底层，源码）"></a>Vue3.0 编译做了哪些优化？（底层，源码）</h2><ol><li>模版渲染方面：<br>在2.0里，渲染效率的快慢与组件大小成正相关：组件越大，渲染效率越慢。并且，对于一些静态节点，又无数据更新，这些遍历都是性能浪费。<br>在3.0里，渲染效率不再与模板大小成正相关，而是与模板中动态节点的数量成正相关。</li><li>slot 编译优化<br>Vue.js 2.x 中，如果有一个组件传入了slot，那么每次父组件更新的时候，会强制使子组件update，造成性能的浪费。<br>Vue.js 3.0 优化了slot的生成，使得非动态slot中属性的更新只会触发子组件的更新。<br>动态slot指的是在slot上面使用v-if，v-for，动态slot名字等会导致slot产生运行时动态变化但是又无法被子组件track的操作。</li><li>diff算法优化</li></ol><h2 id="Vue3-0新特性-——-Composition-API-与-React-js-中-Hooks的异同点"><a href="#Vue3-0新特性-——-Composition-API-与-React-js-中-Hooks的异同点" class="headerlink" title="Vue3.0新特性 —— Composition API 与 React.js 中 Hooks的异同点"></a>Vue3.0新特性 —— Composition API 与 React.js 中 Hooks的异同点</h2><ol><li>React hook 底层是基于链表实现，调用的条件是每次组件被render的时候都会顺序执行所有的hooks。</li><li>vue hook 只会被注册调用一次，vue 能避开这些麻烦的问题，原因在于它对数据的响应是基于proxy的，对数据直接代理观察。</li><li>react 中，数据更改的时候，会导致重新render，重新render又会重新把hooks重新注册一次，所以react复杂程度会高一些。</li></ol><h2 id="Vue3-0是如何变得更快的？"><a href="#Vue3-0是如何变得更快的？" class="headerlink" title="Vue3.0是如何变得更快的？"></a>Vue3.0是如何变得更快的？</h2><ol><li>diff方法优化<br>Vue2.x 中的虚拟dom是进行全量的对比。<br>Vue3.0 中新增了静态标记（PatchFlag）：在与上次虚拟结点进行对比的时候，值对比带有patch flag的节点，并且可以通过flag 的信息得知当前节点要对比的具体内容化。</li><li>hoistStatic 静态提升<br>Vue2.x : 无论元素是否参与更新，每次都会重新创建。<br>Vue3.0 : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用。</li><li>cacheHandlers 事件侦听器缓存<br>默认情况下onClick会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可。</li></ol><h2 id="如何获取当前实例"><a href="#如何获取当前实例" class="headerlink" title="如何获取当前实例"></a>如何获取当前实例</h2><p>  getCurrentInstance()</p><h2 id="vue3-0-路由跳转的方式"><a href="#vue3-0-路由跳转的方式" class="headerlink" title="vue3.0 路由跳转的方式"></a>vue3.0 路由跳转的方式</h2>  <pre><code class="hljs javascript"><span class="hljs-comment">//方式1</span><span class="hljs-keyword">import</span> &#123; useRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  setup() &#123;    <span class="hljs-keyword">const</span> router = useRouter();    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">goto</span>(<span class="hljs-params"></span>)</span>&#123;      router.push(<span class="hljs-string">&quot;/about&quot;</span>);    &#125;    <span class="hljs-keyword">return</span>&#123;      goto  <span class="hljs-comment">//一定要要放在return里才能在模板上面使用</span>    &#125;  &#125;&#125;<span class="hljs-comment">// 方式2</span><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../router/index.js&quot;</span>;router.push(<span class="hljs-string">&quot;/&quot;</span>);</code></pre>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack面试题</title>
    <link href="/articles/2020/12/09/webpack%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/articles/2020/12/09/webpack%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="webpack与grunt、gulp的不同"><a href="#webpack与grunt、gulp的不同" class="headerlink" title="webpack与grunt、gulp的不同"></a>webpack与grunt、gulp的不同</h2><p>  三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。<br>  grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。<br>  webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。</p><h2 id="与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack"><a href="#与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack" class="headerlink" title="与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack"></a>与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack</h2><p>  同样是基于入口的打包工具还有以下几个主流的：<br>    1. webpack<br>    2. rollup<br>    3. parcel</p><p>  从应用场景上来看：<br>    1. webpack适用于大型复杂的前端站点构建<br>    2. rollup适用于基础库的打包，如vue、react<br>    3. parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果</p><h2 id="有哪些常见的Loader-你用过哪些Loader"><a href="#有哪些常见的Loader-你用过哪些Loader" class="headerlink" title="有哪些常见的Loader?你用过哪些Loader?"></a>有哪些常见的Loader?你用过哪些Loader?</h2><ol><li>raw-loader： 加载文件原始内容（utf-8）</li><li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)</li><li>url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)</li><li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</li><li>svg-inline-loader：将压缩后的 SVG 内容注入代码中</li><li>image-loader：加载并且压缩图片文件</li><li>json-loader 加载 JSON 文件（默认包含）</li><li>handlebars-loader: 将 Handlebars 模版编译成函数并返回</li><li>babel-loader：把 ES6 转换成 ES5</li><li>ts-loader: 将 TypeScript 转换成 JavaScript</li><li>awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader</li><li>sass-loader：将SCSS/SASS代码转换成CSS</li><li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li><li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</li><li>postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀</li><li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li><li>tslint-loader：通过 TSLint检查 TypeScript 代码</li><li>mocha-loader：加载 Mocha 测试用例的代码</li><li>coverjs-loader：计算测试的覆盖率</li><li>vue-loader：加载 Vue.js 单文件组件</li><li>i18n-loader: 国际化</li><li>cache-loader: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里</li></ol><h2 id="有哪些常见的Plugin-你用过哪些Plugin"><a href="#有哪些常见的Plugin-你用过哪些Plugin" class="headerlink" title="有哪些常见的Plugin?你用过哪些Plugin?"></a>有哪些常见的Plugin?你用过哪些Plugin?</h2><ol><li>define-plugin：定义环境变量 (Webpack4 之后指定 mode 会自动配置)</li><li>ignore-plugin：忽略部分文件</li><li>html-webpack-plugin：简化 HTML 文件创建 (依赖于 html-loader)</li><li>web-webpack-plugin：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用</li><li>uglifyjs-webpack-plugin：不支持 ES6 压缩 (Webpack4 以前)</li><li>terser-webpack-plugin: 支持压缩 ES6 (Webpack4)</li><li>webpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度</li><li>mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)</li><li>serviceworker-webpack-plugin：为网页应用增加离线缓存功能</li><li>clean-webpack-plugin: 目录清理</li><li>ModuleConcatenationPlugin: 开启 Scope Hoisting</li><li>speed-measure-webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)</li><li>webpack-bundle-analyzer: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)</li></ol><h2 id="那你再说一说Loader和Plugin的区别"><a href="#那你再说一说Loader和Plugin的区别" class="headerlink" title="那你再说一说Loader和Plugin的区别?"></a>那你再说一说Loader和Plugin的区别?</h2><p>  Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。<br>  Plugin 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p><p>  Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。<br>  Plugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。</p><h2 id="Webpack构建流程简单说一下"><a href="#Webpack构建流程简单说一下" class="headerlink" title="Webpack构建流程简单说一下"></a>Webpack构建流程简单说一下</h2><p>  Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：<br>    1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；<br>    2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；<br>    3. 确定入口：根据配置中的 entry 找出所有的入口文件；<br>    4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；<br>    5. 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；<br>    6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；<br>    7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p><p>  在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><p>  简单说：<br>    初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler<br>    编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理<br>    输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中</p><h2 id="使用webpack开发时，你用过哪些可以提高效率的插件"><a href="#使用webpack开发时，你用过哪些可以提高效率的插件" class="headerlink" title="使用webpack开发时，你用过哪些可以提高效率的插件?"></a>使用webpack开发时，你用过哪些可以提高效率的插件?</h2><ol><li>webpack-dashboard：可以更友好的展示相关打包信息。</li><li>webpack-merge：提取公共配置，减少重复配置代码</li><li>speed-measure-webpack-plugin：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。</li><li>size-plugin：监控资源体积变化，尽早发现问题</li><li>HotModuleReplacementPlugin：模块热替换</li></ol><h2 id="source-map是什么-生产环境怎么用"><a href="#source-map是什么-生产环境怎么用" class="headerlink" title="source map是什么?生产环境怎么用?"></a>source map是什么?生产环境怎么用?</h2><p>  source map 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。<br>  map文件只要不打开开发者工具，浏览器是不会加载的。</p><p>  线上环境一般有三种处理方案：<br>    1. hidden-source-map：借助第三方错误监控平台 Sentry 使用<br>    2. nosources-source-map：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高<br>    3. sourcemap：通过 nginx 设置将 .map 文件只对白名单开放(公司内网)</p><p>  注意：避免在生产中使用 inline- 和 eval-，因为它们会增加 bundle 体积大小，并降低整体性能。</p><h2 id="模块打包原理知道吗"><a href="#模块打包原理知道吗" class="headerlink" title="模块打包原理知道吗?"></a>模块打包原理知道吗?</h2><p>  Webpack 实际上为每个模块创造了一个可以导出和导入的环境，本质上并没有修改 代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致。</p><h2 id="文件监听原理呢"><a href="#文件监听原理呢" class="headerlink" title="文件监听原理呢?"></a>文件监听原理呢?</h2><p>  在发现源码发生变化时，自动重新构建出新的输出文件。<br>  Webpack开启监听模式，有两种方式：<br>    1. 启动 webpack 命令时，带上 –watch 参数<br>    2. 在配置 webpack.config.js 中设置 watch:true</p><p>  缺点：每次需要手动刷新浏览器<br>  原理：轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 aggregateTimeout 后再执行。</p><h2 id="是否写过Loader？简单描述一下编写loader的思路"><a href="#是否写过Loader？简单描述一下编写loader的思路" class="headerlink" title="是否写过Loader？简单描述一下编写loader的思路"></a>是否写过Loader？简单描述一下编写loader的思路</h2><p>  Loader 支持链式调用，所以开发上需要严格遵循“单一职责”，每个 Loader 只负责自己需要负责的事情。</p><ol><li>Loader 运行在 Node.js 中，我们可以调用任意 Node.js 自带的 API 或者安装第三方模块进行调用</li><li>Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串，当某些场景下 Loader 处理二进制文件时，需要通过 exports.raw = true 告诉 Webpack 该 Loader 是否需要二进制数据</li><li>尽可能的异步化 Loader，如果计算量很小，同步也可以</li><li>Loader 是无状态的，我们不应该在 Loader 中保留状态</li><li>使用 loader-utils 和 schema-utils 为我们提供的实用工具</li><li>加载本地 Loader 方法<br>6.1. Npm link<br>6.2. ResolveLoader</li></ol><h2 id="是否写过Plugin？简单描述一下编写Plugin的思路？"><a href="#是否写过Plugin？简单描述一下编写Plugin的思路？" class="headerlink" title="是否写过Plugin？简单描述一下编写Plugin的思路？"></a>是否写过Plugin？简单描述一下编写Plugin的思路？</h2><p>  webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在特定的阶段钩入想要添加的自定义功能。Webpack 的 Tapable 事件流机制保证了插件的有序性，使得整个系统扩展性良好。</p><ol><li>compiler 暴露了和 Webpack 整个生命周期相关的钩子</li><li>compilation 暴露了与模块和依赖有关的粒度更小的事件钩子</li><li>插件需要在其原型上绑定apply方法，才能访问 compiler 实例</li><li>传给每个插件的 compiler 和 compilation对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件</li><li>找出合适的事件点去完成想要的功能:<br>5.1 emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改(emit 事件是修改 Webpack 输出资源的最后时机)<br>5.2 watch-run 当依赖的文件发生变化时会触发<br>异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住</li></ol><h2 id="webpack的热更新是如何做到的？说明其原理"><a href="#webpack的热更新是如何做到的？说明其原理" class="headerlink" title="webpack的热更新是如何做到的？说明其原理"></a>webpack的热更新是如何做到的？说明其原理</h2><p>  Webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p><p>  HMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该chunk的增量更新。</p><p>  后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。</p><h2 id="如何利用webpack来优化前端性能？（提高性能和体验）"><a href="#如何利用webpack来优化前端性能？（提高性能和体验）" class="headerlink" title="如何利用webpack来优化前端性能？（提高性能和体验）"></a>如何利用webpack来优化前端性能？（提高性能和体验）</h2><p>  用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。</p><pre><code>1. 压缩代码。删除多余的代码、注释、简化代码的写法等等方式。2. 利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径3. 删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现4. 提取公共代码。</code></pre><h2 id="如何优化-Webpack-的构建速度？"><a href="#如何优化-Webpack-的构建速度？" class="headerlink" title="如何优化 Webpack 的构建速度？"></a>如何优化 Webpack 的构建速度？</h2><ol><li>使用高版本的 Webpack 和 Node.js</li><li>多进程/多实例构建：HappyPack(不维护了)、thread-loader</li><li>压缩代码：<br>3.1 多进程并行压缩：<br> 3.1.1 webpack-paralle-uglify-plugin<br> 3.1.2 uglifyjs-webpack-plugin 开启 parallel 参数 (不支持ES6)<br> 3.1.3 terser-webpack-plugin 开启 parallel 参数<br>3.2 通过 mini-css-extract-plugin 提取 Chunk 中的 CSS 代码到单独文件，通过 css-loader 的 minimize 选项开启 cssnano 压缩 CSS。</li><li>图片压缩：<br>4.1 使用基于 Node 库的 imagemin (很多定制选项、可以处理多种图片格式)<br>4.2 配置 image-webpack-loader</li><li>缩小打包作用域：<br>5.1 exclude/include (确定 loader 规则范围)<br>5.2 resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)<br>5.3 resolve.mainFields 只采用 main 字段作为入口文件描述字段 (减少搜索步骤，需要考虑到所有运行时依赖的第三方模块的入口文件描述字段)<br>5.4 resolve.extensions 尽可能减少后缀尝试的可能性<br>5.5 noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)<br>5.6 IgnorePlugin (完全排除模块)<br>5.7 合理使用alias</li><li>提取页面公共资源：<br>6.1 基础包分离：<br> 6.1.1 使用 html-webpack-externals-plugin，将基础包通过 CDN 引入，不打入 bundle 中<br> 6.1.2 使用 SplitChunksPlugin 进行(公共脚本、基础包、页面公共文件)分离(Webpack4内置) ，替代了 CommonsChunkPlugin 插件</li><li>DLL：<br>7.1 使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。<br>7.2 HashedModuleIdsPlugin 可以解决模块数字id问题</li><li>充分利用缓存提升二次构建速度：<br>8.1 babel-loader 开启缓存<br>8.2 terser-webpack-plugin 开启缓存<br>8.3 使用 cache-loader 或者 hard-source-webpack-plugin</li><li>Tree shaking：<br>9.1 打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle中去掉(只能对ES6 Modlue生效) 开发中尽可能使用ES6 Module的模块，提高tree shaking效率<br>9.2 禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking<br>9.3 使用 PurifyCSS(不在维护) 或者 uncss 去除无用 CSS 代码:<br> 9.3.1 purgecss-webpack-plugin 和 mini-css-extract-plugin配合使用(建议)</li><li>Scope hoisting<br>10.1 构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突<br>10.2 必须是ES6的语法，因为有很多第三方库仍采用 CommonJS 语法，为了充分发挥 Scope hoisting 的作用，需要配置 mainFields 对第三方模块优先采用 jsnext:main 中指向的ES6模块化语法</li><li>动态Polyfill： 建议采用 polyfill-service 只给用户返回需要的polyfill，社区维护。 (部分国内奇葩浏览器UA可能无法识别，但可以降级返回所需全部polyfill)</li></ol><h2 id="如何对bundle体积进行监控和分析"><a href="#如何对bundle体积进行监控和分析" class="headerlink" title="如何对bundle体积进行监控和分析?"></a>如何对bundle体积进行监控和分析?</h2><p>  VSCode 中有一个插件 Import Cost 可以帮助我们对引入模块的大小进行实时监测，还可以使用 webpack-bundle-analyzer 生成 bundle 的模块组成图，显示所占体积。bundlesize 工具包可以进行自动化资源体积监控。</p><h2 id="文件指纹是什么？怎么用？"><a href="#文件指纹是什么？怎么用？" class="headerlink" title="文件指纹是什么？怎么用？"></a>文件指纹是什么？怎么用？</h2><p>  文件指纹是打包后输出的文件名的后缀。<br>    1. Hash：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改<br>    2. Chunkhash：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash<br>    3. Contenthash：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变</p><p>  JS的文件指纹设置: 设置 output 的 filename，用 chunkhash。<br>  CSS的文件指纹设置: 设置 MiniCssExtractPlugin 的 filename，使用 contenthash。<br>  图片的文件指纹设置: 设置file-loader的name，使用hash。</p><h2 id="代码分割的本质是什么？有什么意义呢？"><a href="#代码分割的本质是什么？有什么意义呢？" class="headerlink" title="代码分割的本质是什么？有什么意义呢？"></a>代码分割的本质是什么？有什么意义呢？</h2><p>  代码分割的本质其实就是在源代码直接上线和打包成唯一脚本main.bundle.js这两种极端方案之间的一种更适合实际场景的中间状态。</p><p>  「用可接受的服务器性能压力增加来换取更好的用户体验。」</p><p>  源代码直接上线：虽然过程可控，但是http请求多，性能开销大。</p><p>  打包成唯一脚本：一把梭完自己爽，服务器压力小，但是页面空白期长，用户体验不好。</p><h2 id="聊一聊Babel原理吧"><a href="#聊一聊Babel原理吧" class="headerlink" title="聊一聊Babel原理吧"></a>聊一聊Babel原理吧</h2><p>  大多数JavaScript Parser遵循 estree 规范，Babel 最初基于 acorn 项目(轻量级现代 JavaScript 解析器) Babel大概分为三大部分：<br>    1. 解析：将代码转换成 AST<br>      1.1 词法分析：将代码(字符串)分割为token流，即语法单元成的数组<br>      1.2 语法分析：分析token流(上面生成的数组)并生成 AST<br>    2. 转换：访问 AST 的节点进行变换操作生产新的 AST<br>      2.1 Taro就是利用 babel 完成的小程序语法转换<br>    3. 生成：以新的 AST 为基础生成代码</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react面试题</title>
    <link href="/articles/2020/12/08/react%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/articles/2020/12/08/react%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用pureComponent"><a href="#为什么要使用pureComponent" class="headerlink" title="为什么要使用pureComponent"></a>为什么要使用pureComponent</h2><p>  当使用component时，父组件的state或prop更新时，无论子组件的state、prop是否更新，都会触发子组件的更新，这会形成很多没必要的render，浪费很多性能；pureComponent的优点在于：pureComponent在shouldComponentUpdate只进行浅层的比较，只要外层对象没变化，就不会触发render,减少了不必要的render，当遇到复杂数据结构时，可以将一个组件拆分成多个pureComponent，以这种方式来实现复杂数据结构，以期达到节省不必要渲染的目的，如：表单、复杂列表、文本域等情况；</p><h2 id="purecomponent-和-component-区别"><a href="#purecomponent-和-component-区别" class="headerlink" title="purecomponent 和 component 区别"></a>purecomponent 和 component 区别</h2><ol><li><p>pureComponent通过prop和state的浅比较（shallowEqual）来实现shouldComponentUpdate,</p></li><li><p>component是需要开发者在shouldComponentUpdate钩子函数中自己写render逻辑的，在某些情况下可以使用pureComponent来提升性能。</p><p>浅比较（shallowEqual）：是react源码中的一个函数，它代替了shouldComponentUpdate的工作, 只比较外层数据结构，只要外层相同，则认为没有变化，不会深层次比较数据。</p></li></ol><h2 id="pureComponent的优缺点"><a href="#pureComponent的优缺点" class="headerlink" title="pureComponent的优缺点"></a>pureComponent的优缺点</h2><p>  优点：<br>    不需要开发者使用shouldComponentUpdate就可使用简单的判断来提升性能；<br>  缺点：<br>    由于进行的是浅比较，可能由于深层的数据不一致导致而产生错误的否定判断，从而导致页面得不到更新；</p><h2 id="setState是同步还是异步的"><a href="#setState是同步还是异步的" class="headerlink" title="setState是同步还是异步的"></a>setState是同步还是异步的</h2><ol><li>setState只在合成事件(例如： onClick、onChange )和钩子函数(生命周期)中是“异步”的，在原生事件(例如： addEventListener ， 或者原生js、jq直接 document.querySelector().onclick)和setTimeout 中都是同步的。</li><li>setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</li><li>setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。</li></ol><h2 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h2><p>  挂载过程， 当组件实例被创建并插入DOM中时，其生命周期调用顺序如下：<br>    1. constructor()<br>    2. static getDerivedStateFromProps()<br>    3. render()<br>    4. componentDidMount()</p><p>  注意： 在这个阶段的componentWillMount()生命周期即将过时，在新代码中应该避免使用。</p><p>  更新过程， 当组件的props或state发生变化时会触发更新，组件更新的生命周期调用顺序如下：<br>    1. static getDerivedStateFromProps()<br>    2. shouldComponentUpdate()<br>    3. render()<br>    4. getSnapshotBeforeUpdate()<br>    5. componentDidUpdate()</p><p>  注意： 在这个阶段的componentWillUpdate()、componentWillReceiveProps()生命周期即将过时，在新代码中应该避免使用。</p><p>  卸载过程， 当组件从DOM中移除时，组件更新的生命周期调用顺序如下：<br>    1. componentWillUnmount()</p><p>  错误处理， 当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：<br>    1. static getDerivedStateFromError()<br>    2. componentDidCatch()</p><h2 id="常用React-Hooks-方法"><a href="#常用React-Hooks-方法" class="headerlink" title="常用React Hooks 方法"></a>常用React Hooks 方法</h2><ol><li>useState<br>useState相当于class的state的赋值操作</li><li>useEffect<br>useEffect Hook 可以看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。通常用于请求数据，事件处理，订阅等相关操作</li><li>useLayoutEffect<br>在大多数情况下，我们都可以使用useEffect处理副作用，但是，如果副作用是跟DOM相关的，就需要使用useLayoutEffect。useLayoutEffect中的副作用会在DOM更新之后同步执行。</li><li>useReducer<br>useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。</li><li>useContext<br>接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。</li><li>useRef<br>相当于class中的this</li><li>useMemo<br>用于缓存计算结果。类似vue的计算属性，函数只依赖count的变化</li><li>useCallback<br>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)</li></ol><h2 id="为什么使用key"><a href="#为什么使用key" class="headerlink" title="为什么使用key"></a>为什么使用key</h2><p>  react的diff算法是把key当成唯一id然后比对组件的value来确定是否需要更新的，所以如果没有key，react将不会知道该如何更新组件。<br>  不传默认使用数组的索引作为key。<br>  react根据key来决定是销毁重新创建组件还是更新组件，原则是：<br>    1. key相同，组件有所变化，react会只更新组件对应变化的属性。<br>    2. key不同，组件会销毁之前的组件，将整个组件重新渲染。</p><h2 id="Redux及其工作原理"><a href="#Redux及其工作原理" class="headerlink" title="Redux及其工作原理"></a>Redux及其工作原理</h2><pre><code>Redux 是 React的一个状态管理库，它基于flux。 Redux简化了React中的单向数据流。 Redux将状态管理完全从React中抽象出来。工作原理：   1. 组件连接到 redux ，如果要访问 redux，需要派出一个包含 id和负载(payload) 的 action。action 中的 payload 是可选的，action 将其转发给 Reducer。  2. 当reducer收到action时，通过 swithc…case 语法比较 action 中type。 匹配时，更新对应的内容返回新的 state。  3. 当Redux状态更改时，连接到Redux的组件将接收新的状态作为props。当组件接收到这些props时，它将进入更新阶段并重新渲染 UI。</code></pre><h2 id="什么是-Fragments"><a href="#什么是-Fragments" class="headerlink" title="什么是 Fragments"></a>什么是 Fragments</h2><p>  React 中一个常见模式是为一个组件返回多个元素。Fragments 可以让你聚合一个子元素列表，并且不在DOM中增加额外节点。</p><h2 id="什么是传送门-Portals"><a href="#什么是传送门-Portals" class="headerlink" title="什么是传送门(Portals)"></a>什么是传送门(Portals)</h2><p>  和vue3新增的teleport一样，是 Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。</p><h2 id="如何提高性能"><a href="#如何提高性能" class="headerlink" title="如何提高性能"></a>如何提高性能</h2><ol><li>减少渲染的节点/降低渲染计算量(复杂度)<br>1.1 不要在渲染函数都进行不必要的计算<br>1.2 减少不必要的嵌套<br>1.3 虚拟列表只渲染当前视口可见元素:<br>1.4 惰性渲染的初衷本质上和虚表一样，也就是说我们只在必要时才去渲染对应的节点。<br>1.5 选择合适的样式方案</li><li>避免重新渲染<br>减少不必要的重新渲染也是 React 组件性能优化的重要方向. 为了避免不必要的组件重新渲染需要在做到两点:<br>2.1 保证组件纯粹性。即控制组件的副作用，如果组件有副作用则无法安全地缓存渲染结果<br>2.2 通过shouldComponentUpdate生命周期函数来比对 state 和 props, 确定是否要重新渲染。对于函数组件可以使用React.memo包装</li><li>简化 props ， 如果一个组件的 props 太复杂一般意味着这个组件已经违背了‘单一职责’，首先应该尝试对组件进行拆解. 另外复杂的 props 也会变得难以维护, 比如会影响shallowCompare效率, 还会让组件的变动变得难以预测和调试. 简化的 props 更容易理解, 且可以提高组件缓存的命中率</li><li>不变的事件处理器<br>4.1 避免使用箭头函数形式的事件处理器(假设组件是一个复杂的 PureComponent, 这里使用箭头函数，其实每次渲染时都会创建一个新的事件处理器，这会导致组件始终会被重新渲染.)<br>4.2 使用useCallback来包装事件处理器，尽量给下级组件暴露一个静态的函数<br>4.3 设计更方便处理的 Event Props</li><li>不可变数据： 不可变数据可以让状态变得可预测，也让 shouldComponentUpdate ‘浅比较’变得更可靠和高效.</li><li>简化 state： 不是所有状态都应该放在组件的 state 中. 例如缓存数据。</li><li>使用 recompose 精细化比对</li><li>精细化渲染<br>8.1 响应式数据的精细化渲染： 大部分情况下，响应式数据可以实现视图精细化的渲染, 但它还是不能避免开发者写出低效的程序. 本质上还是因为组件违背‘单一职责’.<br>8.2 不要滥用 Context： 首先要理解 Context API 的更新特点，它是可以穿透React.memo或者shouldComponentUpdate的比对的，也就是说，一旦 Context 的 Value 变动，所有依赖该 Context 的组件会全部 forceUpdate.使用 Context API 要遵循一下原则:明确状态作用域, Context 只放置必要的，关键的，被大多数组件所共享的状态。比较典型的是鉴权状态</li></ol><h2 id="如何在重新加载页面时保留数据"><a href="#如何在重新加载页面时保留数据" class="headerlink" title="如何在重新加载页面时保留数据"></a>如何在重新加载页面时保留数据</h2><p>  每当重新加载应用程序时，我们使用浏览器localstorage来保存应用程序的状态。我们将整个存储数据保存在localstorage中，每当有页面刷新或重新加载时，我们从localstorage加载状态。</p><h2 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h2><p>  虚拟DOM（VDOM）它是真实DOM的内存表示,一种编程概念，一种模式。它会和真实的DOM同步，比如通过ReactDOM这种库，这个同步的过程叫做调和(reconcilation)。<br>  虚拟DOM更多是一种模式，不是一种特定的技术。</p><h2 id="类组件和函数组件之间有什么区别"><a href="#类组件和函数组件之间有什么区别" class="headerlink" title="类组件和函数组件之间有什么区别"></a>类组件和函数组件之间有什么区别</h2><ol><li><p>类组件（Class components）<br>1.1 无论是使用函数或是类来声明一个组件，它决不能修改它自己的 props ， 所有 React 组件都必须是纯函数，并禁止修改其自身 props。<br>1.2 React是单项数据流，父组件改变了属性，那么子组件视图会更新， 属性 props是外界传递过来的，状态 state是组件本身的，状态可以在组件中任意修改，组件的属性和状态改变都会更新视图。</p></li><li><p>函数组件（functional component）<br>2.1 函数组件接收一个单一的 props 对象并返回了一个React元素</p><p>区别：<br>函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。</p><table><thead><tr><th>区别</th><th>函数组件</th><th>类组件</th></tr></thead><tbody><tr><td>是否有 this</td><td>没有</td><td>有</td></tr><tr><td>是否有生命周期</td><td>没有</td><td>有</td></tr><tr><td>是否有状态 state</td><td>没有</td><td>有</td></tr></tbody></table></li></ol><h2 id="React中的refs作用是什么"><a href="#React中的refs作用是什么" class="headerlink" title="React中的refs作用是什么"></a>React中的refs作用是什么</h2><p>  Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。</p><h2 id="描述React事件处理"><a href="#描述React事件处理" class="headerlink" title="描述React事件处理"></a>描述React事件处理</h2><p>  为了解决跨浏览器兼容性问题，React中的事件处理程序将传递SyntheticEvent实例，该实例是React跨浏览器本机事件的跨浏览器包装器。这些综合事件具有与您惯用的本机事件相同的界面，除了它们在所有浏览器中的工作方式相同。<br>  有点有趣的是，React实际上并未将事件附加到子节点本身。React将使用单个事件侦听器在顶层侦听所有事件。这对性能有好处，也意味着React在更新DOM时无需担心跟踪事件监听器。</p><h2 id="state-和-props有什么区别"><a href="#state-和-props有什么区别" class="headerlink" title="state 和 props有什么区别"></a>state 和 props有什么区别</h2><p>  state 和 props都是普通的JavaScript对象。尽管它们两者都具有影响渲染输出的信息，但它们在组件方面的功能不同。即：<br>    1. props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。<br>    2. state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。</p><h2 id="如何创建refs"><a href="#如何创建refs" class="headerlink" title="如何创建refs"></a>如何创建refs</h2><p>  Refs 是使用 React.createRef() 方法创建的，并通过 ref 属性添加到 React 元素上。为了在整个组件中使用refs，只需将 ref 分配给构造函数中的实例属性</p><h2 id="什么是高阶组件"><a href="#什么是高阶组件" class="headerlink" title="什么是高阶组件"></a>什么是高阶组件</h2><p>  高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。基本上，这是从React的组成性质派生的一种模式，我们称它们为“纯”组件， 因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件的任何行为。<br>    1. 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧<br>    2. 高阶组件的参数为一个组件返回一个新的组件<br>    3. 组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件</p><h2 id="constructor中super与props参数一起使用的目的是什么"><a href="#constructor中super与props参数一起使用的目的是什么" class="headerlink" title="constructor中super与props参数一起使用的目的是什么"></a>constructor中super与props参数一起使用的目的是什么</h2><p>  在调用方法之前，子类构造函数无法使用this引用super()。<br>  在ES6中，在子类的constructor中必须先调用super才能引用this。<br>  在constructor中可以使用this.props</p><h2 id="什么是受控组件"><a href="#什么是受控组件" class="headerlink" title="什么是受控组件"></a>什么是受控组件</h2><p>  在HTML当中，像 input,textarea , 和  select 这类表单元素会维持自身状态，并根据用户输入进行更新。但在React中，可变的状态通常保存在组件的状态属性中，并且只能用 setState() 方法进行更新。</p><h2 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h2><p>  非受控组件，即组件的状态不受React控制的组件</p><h2 id="什么是JSX"><a href="#什么是JSX" class="headerlink" title="什么是JSX"></a>什么是JSX</h2><p>  JSX即JavaScript XML。一种在React组件内部构建标签的类XML语法。JSX为react.js开发的一套语法糖，也是react.js的使用基础。React在不使用JSX的情况下一样可以工作，然而使用JSX可以提高组件的可读性，因此推荐使用JSX。</p><p>  优点：<br>    1. 允许使用熟悉的语法来定义 HTML 元素树；<br>    2. 提供更加语义化且移动的标签；<br>    3. 程序结构更容易被直观化；<br>    4. 抽象了 React Element 的创建过程；<br>    5. 可以随时掌控 HTML 标签以及生成这些标签的代码；<br>    6. 是原生的 JavaScript。</p><h2 id="为什么不直接更新state状态"><a href="#为什么不直接更新state状态" class="headerlink" title="为什么不直接更新state状态"></a>为什么不直接更新state状态</h2><p>  如果进行直接赋值更新状态，那么它将不会重新渲染组件。<br>  而是使用setState()方法。它计划对组件状态对象的更新。状态改变时，组件通过重新渲染做出响应<br>  注意：可以分配状态的唯一位置是构造函数。</p><h2 id="使用React-Hooks有什么优势"><a href="#使用React-Hooks有什么优势" class="headerlink" title="使用React Hooks有什么优势"></a>使用React Hooks有什么优势</h2><p>  hooks 是react 16.8 引入的特性，他允许你在不写class的情况下操作state 和react的其他特性。<br>  hooks 只是多了一种写组件的方法，使编写一个组件更简单更方便，同时可以自定义hook把公共的逻辑提取出来，让逻辑在多个组件之间共享。</p><p>  Hook 是什么：<br>    Hook 是一个特殊的函数，它可以让你“钩入” React 的特性。例如，useState 是允许你在 React 函数组件中添加 state 的 Hook。</p><p>  ReactHooks的优点：<br>    1. 无需复杂的DOM结构<br>    2. 简洁易懂</p><h2 id="React中的StrictMode是什么"><a href="#React中的StrictMode是什么" class="headerlink" title="React中的StrictMode是什么"></a>React中的StrictMode是什么</h2><p>  React的StrictMode是一种帮助程序组件，可以帮助您编写更好的react组件，您可以使用包装一些组件，StrictMode 并且基本上可以：<br>    1. 验证内部组件是否遵循某些推荐做法，如果不在控制台中，则会发出警告。<br>    2. 验证不赞成使用的方法，如果使用了严格模式，则会在控制台中警告您。<br>    3. 通过识别潜在风险来帮助您预防某些副作用。</p><h2 id="为什么类方法需要绑定"><a href="#为什么类方法需要绑定" class="headerlink" title="为什么类方法需要绑定"></a>为什么类方法需要绑定</h2><p>  在JavaScript中，this的值取决于当前上下文。在React类的组件方法中，开发人员通常希望它引用组件的当前实例，因此有必要将这些方法绑定到该实例。<br>  通常，这是在构造函数中完成的</p><h2 id="描述Flux与MVC"><a href="#描述Flux与MVC" class="headerlink" title="描述Flux与MVC"></a>描述Flux与MVC</h2><p>  传统的MVC模式在分离数据（模型），UI（视图）和逻辑（控制器）的关注方面效果很好，但是MVC架构经常遇到两个主要问题：<br>    1. 数据流定义不佳：跨视图进行的级联更新通常会导致纠结的事件网，难以调试。<br>    2. 缺乏数据完整性：可以从任何地方对模型数据进行突变，从而在整个UI上产生不可预测的结果。</p><p>  使用Flux模式，复杂的UI不再受到级联更新的困扰。任何给定的React组件都将能够根据商店提供的数据重建其状态。Flux模式还通过限制对共享数据的直接访问来增强数据完整性。</p><h2 id="React-context是什么"><a href="#React-context是什么" class="headerlink" title="React context是什么"></a>React context是什么</h2><p>  使用Context，可以跨越组件进行数据传递。</p><h2 id="React-Fiber是什么"><a href="#React-Fiber是什么" class="headerlink" title="React Fiber是什么"></a>React Fiber是什么</h2><p>  React Fiber 并不是所谓的纤程（微线程、协程），而是一种基于浏览器的单线程调度算法，背后的支持 API 是大名鼎鼎的：requestIdleCallback。<br>  Fiberl是一种将 recocilation （递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-router面试题</title>
    <link href="/articles/2020/12/08/vue-router%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/articles/2020/12/08/vue-router%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue-router-导航守卫有哪些"><a href="#Vue-router-导航守卫有哪些" class="headerlink" title="Vue-router 导航守卫有哪些"></a>Vue-router 导航守卫有哪些</h2><p>  全局前置/钩子：beforeEach、beforeResolve、afterEach<br>  路由独享的守卫：beforeEnter<br>  组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</p><h2 id="vue-router-hash-模式和-history-模式有什么区别"><a href="#vue-router-hash-模式和-history-模式有什么区别" class="headerlink" title="vue-router hash 模式和 history 模式有什么区别"></a>vue-router hash 模式和 history 模式有什么区别</h2><p>  区别：<br>    1. url 展示上，hash 模式有“#”，history 模式没有<br>    2. 刷新页面时，hash 模式可以正常加载到 hash 值对应的页面，而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由。<br>    3. 兼容性。hash 可以支持低版本浏览器和 IE。</p><h2 id="vue-router-hash-模式和-history-模式是如何实现的"><a href="#vue-router-hash-模式和-history-模式是如何实现的" class="headerlink" title="vue-router hash 模式和 history 模式是如何实现的"></a>vue-router hash 模式和 history 模式是如何实现的</h2><p>  hash 模式：<br>    #后面 hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面。同时通过监听 hashchange 事件可以知道 hash 发生了哪些变化，然后根据 hash 变化来实现更新页面部分内容的操作。</p><p>  history 模式：<br>    history 模式的实现，主要是 HTML5 标准发布的两个 API，pushState 和 replaceState，这两个 API 可以在改变 url，但是不会发送请求。这样就可以监听 url 变化来实现更新页面部分内容的操作。</p><h2 id="route和-router的区别是什么"><a href="#route和-router的区别是什么" class="headerlink" title="$route和 $router的区别是什么"></a>$route和 $router的区别是什么</h2><p>  $router为VueRouter的实例，是一个全局路由对象，包含了路由跳转的方法、钩子函数等。<br>  $route 是路由信息对象||跳转的路由对象，每一个路由都会有一个route对象，是一个局部对象，包含path,params,hash,query,fullPath,matched,name等路由信息参数。</p><h2 id="vue-router-传参"><a href="#vue-router-传参" class="headerlink" title="vue-router 传参"></a>vue-router 传参</h2><p>  1.使用Params:<br>    1.1 只能使用name，不能使用path<br>    1.2 参数不会显示在路径上<br>    1.3 浏览器强制刷新参数会被清空</p><p>  2.使用Query:<br>    2.1 参数会显示在路径上，刷新不会被清空<br>    2.2 name 可以使用path路径</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vuex面试题</title>
    <link href="/articles/2020/12/07/Vuex%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/articles/2020/12/07/Vuex%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="Vuex和单纯的全局对象有什么区别"><a href="#Vuex和单纯的全局对象有什么区别" class="headerlink" title="Vuex和单纯的全局对象有什么区别"></a>Vuex和单纯的全局对象有什么区别</h2><p>  Vuex和全局对象主要有两大区别：<br>    1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>    2. 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p><h2 id="为什么-Vuex-的-mutation-中不能做异步操作"><a href="#为什么-Vuex-的-mutation-中不能做异步操作" class="headerlink" title="为什么 Vuex 的 mutation 中不能做异步操作"></a>为什么 Vuex 的 mutation 中不能做异步操作</h2><p>  Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。<br>  每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难</p><h2 id="vuex有哪几种属性"><a href="#vuex有哪几种属性" class="headerlink" title="vuex有哪几种属性"></a>vuex有哪几种属性</h2><p>  有五种，分别是 State、 Getter、Mutation 、Action、 Module。</p><h2 id="vuex的State特性是"><a href="#vuex的State特性是" class="headerlink" title="vuex的State特性是"></a>vuex的State特性是</h2><ol><li>Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于与一般Vue对象里面的data</li><li>state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新</li><li>它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</li></ol><h2 id="vuex的Getter特性是"><a href="#vuex的Getter特性是" class="headerlink" title="vuex的Getter特性是"></a>vuex的Getter特性是</h2><ol><li>getters 可以对State进行计算操作，它就是Store的计算属性</li><li>虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用</li><li>如果一个状态只在一个组件内使用，是可以不用getters</li></ol><h2 id="vuex的Mutation-Action特性是"><a href="#vuex的Mutation-Action特性是" class="headerlink" title="vuex的Mutation , Action特性是"></a>vuex的Mutation , Action特性是</h2><ol><li>Action 类似于 mutation，不同在于: Action 提交的是 mutation，而不是直接变更状态</li><li>Action 可以包含任意异步操作</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue面试题集锦</title>
    <link href="/articles/2020/12/07/vue%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <url>/articles/2020/12/07/vue%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="如何保留页面状态，例如列表跳转到详情回退还是在原来位置"><a href="#如何保留页面状态，例如列表跳转到详情回退还是在原来位置" class="headerlink" title="如何保留页面状态，例如列表跳转到详情回退还是在原来位置"></a>如何保留页面状态，例如列表跳转到详情回退还是在原来位置</h2><p>  利用vue 内置组件 keep-alive 以及 vue-router实现</p><p>  具体做法： 在路由表中配置 meta 字段， 写入两个属性用来判断是否需要缓存并且记录 滚动条位置，在vue页面中， 使用 beforeRouteEnter 和 beforeRouteLeave两个api判断进入来源并判断meta标签的属性是否需要缓存并设置滚动条位置</p><p>  如果还需要更新列表页的数据， 那么还应该记录 用户点击的 列表id ， 并在返回的时候， 在 keep-alive 中的activated和deactivated生命周期中更新处理用户更改的那条数据</p><h2 id="自己写过自定义指令吗"><a href="#自己写过自定义指令吗" class="headerlink" title="自己写过自定义指令吗"></a>自己写过自定义指令吗</h2><p>  自定义指令是 vue 提供给开发者对普通 DOM 元素进行底层操作api 。 它可以帮助我们实现一些通用的dom操作，如 focus 等。</p><p>  注册一个全局的自定义指令可以使用 Vue.directive()<br>  注册一个局部的自定义指令，vue文件的options还接受一个 directives 选项</p><p>  注册之后， 使用的方式是在任何元素上使用新的 v-xx 属性 。 这个 xx 是 directive 中的第一个参数名称， 例如 Vue.directive(‘focus’ , {…})</p><p>  一个指令定义对象可以提供如下几个钩子函数 (均为可选)：<br>    1. bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。<br>    2. inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。<br>    3. update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。<br>    4. componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。<br>    5. unbind：只调用一次，指令与元素解绑时调用。</p><p>  接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。</p><p>  钩子函数参数:<br>    1. el：指令所绑定的元素，可以用来直接操作 DOM 。<br>    2. binding：一个对象，包含以下属性：<br>      2.1 name：指令名，不包括 v- 前缀。<br>      2.2 value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。<br>      2.3 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。<br>      2.4 expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。<br>      2.5 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。<br>      2.6 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。<br>    3. vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。<br>    4. oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</p><p>  除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。<br>  记住，指令函数能够接受所有合法的 JavaScript 表达式。</p><h2 id="如何强制更新例如像elementui里面的样式"><a href="#如何强制更新例如像elementui里面的样式" class="headerlink" title="如何强制更新例如像elementui里面的样式"></a>如何强制更新例如像elementui里面的样式</h2><ol><li>新添加 style 标签 ，去除 scoped （ 慎用 ， 去污染全局 ）</li><li>深度作用选择器 ， 原生 css 你可以使用 &gt;&gt;&gt; 操作符 ， 有些像 Sass 之类的预处理器无法正确解析 &gt;&gt;&gt; ； 这种情况下你可以使用 /deep/ 或 ::v-deep 操作符取而代之——两者都是 &gt;&gt;&gt; 的别名，同样可以正常工作。 （ scss 中使用 /deep/ 会报错的同学可以使用 ::v-deep , 具体原因是sass-loader 导致的， 感兴趣可自查 ）</li></ol><h2 id="为什么避免-v-if-和-v-for-用在一起，解决办法是什么"><a href="#为什么避免-v-if-和-v-for-用在一起，解决办法是什么" class="headerlink" title="为什么避免 v-if 和 v-for 用在一起，解决办法是什么"></a>为什么避免 v-if 和 v-for 用在一起，解决办法是什么</h2><p>  如果直接 v-if 和 v-for 同时使用，在vue中会优先执行v-for, 当v-for把所有内容全部遍历之后 , v-if再对已经遍历的元素进行删除 , 造成了加载的浪费 。</p><p>  解决办法是： 使用计算属性将不需要的数据先过滤掉，再通过 v-for 显示在页面上。</p><h2 id="组件传值有哪些方法"><a href="#组件传值有哪些方法" class="headerlink" title="组件传值有哪些方法"></a>组件传值有哪些方法</h2><p>  父传子：<br>    1.属性props</p><pre><code>  <pre><code class="hljs JavaScript"><span class="hljs-comment">// child</span>props: &#123; <span class="hljs-attr">msg</span>: <span class="hljs-built_in">String</span> &#125;<span class="hljs-comment">// parent</span>&lt;HelloWorld msg=<span class="hljs-string">&quot;Welcome to Your Vue.js App&quot;</span>/&gt;</code></pre>2. 引用refs  <pre><code class="hljs JavaScript"><span class="hljs-comment">// parent</span>&lt;HelloWorld ref=<span class="hljs-string">&quot;hw&quot;</span>/&gt;<span class="hljs-built_in">this</span>.$refs.hw.xx = <span class="hljs-string">&#x27;xxx&#x27;</span> <span class="hljs-comment">// 父组件可以读取子组件的值并修改</span></code></pre>3. 子组件chidren  <pre><code class="hljs JavaScript"><span class="hljs-comment">// parent</span><span class="hljs-built_in">this</span>.$children[<span class="hljs-number">0</span>].xx = <span class="hljs-string">&#x27;xxx&#x27;</span> <span class="hljs-comment">// 父组件可以通过$children或许子组件的值并修改</span></code></pre></code></pre><p>  子传父：<br>    4. 使用$emit</p><pre><code>  <pre><code class="hljs JavaScript"><span class="hljs-comment">// child</span><span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;add&#x27;</span>, good)<span class="hljs-comment">// parent</span>&lt;Cart @add=<span class="hljs-string">&quot;cartAdd($event)&quot;</span>&gt;&lt;/Cart&gt;</code></pre></code></pre><p>  兄弟组件通信：<br>    5. 通过共同的祖辈组件搭桥，$parent或$root。</p><pre><code>  <pre><code class="hljs JavaScript"><span class="hljs-comment">// Child2</span>&lt;h2 @click=<span class="hljs-string">&quot;$parent.$emit(&#x27;foo&#x27;,foo)&quot;</span>&gt;Child2&lt;/h2&gt;<span class="hljs-comment">// Child1</span><span class="hljs-built_in">this</span>.$parent.$on(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1111111111111&#x27;</span>+e);        &#125;)</code></pre></code></pre><p>  祖先和后代通信：<br>    6. provide/inject：能够实现祖先给后代传值( 多个子代嵌套传值 )</p><pre><code>  <pre><code class="hljs JavaScript"><span class="hljs-comment">//provide传值</span>provide() &#123;<span class="hljs-comment">//多个子代嵌套传值</span>          <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">myprovide</span>: <span class="hljs-built_in">this</span> &#125;        &#125;,<span class="hljs-comment">// inject子组件接收</span>inject:[<span class="hljs-string">&#x27;myprovide&#x27;</span>],</code></pre></code></pre><p>  任意两个组件通信：<br>    7. 事件总线：创建一个Bus类负责事件派发、监听和回调管理(单独创建一个vue实例做监听使用)</p><pre><code>  <pre><code class="hljs JavaScript">Vue.prototype.$bus = <span class="hljs-keyword">new</span> Vue();&lt;h3 @click=<span class="hljs-string">&quot;$bus.$emit(&#x27;foo1&#x27;)&quot;</span>&gt;&#123;&#123;msg&#125;&#125;&lt;<span class="hljs-regexp">/h3&gt; /</span><span class="hljs-regexp">/ 创建响应</span><span class="hljs-regexp"></span><span class="hljs-regexp">this.$bus.$on(&#x27;foo1&#x27;, this.handle) /</span><span class="hljs-regexp">/ 收到响应</span></code></pre>8. vuex</code></pre><h2 id="data返回为什么是返回函数"><a href="#data返回为什么是返回函数" class="headerlink" title="data返回为什么是返回函数"></a>data返回为什么是返回函数</h2><p>  JS中的实例是通过构造函数来创建的，每个构造函数可以new出很多个实例，那么每个实例都会继承原型上的方法或属性。<br>  vue的data数据其实是vue原型上的属性，数据存在于内存当中<br>  vue为了保证每个实例上的data数据的独立性，规定了必须使用函数，而不是对象。<br>  因为使用对象的话，每个实例（组件）上使用的data数据是相互影响的，这当然就不是我们想要的了。对象是对于内存地址的引用，直接定义个对象的话组件之间都会使用这个对象，这样会造成组件之间数据相互影响。</p><h2 id="说说你对-SPA-单页面的理解，它的优缺点分别是什么"><a href="#说说你对-SPA-单页面的理解，它的优缺点分别是什么" class="headerlink" title="说说你对 SPA 单页面的理解，它的优缺点分别是什么"></a>说说你对 SPA 单页面的理解，它的优缺点分别是什么</h2><p>  SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><p>  优点：<br>    1. 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；<br>    2. 基于上面一点，SPA 相对对服务器压力小；<br>    3. 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</p><p>  缺点:<br>    1. 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；<br>    2. 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；<br>    3. SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</p><h2 id="v-show-与-v-if-有什么区别"><a href="#v-show-与-v-if-有什么区别" class="headerlink" title="v-show 与 v-if 有什么区别"></a>v-show 与 v-if 有什么区别</h2><p>  v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>  v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</p><p>  所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><h2 id="怎样理解-Vue-的单向数据流"><a href="#怎样理解-Vue-的单向数据流" class="headerlink" title="怎样理解 Vue 的单向数据流"></a>怎样理解 Vue 的单向数据流</h2><p>  所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定: 父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>  额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p><h2 id="computed-和-watch-的区别和运用的场景"><a href="#computed-和-watch-的区别和运用的场景" class="headerlink" title="computed 和 watch 的区别和运用的场景"></a>computed 和 watch 的区别和运用的场景</h2><p>  computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；<br>  watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><p>  运用场景：<br>    1. 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；<br>    2. 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><h2 id="直接给一个数组项赋值，Vue-能检测到变化吗"><a href="#直接给一个数组项赋值，Vue-能检测到变化吗" class="headerlink" title="直接给一个数组项赋值，Vue 能检测到变化吗"></a>直接给一个数组项赋值，Vue 能检测到变化吗</h2><p>  由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：<br>    1. 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue<br>    2. 当你修改数组的长度时，例如：vm.items.length = newLength</p><p>  为了解决第一个问题，Vue 提供了以下操作方法：</p><pre><code><pre><code class="hljs JavaScript"><span class="hljs-comment">// Vue.set</span>Vue.set(vm.items, indexOfItem, newValue)<span class="hljs-comment">// vm.$set，Vue.set的一个别名</span>vm.$set(vm.items, indexOfItem, newValue)<span class="hljs-comment">// Array.prototype.splice</span>vm.items.splice(indexOfItem, <span class="hljs-number">1</span>, newValue)</code></pre></code></pre><p>  为了解决第二个问题，Vue 提供了以下操作方法：</p><pre><code><pre><code class="hljs JavaScript"><span class="hljs-comment">// Array.prototype.splice</span>vm.items.splice(newLength)</code></pre></code></pre><h2 id="谈谈你对-Vue-生命周期的理解"><a href="#谈谈你对-Vue-生命周期的理解" class="headerlink" title="谈谈你对 Vue 生命周期的理解"></a>谈谈你对 Vue 生命周期的理解</h2><ol><li><p>生命周期是什么?<br>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p></li><li><p>各个生命周期的作用<br>Vue 的生命周期总共有 8 个 , 分别是：</p><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>创建前 ， 此时data对象和 $el 都为 undefined ，一般此处可以加 loading 事件</td></tr><tr><td>created</td><td>创建后，此时data对象已经有了， 但是 $el 还没有 ， 此处可以做些 关闭 loading 事件 ，异步请求等</td></tr><tr><td>beforeMount</td><td>渲染前 ， 此时data对象和$el都初始化了，但还是虚拟的dom节点</td></tr><tr><td>mounted</td><td>渲染后 ， 实例挂载完毕，此阶段可以做的事情： 配合路由钩子使用</td></tr><tr><td>beforeUpdate</td><td>更新前， data更新时触发</td></tr><tr><td>update</td><td>更新后， data更新时触发 ， 此处可以在数据更新时做些处理， 也可以使用 watch 进行观测</td></tr><tr><td>beforeDestory</td><td>销毁前 ， 组件销毁时触发， 此阶段可做的事情：询问用户是否销毁</td></tr><tr><td>destoryed</td><td>销毁后， 组件销毁时触发，此时 实例解除了事件监听以及dom的绑定，但是dom节点依旧存在，此阶段可以做的事情： 组件销毁时进行提示</td></tr></tbody></table><p>   补充两个 keep-alive 专属生命周期：</p><table><thead><tr><th>keep-alive 专属生命周期</th><th>描述</th></tr></thead><tbody><tr><td>activited</td><td>组件被激活时调用</td></tr><tr><td>deactivated</td><td>组件被销毁时调用</td></tr></tbody></table></li></ol><h2 id="Vue-的父组件和子组件生命周期钩子函数执行顺序"><a href="#Vue-的父组件和子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue 的父组件和子组件生命周期钩子函数执行顺序"></a>Vue 的父组件和子组件生命周期钩子函数执行顺序</h2><p>  Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：<br>    1. 加载渲染过程： 父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted<br>    2. 子组件更新过程： 父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父<br>    3. 父组件更新过程： 父 beforeUpdate -&gt; 父 updated<br>    4. 销毁过程： 父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p><h2 id="在哪个生命周期内调用异步请求"><a href="#在哪个生命周期内调用异步请求" class="headerlink" title="在哪个生命周期内调用异步请求"></a>在哪个生命周期内调用异步请求</h2><p>  可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：<br>    1. 能更快获取到服务端数据，减少页面 loading 时间；<br>    2. ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</p><h2 id="在什么阶段才能访问操作DOM"><a href="#在什么阶段才能访问操作DOM" class="headerlink" title="在什么阶段才能访问操作DOM"></a>在什么阶段才能访问操作DOM</h2><p>  在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。</p><h2 id="父组件可以监听到子组件的生命周期吗"><a href="#父组件可以监听到子组件的生命周期吗" class="headerlink" title="父组件可以监听到子组件的生命周期吗"></a>父组件可以监听到子组件的生命周期吗</h2><p>  可以 子组件在对应的生命周期内 $emit 告诉 父组件</p><h2 id="谈谈你对-keep-alive-的了解"><a href="#谈谈你对-keep-alive-的了解" class="headerlink" title="谈谈你对 keep-alive 的了解"></a>谈谈你对 keep-alive 的了解</h2><p>  keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：<br>    1. 一般结合路由和动态组件一起使用，用于缓存组件；<br>    2. 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；<br>    3. 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</p><h2 id="v-model-的原理"><a href="#v-model-的原理" class="headerlink" title="v-model 的原理"></a>v-model 的原理</h2><p>  我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：<br>    1. text 和 textarea 元素使用 value 属性和 input 事件；<br>    2. checkbox 和 radio 使用 checked 属性和 change 事件；<br>    3. select 字段将 value 作为 prop 并将 change 作为事件。</p><pre><code>    <pre><code class="hljs JavaScript">&lt;input v-model=<span class="hljs-string">&#x27;something&#x27;</span>&gt;<span class="hljs-comment">// 相当于</span>&lt;input v-bind:value=<span class="hljs-string">&quot;something&quot;</span> v-on:input=<span class="hljs-string">&quot;something = $event.target.value&quot;</span>&gt;</code></pre></code></pre><p>  如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：</p><pre><code>  <pre><code class="hljs JavaScript"><span class="hljs-comment">// 父组件：</span>&lt;ModelChild v-model=<span class="hljs-string">&quot;message&quot;</span>&gt;&lt;/ModelChild&gt;<span class="hljs-comment">// 子组件：</span>&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;/div&gt;props:&#123;  value: <span class="hljs-built_in">String</span>&#125;,methods: &#123;  test1()&#123;    <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-string">&#x27;小红&#x27;</span>)  &#125;,&#125;,</code></pre></code></pre><h2 id="你使用过-Vuex-吗"><a href="#你使用过-Vuex-吗" class="headerlink" title="你使用过 Vuex 吗"></a>你使用过 Vuex 吗</h2><p>  Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。<br>    1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>    2. 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p><p>  主要包括以下几个模块：<br>    1. State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。<br>    2. Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。<br>    3. Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。<br>    4. Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。<br>    5. Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</p><h2 id="使用过-Vue-SSR-吗？说说-SSR"><a href="#使用过-Vue-SSR-吗？说说-SSR" class="headerlink" title="使用过 Vue SSR 吗？说说 SSR"></a>使用过 Vue SSR 吗？说说 SSR</h2><p>  SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p><p>  服务端渲染的优点：<br>    1. 更好的 SEO<br>    2. 更快的内容到达时间（首屏加载更快）</p><p>  服务端渲染的缺点：<br>    1. 更多的开发条件限制：  例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；<br>    2. 更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p><h2 id="vue-router-路由模式有几种"><a href="#vue-router-路由模式有几种" class="headerlink" title="vue-router 路由模式有几种"></a>vue-router 路由模式有几种</h2><p>  vue-router 有 3 种路由模式：hash、history、abstract：<br>    1. hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；<br>    2. history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；<br>    3. abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</p><h2 id="Vue-是如何实现数据双向绑定的"><a href="#Vue-是如何实现数据双向绑定的" class="headerlink" title="Vue 是如何实现数据双向绑定的"></a>Vue 是如何实现数据双向绑定的</h2><p>  Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。</p><p>  主要通过以下 4 个步骤来实现数据双向绑定的：<br>    1. 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。<br>    2. 实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。<br>    3. 实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。<br>    4. 实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p><h2 id="Vue-框架怎么实现对象和数组的监听"><a href="#Vue-框架怎么实现对象和数组的监听" class="headerlink" title="Vue 框架怎么实现对象和数组的监听"></a>Vue 框架怎么实现对象和数组的监听</h2><p>  如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是  Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p><pre><code><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><span class="hljs-comment">* Observe a list of Array items.</span><span class="hljs-comment">*/</span>observeArray (items: <span class="hljs-built_in">Array</span>&lt;any&gt;) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = items.length; i &lt; l; i++) &#123;    observe(items[i])  <span class="hljs-comment">// observe 功能为监测数据的变化 </span>  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">* 对属性进行递归遍历</span><span class="hljs-comment">*/</span><span class="hljs-keyword">let</span> childOb = !shallow &amp;&amp; observe(val) <span class="hljs-comment">// observe 功能为监测数据的变化</span></code></pre></code></pre><p>  通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p><p>  拓展： 在Vue2.x中数组变化监听的问题，其实不是Object.definePropertype方法监听不到，而是为了性能和收益比例综合考虑之下，改变了监听方式 , 从原本的直接监听结果变化这种思路变换到监听会导致结果变化的方法上（重写数组的部分方法（七种： push，pop，shift，unshift，splice, sort，reverse））。<br>  Vue3.0中利用Proxy的方式则完美解决了2.0中出现的问题</p><h2 id="Proxy-与-Object-defineProperty-优劣对比"><a href="#Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="Proxy 与 Object.defineProperty 优劣对比"></a>Proxy 与 Object.defineProperty 优劣对比</h2><p>  Proxy 的优势如下:<br>    1. Proxy 可以直接监听对象而非属性；<br>    2. Proxy 可以直接监听数组的变化；<br>    3. Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；<br>    4. Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；<br>    5. Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</p><p>  Object.defineProperty 的优势如下:<br>    兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</p><h2 id="Vue-怎么用-vm-set-解决对象新增属性不能响应的问题"><a href="#Vue-怎么用-vm-set-解决对象新增属性不能响应的问题" class="headerlink" title="Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题"></a>Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题</h2><p>  受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)  来实现为对象添加响应式属性，那框架本身是如何实现的呢？</p><p>  我们查看对应的 Vue 源码：vue/src/core/instance/index.js</p><pre><code><pre><code class="hljs JavaScript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set</span> (<span class="hljs-params">target: Array&lt;any&gt; | Object, key: any, val: any</span>): <span class="hljs-title">any</span> </span>&#123;  <span class="hljs-comment">// target 为数组  </span>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;    <span class="hljs-comment">// 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span>    target.length = <span class="hljs-built_in">Math</span>.max(target.length, key)    <span class="hljs-comment">// 利用数组的splice变异方法触发响应式  </span>    target.splice(key, <span class="hljs-number">1</span>, val)    <span class="hljs-keyword">return</span> val  &#125;  <span class="hljs-comment">// key 已经存在，直接修改属性值  </span>  <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> target &amp;&amp; !(key <span class="hljs-keyword">in</span> <span class="hljs-built_in">Object</span>.prototype)) &#123;    target[key] = val    <span class="hljs-keyword">return</span> val  &#125;  <span class="hljs-keyword">const</span> ob = (target: any).__ob__  <span class="hljs-comment">// target 本身就不是响应式数据, 直接赋值</span>  <span class="hljs-keyword">if</span> (!ob) &#123;    target[key] = val    <span class="hljs-keyword">return</span> val  &#125;  <span class="hljs-comment">// 对属性进行响应式处理</span>  defineReactive(ob.value, key, val)  ob.dep.notify()  <span class="hljs-keyword">return</span> val&#125;</code></pre></code></pre><p>  我们阅读以上源码可知，vm.$set 的实现原理是：<br>    1. 如果目标是数组，直接使用数组的 splice 方法触发相应式；<br>    2. 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用   defineReactive 方法进行响应式处理（ defineReactive 方法就是  Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</p><h2 id="虚拟-DOM-的优缺点"><a href="#虚拟-DOM-的优缺点" class="headerlink" title="虚拟 DOM 的优缺点"></a>虚拟 DOM 的优缺点</h2><p>  优点：<br>    1. 保证性能下限<br>    2. 无需手动操作 DOM<br>    3. 跨平台</p><p>  缺点:<br>    1. 无法进行极致优化</p><h2 id="虚拟-DOM-实现原理"><a href="#虚拟-DOM-实现原理" class="headerlink" title="虚拟 DOM 实现原理"></a>虚拟 DOM 实现原理</h2><p>  虚拟 DOM 的实现原理主要包括以下 3 部分:<br>    1. 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；<br>    2. diff 算法 — 比较两棵虚拟 DOM 树的差异；<br>    3. pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</p><h2 id="Vue-中的-key-有什么作用"><a href="#Vue-中的-key-有什么作用" class="headerlink" title="Vue 中的 key 有什么作用"></a>Vue 中的 key 有什么作用</h2><p>  key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。</p><h2 id="你有对-Vue-项目进行哪些优化"><a href="#你有对-Vue-项目进行哪些优化" class="headerlink" title="你有对 Vue 项目进行哪些优化"></a>你有对 Vue 项目进行哪些优化</h2><ol><li>代码层面的优化<br>v-if 和 v-show 区分使用场景<br>computed 和 watch  区分使用场景<br>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if<br>长列表性能优化<br>事件的销毁<br>图片资源懒加载<br>路由懒加载<br>第三方插件的按需引入<br>优化无限列表性能<br>服务端渲染 SSR or 预渲染</li><li>Webpack 层面的优化<br>Webpack 对图片进行压缩<br>减少 ES6 转为 ES5 的冗余代码<br>提取公共代码<br>模板预编译<br>提取组件的 CSS<br>优化 SourceMap<br>构建结果输出分析<br>Vue 项目的编译优化</li><li>基础的 Web 技术的优化<br>开启 gzip 压缩<br>浏览器缓存<br>CDN 的使用<br>使用 Chrome Performance 查找性能瓶颈</li></ol><h2 id="Vue-中-v-html-会导致什么问题"><a href="#Vue-中-v-html-会导致什么问题" class="headerlink" title="Vue 中 v-html 会导致什么问题"></a>Vue 中 v-html 会导致什么问题</h2><p>  在网站上动态渲染任意 HTML，很容易导致 XSS 攻击。所以只能在可信内容上使用 v-html，且永远不能用于用户提交的内容上。</p><h2 id="nextTick是做什么用的，其原理是什么"><a href="#nextTick是做什么用的，其原理是什么" class="headerlink" title="nextTick是做什么用的，其原理是什么"></a>nextTick是做什么用的，其原理是什么</h2><p>  定义：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。<br>  理解：nextTick()，是将回调函数延迟在下一次dom更新数据后调用，简单的理解是：当数据更新了，在dom中渲染后，自动执行该函数</p><p>  原理：<br>    nextTick() 涉及到js线程中的微任务和宏任务.在一次事件循环中,先执行微任务,再执行宏任务。<br>    查询浏览器支持的程度,先后执行<br>      1. promise<br>      2. MutationObserve<br>      3. setTimeout<br>    nextTick好处: 碰到太频繁的js操作,只需要显示最后一次的数据的视图,如果每次都实时更新视图,会消耗太多性能</p><h2 id="Vue-的模板编译原理"><a href="#Vue-的模板编译原理" class="headerlink" title="Vue 的模板编译原理"></a>Vue 的模板编译原理</h2><p>  vue模板的编译过程分为3个阶段：<br>    1. 第一步：解析。 将模板字符串解析生成 AST，生成的AST 元素节点总共有 3 种类型，1 为普通元素， 2 为表达式，3为纯文本。<br>    2. 第二步：优化语法树。 Vue 模板中并不是所有数据都是响应式的，有很多数据是首次渲染后就永远不会变化的，那么这部分数据生成的 DOM 也不会变化，我们可以在 patch 的过程跳过对他们的比对。<br>    此阶段会深度遍历生成的 AST 树，检测它的每一颗子树是不是静态节点，如果是静态节点则它们生成 DOM 永远不需要改变，这对运行时对模板的更新起到极大的优化作用。<br>    3. 生成代码： 通过 generate 方法，将ast生成 render 函数。</p><h2 id="为什么Vue-采用异步渲染"><a href="#为什么Vue-采用异步渲染" class="headerlink" title="为什么Vue 采用异步渲染"></a>为什么Vue 采用异步渲染</h2><p>  因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能考虑，<br>  Vue 会在本轮数据更新后，再去异步更新数据；</p><h2 id="vue常用的修饰符"><a href="#vue常用的修饰符" class="headerlink" title="vue常用的修饰符"></a>vue常用的修饰符</h2><ol><li><p>按键修饰符: 如：.delete（捕获“删除”和”退格“键）<br>用法上和事件修饰符一样，挂载在v-on:后面，语法：v-on:keyup.xxx=’yyy’</p><pre><code> <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">inputclass</span> = <span class="hljs-string">&#x27;aaa&#x27;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;inputValue&quot;</span> @<span class="hljs-attr">keyup.delete</span>=<span class="hljs-string">&quot;onKey&quot;</span>/&gt;</span></code></pre></code></pre></li><li><p>系统修饰符<br>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器:<br> 2.1 .ctrl<br> 2.2 .alt<br> 2.3 .shift<br> 2.4 .meta</p></li><li><p>鼠标按钮修饰符<br>.left<br>.right<br>.middle</p></li><li><p>其他修饰符<br>.lazy<br>.number<br>.trim</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css面试题</title>
    <link href="/articles/2020/12/07/css%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/articles/2020/12/07/css%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="谈谈你对-CSS-盒模型的认识"><a href="#谈谈你对-CSS-盒模型的认识" class="headerlink" title="谈谈你对 CSS 盒模型的认识"></a>谈谈你对 CSS 盒模型的认识</h2><p>  盒子模型分两种:</p><pre><code>1. 标准模型2. IE模型</code></pre><p>  标准模型: 标准 W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。<br>  IE模型: IE 盒子模型的范围也包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading。</p><h2 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h2><p>  基本概念： Block Formatting Context, 块级格式化上下文，一个独立的块级渲染区域，该区域拥有一套渲染规格来约束块级盒子的布局，且与区域外部无关。</p><p>  BFC 的原理：</p><pre><code>1. BFC 这个元素的垂直的边距会发生重叠2. BFC 的区域不会与浮动元素的 float 重叠3. 独立的容器，内外元素互不影响4. 计算 BFC 高度，浮动元素也参与计算</code></pre><p>  如何创建 BFC：</p><pre><code>1. float 不为none的时候2. position 不为 static 或者 relative 的时候3. display 与 table 相关的时候4. overflow 为auto, hidden 的时候</code></pre><h2 id="px、em、rem、-、vw、vh、vm这些单位的区别"><a href="#px、em、rem、-、vw、vh、vm这些单位的区别" class="headerlink" title="px、em、rem、%、vw、vh、vm这些单位的区别"></a>px、em、rem、%、vw、vh、vm这些单位的区别</h2><ol><li>px就是pixel的缩写，意为像素。px就是一张图片最小的一个点，一张位图就是千千万万的这样的点构成的，比如常常听到的电脑像素是1024x768的，表示的是水平方向是1024个像素点，垂直方向是768个像素点。</li><li>em参考物是父元素的font-size，具有继承的特点。如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。</li><li>rem 是css3新单位，相对于根元素html（网页）的font-size，不会像em那样，依赖于父元素的字体大小，而造成混乱。</li><li>% 一般宽泛的讲是相对于父元素，但是并不是十分准确。对于普通定位元素就是我们理解的父元素 ； 对于position: absolute;的元素是相对于已定位的父元素 ； 对于position: fixed;的元素是相对于 ViewPort（可视窗口）</li><li>vw 是 css3新单位，viewpoint width的缩写，视窗宽度，1vw等于视窗宽度的1%。 举个例子：浏览器宽度1200px, 1 vw = 1200px/100 = 12 px。</li><li>vh 是 css3新单位，viewpoint height的缩写，视窗高度，1vh等于视窗高度的1%。 举个例子：浏览器高度900px, 1 vh = 900px/100 = 9 px。</li><li>vm 是 css3新单位，相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vm。 举个例子：浏览器高度900px，宽度1200px，取最小的浏览器高度， 1 vm = 900px/100 = 9 px。</li></ol><h2 id="css3有哪些新特性"><a href="#css3有哪些新特性" class="headerlink" title="css3有哪些新特性"></a>css3有哪些新特性</h2><p>  圆角（border-radius）<br>  阴影（box-shadow）<br>  过渡效果（transition）<br>  翻转（transform）<br>  动画（animation）<br>  媒体查询（@media）<br>  弹性盒子（flex）</p><h2 id="垂直居中有哪些方法"><a href="#垂直居中有哪些方法" class="headerlink" title="垂直居中有哪些方法"></a>垂直居中有哪些方法</h2><ol><li><p>使用绝对定位和负外边距对块级元素进行垂直居中</p> <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre> <pre><code class="hljs css"><span class="hljs-selector-id">#box</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#ddd</span>;  <span class="hljs-attribute">position</span>: relative;&#125;<span class="hljs-selector-id">#child</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">background</span>: orange;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;  <span class="hljs-attribute">margin</span>: -<span class="hljs-number">50px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>; &#125;</code></pre></li><li><p>使用绝对定位和transform</p> <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>test vertical align<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre> <pre><code class="hljs css"><span class="hljs-selector-id">#box</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">background</span>: <span class="hljs-number">#ddd</span>;    <span class="hljs-attribute">position</span>: relative;&#125;<span class="hljs-selector-id">#child</span> &#123;    <span class="hljs-attribute">background</span>: orange;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">50%</span>);&#125;</code></pre></li><li><p>使用绝对定位和负外边距进行垂直居中的方式</p> <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>test vertical align<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre> <pre><code class="hljs css"><span class="hljs-selector-id">#box</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">background</span>: <span class="hljs-number">#ddd</span>;    <span class="hljs-attribute">position</span>: relative;&#125;<span class="hljs-selector-id">#child</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">30%</span>;    <span class="hljs-attribute">background</span>: orange;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">margin</span>: -<span class="hljs-number">15%</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p>绝对定位结合margin: auto</p> <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>test vertical align<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre> <pre><code class="hljs css"><span class="hljs-selector-id">#box</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">background</span>: <span class="hljs-number">#ddd</span>;    <span class="hljs-attribute">position</span>: relative;&#125;<span class="hljs-selector-id">#child</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">background</span>: orange;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">margin</span>: auto;    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>;&#125;</code></pre></li><li><p>使用padding实现子元素的垂直居中</p> <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre> <pre><code class="hljs css"><span class="hljs-selector-id">#box</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">background</span>: <span class="hljs-number">#ddd</span>;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">100px</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-id">#child</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">background</span>: orange;&#125;</code></pre></li><li><p>设置第三方基准</p> <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;base&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre> <pre><code class="hljs css"><span class="hljs-selector-id">#box</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">background</span>: <span class="hljs-number">#ddd</span>;&#125;<span class="hljs-selector-id">#base</span> &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">background</span>: orange;&#125;<span class="hljs-selector-id">#child</span> &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">131</span>, <span class="hljs-number">224</span>, <span class="hljs-number">245</span>, <span class="hljs-number">0.6</span>);     <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;&#125;</code></pre></li><li><p>使用flex布局</p> <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>test vertical align<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre> <pre><code class="hljs css"><span class="hljs-selector-id">#box</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">background</span>: <span class="hljs-number">#ddd</span>;    <span class="hljs-attribute">display</span>: flex;    <span class="hljs-attribute">align-items</span>: center;&#125;</code></pre></li><li><p>使用 line-height 对单行文本进行垂直居中</p> <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>test vertical align<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre> <pre><code class="hljs css"><span class="hljs-selector-id">#box</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">background</span>: <span class="hljs-number">#ddd</span>;    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">300px</span>;&#125;</code></pre></li><li><p>使用 line-height 和 vertical-align 对图片进行垂直居中</p> <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;xx.jpg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre> <pre><code class="hljs css"><span class="hljs-selector-id">#box</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">background</span>: <span class="hljs-number">#ddd</span>;    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">300px</span>;&#125;<span class="hljs-selector-id">#box</span> <span class="hljs-selector-tag">img</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">vertical-align</span>: middle;&#125;</code></pre></li><li><p>使用 display: table; 和 vertical-align: middle; 对容器里的文字进行垂直居中</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>test vertical align<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs css"><span class="hljs-selector-id">#box</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#ddd</span>;  <span class="hljs-attribute">display</span>: table;&#125;<span class="hljs-selector-id">#child</span> &#123;    <span class="hljs-attribute">display</span>: table-cell;    <span class="hljs-attribute">vertical-align</span>: middle;&#125;</code></pre></li><li><p>使用 CSS Grid</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;</span>target item<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;three&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs css"><span class="hljs-selector-id">#box</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;  <span class="hljs-attribute">display</span>: grid;&#125;<span class="hljs-selector-class">.two</span> &#123;    <span class="hljs-attribute">background</span>: orange;&#125;<span class="hljs-selector-class">.one</span>, <span class="hljs-selector-class">.three</span> &#123;    <span class="hljs-attribute">background</span>: skyblue;&#125;</code></pre><p>总结一下，比较通用的就三种：<br>flex布局<br>绝对定位 + translate，或绝对定位 + margin<br>grid布局</p></li></ol><h2 id="css精灵图怎么实现，好处和坏处"><a href="#css精灵图怎么实现，好处和坏处" class="headerlink" title="css精灵图怎么实现，好处和坏处"></a>css精灵图怎么实现，好处和坏处</h2><p>  CSS Sprites优点:<br>    1. 利用CSS Sprites能很好地减少了网页的http请求，从而大大的提高了页面的性能，这也是CSS Sprites最大的优点，也是其被广泛传播和应用的主要原因；<br>    2. CSS Sprites能减少图片的字节，曾经比较过多次3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</p><p>  CSS Sprites缺点:<br>    1. 在图片合并的时候，你要把多张图片有序的合理的合并成一张图片，还要留好足够的空间，防止板块内不会出现不必要的背景；这些还好，最痛苦的是在宽屏，高分辨率的屏幕下的自适应页面，你的图片如果不够宽，很容易出现背景断裂；<br>    2. CSS Sprites在开发的时候比较麻烦，你要通过photoshop或其他工具测量计算每一个背景单元的精确位置，这是针线活，没什么难度，但是很繁琐；幸好腾讯的鬼哥用RIA开发了一个CSS Sprites 样式生成工具，虽然还有一些使用上的不灵活，但是已经比photoshop测量来的方便多了，而且样式直接生成，复制，拷贝就OK！<br>    3. CSS Sprites在维护的时候比较麻烦，如果页面背景有少许改动，一般就要改这张合并的图片，无需改的地方最好不要动，这样避免改动更多的css，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动css。</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题收集</title>
    <link href="/articles/2020/11/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/"/>
    <url>/articles/2020/11/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="promise-all-和-promise-race-区别"><a href="#promise-all-和-promise-race-区别" class="headerlink" title="promise.all 和 promise.race 区别"></a>promise.all 和 promise.race 区别</h2><p>promise.all :<br>比如当数组里的 P1，P2 都执行完成时，页面才显示。<br>值得注意的是，返回的数组结果顺序不会改变，即使 P2 的返回要比 P1 的返回快，顺序依然是 P1，P2<br>Promise.all 成功返回成功数组,<br>失败返回失败数据, 一但失败就不会继续往下走</p><p>promise.race :<br>Promise.race 是赛跑的意思，也就是说 Promise.race([p1, p2, p3])里面的结果哪个获取的快，就返回哪个结果，不管结果本身是成功还是失败</p><p>使用场景:<br>Promise.all 和 Promise.race 都是有使用场景的。<br>有些时候我们做一个操作可能得同时需要不同的接口返回的数据，这时我们就可以使用 Promise.all；<br>有时我们比如说有好几个服务器的好几个接口都提供同样的服务，我们不知道哪个接口更快，就可以使用 Promise.race，哪个接口的数据先回来我们就用哪个接口的数据。</p><h2 id="哪些设计模式，用过哪些"><a href="#哪些设计模式，用过哪些" class="headerlink" title="哪些设计模式，用过哪些"></a>哪些设计模式，用过哪些</h2><ol><li>工厂模式</li><li>单例模式</li><li>代理模式</li><li>观察者模式</li><li>策略模式</li></ol><h2 id="http2-0-和-http1-1-区别"><a href="#http2-0-和-http1-1-区别" class="headerlink" title="http2.0 和 http1.1 区别"></a>http2.0 和 http1.1 区别</h2><ol><li>多路复用</li><li>首部压缩</li><li>HTTP2 支持服务器推送</li></ol><h2 id="如何并发请求"><a href="#如何并发请求" class="headerlink" title="如何并发请求"></a>如何并发请求</h2><ol><li>promise.all</li><li>axios.all 和 axios.spread</li></ol><h2 id="从输入-url-到页面加载全过程"><a href="#从输入-url-到页面加载全过程" class="headerlink" title="从输入 url 到页面加载全过程"></a>从输入 url 到页面加载全过程</h2><ol><li>DNS 解析:将域名解析成 IP 地址</li><li>TCP 连接：TCP 三次握手</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>断开连接：TCP 四次挥手</li></ol><h2 id="三次握手和四次挥手分别是什么"><a href="#三次握手和四次挥手分别是什么" class="headerlink" title="三次握手和四次挥手分别是什么"></a>三次握手和四次挥手分别是什么</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ol><li>第一次握手 ，客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_SEND 状态。</li><li>第二次握手 ，服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。此时服务器处于 SYN_RCVD 的状态。</li><li>第三次握手 ，客户端收到 SYN 报文之后，会发送一个 ACK 报文，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</li></ol><h3 id="为什么需要三次握手，两次不行吗"><a href="#为什么需要三次握手，两次不行吗" class="headerlink" title="为什么需要三次握手，两次不行吗"></a>为什么需要三次握手，两次不行吗</h3><p>第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。<br>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p><p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>第一次挥手：客户端发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接，进入 FIN_WAIT1（终止等待 1）状态，等待服务端的确认。<br>第二次挥手：服务端收到连接释放报文段后即发出确认报文段，服务端进入 CLOSE_WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入 FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。<br>第三次挥手：服务端没有要向客户端发出的数据，服务端发出连接释放报文段，服务端进入 LAST_ACK（最后确认）状态，等待客户端的确认。<br>第四次挥手：客户端收到服务端的连接释放报文段后，对此发出确认报文段，客户端进入 TIME_WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，客户端才进入 CLOSED 状态。</p><h3 id="挥手为什么需要四次"><a href="#挥手为什么需要四次" class="headerlink" title="挥手为什么需要四次"></a>挥手为什么需要四次</h3><p>因为当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当服务端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉客户端，”你发的 FIN 报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四次挥手。</p><h3 id="四次挥手释放连接时，等待-2MSL-的意义"><a href="#四次挥手释放连接时，等待-2MSL-的意义" class="headerlink" title="四次挥手释放连接时，等待 2MSL 的意义"></a>四次挥手释放连接时，等待 2MSL 的意义</h3><p>为了保证客户端发送的最后一个 ACK 报文段能够到达服务器。因为这个 ACK 有可能丢失，从而导致处在 LAST-ACK 状态的服务器收不到对 FIN-ACK 的确认报文。服务器会超时重传这个 FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待 2MSL，而是在发送完 ACK 之后直接释放关闭，一但这个 ACK 丢失的话，服务器就无法正常的进入关闭连接状态。</p><h2 id="http-和-https-的区别"><a href="#http-和-https-的区别" class="headerlink" title="http 和 https 的区别"></a>http 和 https 的区别</h2><ol><li>https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。</li><li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li><li>http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。</li></ol><h2 id="为什么定时器是不精准的"><a href="#为什么定时器是不精准的" class="headerlink" title="为什么定时器是不精准的"></a>为什么定时器是不精准的</h2><p>因为 JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码。<br>为了控制要执行的代码，就有一个 JavaScript 任务队列。<br>这些任务会按照将它们添加到队列的顺序执行。<br>setTimeout() 的第二个参数告诉 JavaScript 再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行</p><h2 id="什么是-mvvm-mvc"><a href="#什么是-mvvm-mvc" class="headerlink" title="什么是 mvvm, mvc"></a>什么是 mvvm, mvc</h2><p>MVVM 是 Model View ViewModel 的缩写 , 是由 MVC 中的 controller 演变而来。<br>Model 层代表 数据 ； View 层代表 视图 ； ViewModel 层是 View 和 Model 之间的桥梁； 数据会绑定到 ViewModel 层并自动将数据渲染到页面中；视图变化的时候会通知 ViewModel 更新数据。</p><p>MVC 是 Model View Controller 的缩写 ， 是应用最广泛的软件架构之一。<br>View 一般用 Controller 来和 Model 进行联系。Controller 是 Model 和 View 的协调者, View 和 Model 不直接联系。基本都是单向联系。</p><h2 id="Mvvm-的优缺点"><a href="#Mvvm-的优缺点" class="headerlink" title="Mvvm 的优缺点"></a>Mvvm 的优缺点</h2><p>优点：</p><ol><li>低耦合。 view 可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</li><li>可重用性。 可以把一些视图逻辑放在一个 ViewModel 里面， 让很多 View 重用这段视图逻辑。</li><li>独立开发。 开发者可以专注于业务逻辑和数据的开发，设计人员可以专注于页面的设计。</li><li>可测试性。 开发者更好地编写测试代码自动更新 dom</li></ol><p>缺点：</p><ol><li>bug 定位调试困难。一个 bug 出现，有可能是 View 出现问题也有可能是 Model 出现问题。</li><li>一个大模块中 Model 也会很大，当时长期持有，不释放内存就造成了花费更多的内存对于大型的图形应用程序。</li><li>视图状态较多，ViewModel 的构建和维护的成本都会比较高。</li></ol><h2 id="Mvc-的优缺点"><a href="#Mvc-的优缺点" class="headerlink" title="Mvc 的优缺点"></a>Mvc 的优缺点</h2><p>优点：</p><ol><li>可定制性。</li><li>代码清晰，便于维护。</li><li>视图与控制器的可接插性，允许更换视图和控制器对象，而且可以根据需求动态的打开或关闭、甚至在运行期间进行对象替换。</li><li>潜在的框架结构。可以基于此模型建立应用程序框架，不仅仅是用在设计界面的设计中</li></ol><p>缺点：</p><ol><li>MVC 框架的大部分逻辑都集中在 Controller 层，代码量也都集中在 Controller 层，这带给 Controller 层很大的压力，而已经有独立处理事件能力的 View 层却没有用到。</li><li>还有一个问题，就是 Controller 层和 View 层之间是一一对应的，断绝了 View 层复用的可能，因而产生了很多冗余代码。</li></ol><h2 id="Mvvm-和-Mvc-的区别"><a href="#Mvvm-和-Mvc-的区别" class="headerlink" title="Mvvm 和 Mvc 的区别"></a>Mvvm 和 Mvc 的区别</h2><ol><li>MVC 中 Controller 演变成 MVVM 中的 ViewModel</li><li>MVVM 通过数据来显示视图层而不是节点操作</li><li>MVVM 主要解决了 MVC 中大量的 dom 操作使页面渲染性能降低,加载速度变慢,影响用户体验</li></ol><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p>原型：</p><ol><li>所有引用类型都有一个<strong>proto</strong>(隐式原型)属性，属性值是一个普通的对象</li><li>所有函数都有一个 prototype(原型)属性，属性值是一个普通的对象</li><li>所有引用类型的<strong>proto</strong>属性指向它构造函数的 prototype</li></ol><p>原型链：<br>当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的<strong>proto</strong>隐式原型上查找，即它的构造函数的 prototype，如果还没有找到就会再在构造函数的 prototype 的<strong>proto</strong>中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。</p><h2 id="什么是同源策略，跨域的解决方法"><a href="#什么是同源策略，跨域的解决方法" class="headerlink" title="什么是同源策略，跨域的解决方法"></a>什么是同源策略，跨域的解决方法</h2><p>同源： 若地址里面的协议、域名和端口号均相同则属于同源。</p><p>什么是同源策略？<br>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。</p><p>什么是跨域？<br>受前面所讲的浏览器同源策略的影响，不是同源的脚本不能操作其他源下面的对象。想要操作另一个源下的对象是就需要跨域。</p><p>跨域的解决方法：</p><ol><li>通过 jsonp 跨域</li><li>document.domain + iframe 跨域</li><li>location.hash + iframe</li><li>window.name + iframe 跨域</li><li>postMessage 跨域</li><li>跨域资源共享（CORS）</li><li>nginx 代理跨域</li><li>nodejs 中间件代理跨域</li><li>WebSocket 协议跨域</li></ol><h2 id="跨域请求从发送到被拦截的过程"><a href="#跨域请求从发送到被拦截的过程" class="headerlink" title="跨域请求从发送到被拦截的过程"></a>跨域请求从发送到被拦截的过程</h2><p>浏览器接受到服务器的响应以后, 会检查当前源是否在 access-control-allow-origin 字段内,或者检查该字段是否 * 号 , 如果两个条件都不满足则给拦截掉。</p><p>补充浏览器发送跨域请求的过程： 浏览器发现 AJAX 是跨域请求后，会先发一个谓词为 OPTIONS 的请求给服务器，这个请求叫“预检请求”（Preflighted）；预检通过后才会二次发送原本真正的请求。但是，并不是所有的跨域请求都会发送 预检请求, 跨域请求分两种：简单请求和预检请求。一次完整的请求不需要服务端预检，直接响应的，归为简单请求；而响应前需要预检的，称为预检请求，只有预检请求通过，才有接下来的简单请求。</p><p>当请求满足下述任一条件时，即应首先发送预检请求：</p><pre><code class="hljs ```JS">使用了下面任一 HTTP 方法：PUTDELETECONNECTOPTIONSTRACEPATCH人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：AcceptAccept-LanguageContent-LanguageContent-Type (but note the additional requirements below)DPRDownlinkSave-DataViewport-WidthWidthContent-Type 的值不属于下列之一:application&#x2F;x-www-form-urlencodedmultipart&#x2F;form-datatext&#x2F;plain</code></pre><h2 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h2><ol><li>减少 HTTP 请求</li><li>使用 HTTP2</li><li>使用服务端渲染</li><li>静态资源使用 CDN</li><li>将 CSS 放在文件头部，JavaScript 文件放在底部</li><li>使用字体图标 iconfont 代替图片图标</li><li>善用缓存，不重复加载相同的资源</li><li>压缩文件</li><li>图片优化</li><li>通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码</li><li>减少重绘重排</li><li>使用事件委托</li><li>注意程序的局部性</li><li>if-else 对比 switch</li></ol><h2 id="介绍虚拟-Dom"><a href="#介绍虚拟-Dom" class="headerlink" title="介绍虚拟 Dom"></a>介绍虚拟 Dom</h2><p>虚拟 Dom(Virtual DOM)是对 DOM 的抽象, 本质上是 JavaScript 对象, 这个对象就是更加轻量级的对 DOM 的描述.</p><p>前端性能优化的一个秘诀就是尽量少地操做 DOM, 不只仅是 DOM 相对较慢, 更由于频繁变更 DOM 会形成浏览器的回流或者重回, 这些都是性能的杀手, 所以咱们须要这一层抽象, 在 patch 过程当中尽量地一次性将差别更新到 DOM 中, 这样保证了 DOM 不会出现性能不好的状况。<br>而且 虚拟 dom 的最初目的就是更好的跨平台, 好比 Node.js 就没有 DOM, 若是想实现 SSR(服务端渲染), 那么一个方式就是借助 Virtual DOM, 由于 Virtual DOM 自己是 JavaScript 对象.</p><h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>概念：<br>触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间</p><p>实现思路：<br>每次触发事件时都取消之前的延时调用方法</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn</span>) </span>&#123;    <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 创建一个标记用来存放定时器的返回值</span>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">clearTimeout</span>(timeout); <span class="hljs-comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span>        timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span>            fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);        &#125;, <span class="hljs-number">500</span>);    &#125;;&#125;</code></pre><p>使用场景:<br>登录、发短信、表单重复提交等按钮，避免用户快速点击导致触发多次请求，需要防抖。<br>调整浏览器窗口大小时，resize 次数频繁</p><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>概念:<br>高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率</p><p>实现思路:<br>每次触发事件时都判断当前是否有等待执行的延时函数</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn</span>) </span>&#123;    <span class="hljs-keyword">let</span> canRun = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 通过闭包保存一个标记</span>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (!canRun) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 在函数开头判断标记是否为true，不为true则return</span>        canRun = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 立即设置为false</span>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 将外部传入的函数的执行放在setTimeout中</span>            fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);            <span class="hljs-comment">// 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉</span>            canRun = <span class="hljs-literal">true</span>;        &#125;, <span class="hljs-number">500</span>);    &#125;;&#125;</code></pre><p>使用场景:<br>scroll 事件，每隔一秒计算一次位置信息<br>浏览器播放事件，每隔一秒计算一次进度信息<br>input 框实时搜索</p><h2 id="浅拷贝和深拷贝，如何实现深拷贝"><a href="#浅拷贝和深拷贝，如何实现深拷贝" class="headerlink" title="浅拷贝和深拷贝，如何实现深拷贝"></a>浅拷贝和深拷贝，如何实现深拷贝</h2><p>浅拷贝概念： 如果拷贝的属性是基本类型，拷贝的就是基本类型的值，如果拷贝的属性是引用类型，那么拷贝的就是内存地址。<br>深拷贝概念： 深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一块内存空间存放新的对象。</p><p>它们之间的区别：<br>浅拷贝只是拷贝对象的内存地址，并不是堆中的数据，所以该对象如果改变了，那么通过浅拷贝操作的对象也会受到影响。<br>深拷贝拷贝的是堆内存中的数据，重新开辟一块空间来存放数据，所以该对象即使改变也不会影响到拷贝的对象。</p><p>浅拷贝的方法有:</p><ol><li>Object.assign() ; 如果对象的属性值为简单类型（string， number），通过 Object.assign({}, Obj);得到的新对象为深拷贝；如果属性值为对象或其它引用类型，那对于这个对象而言其实是浅拷贝的。这是 Object.assign()特别值得注意的地方。</li></ol><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> a = &#123;    a: <span class="hljs-string">&#x27;old&#x27;</span>,    b: &#123;        c: <span class="hljs-string">&#x27;old&#x27;</span>    &#125;&#125;<span class="hljs-keyword">let</span> b = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, a)b.a = <span class="hljs-string">&#x27;new&#x27;</span>b.b.c = <span class="hljs-string">&#x27;new&#x27;</span><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// &#123; a: &#x27;old&#x27;, b: &#123; c: &#x27;new&#x27; &#125; &#125;</span><span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// &#123; a: &#x27;new&#x27;, b: &#123; c: &#x27;new&#x27; &#125; &#125;</span></code></pre><ol start="2"><li>Array.prototype.slice() ;该方法提取并返回一个新的数组 ， 如果源数组中的元素是个对象的引用，slice 会拷贝这个对象的引用到新的数组</li></ol><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, &#123;    d: <span class="hljs-string">&#x27;old&#x27;</span>&#125;]<span class="hljs-keyword">let</span> arr1 = arr.slice(<span class="hljs-number">1</span>)arr1[<span class="hljs-number">1</span>].d = <span class="hljs-string">&#x27;new&#x27;</span><span class="hljs-built_in">console</span>.log(arr[<span class="hljs-number">2</span>].d) <span class="hljs-comment">// new</span></code></pre><ol start="3"><li>Array.prototype.concat() ; 该方法返回一个新的数组，和 slice 方法类似，当源数组中的元素是个对象的引用，concat 在合并时拷贝的就是这个对象的引用</li></ol><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr1 = [&#123;    a: <span class="hljs-string">&#x27;old&#x27;</span>&#125;, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<span class="hljs-keyword">let</span> arr2 = [&#123;    b: <span class="hljs-string">&#x27;old&#x27;</span>&#125;, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>]<span class="hljs-keyword">let</span> arr3 = arr1.concat(arr2)arr3[<span class="hljs-number">0</span>].a = <span class="hljs-string">&#x27;new&#x27;</span>arr3[<span class="hljs-number">3</span>].b = <span class="hljs-string">&#x27;new&#x27;</span><span class="hljs-built_in">console</span>.log(arr1[<span class="hljs-number">0</span>].a) <span class="hljs-comment">// new</span><span class="hljs-built_in">console</span>.log(arr2[<span class="hljs-number">0</span>].b) <span class="hljs-comment">// new</span></code></pre><ol start="4"><li>函数库 lodash 的_.clone 方法</li><li>展开运算符…</li></ol><p>手动实现浅拷贝方法：<br>实现一个浅拷贝，就是遍历源对象，然后在将对象的属性的属性值都放到一个新对象里就 ok 了</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copy</span>(<span class="hljs-params">obj</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!obj || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">let</span> newObj = obj.constructor === <span class="hljs-built_in">Array</span> ? [] : &#123;&#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;        newObj[key] = obj[key]    &#125;    <span class="hljs-keyword">return</span> newObj&#125;<span class="hljs-keyword">let</span> a = &#123;    b: <span class="hljs-string">&#x27;bb&#x27;</span>,    c: <span class="hljs-string">&#x27;cc&#x27;</span>,    d: &#123;        e: <span class="hljs-string">&#x27;ee&#x27;</span>    &#125;&#125;<span class="hljs-keyword">let</span> b = copy(a)<span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// &#123; b: &#x27;bb&#x27;, c: &#x27;cc&#x27;, d: &#123; e: &#x27;ee&#x27; &#125; &#125;</span></code></pre><p>深拷贝的方法有:</p><ol><li>JSON.stringify()和 JSON.parse()的混合配对使用。 使用 JSON.stringify()和 JSON.parse()确实可以实现深拷贝 ， 但是如果源数据中假如出现 undefined、任意的函数以及 symbol 值的时候 JSON.stringify()在序列化过程中会被忽略。导致拷贝生成的对象中没有对应属性及属性值</li></ol><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arr1 = [&#123;    a: <span class="hljs-string">&#x27;old&#x27;</span>&#125;, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<span class="hljs-keyword">let</span> arr2 = [&#123;    b: <span class="hljs-string">&#x27;old&#x27;</span>&#125;, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>]<span class="hljs-keyword">let</span> arr3 = arr1.concat(arr2)arr3[<span class="hljs-number">0</span>].a = <span class="hljs-string">&#x27;new&#x27;</span>arr3[<span class="hljs-number">3</span>].b = <span class="hljs-string">&#x27;new&#x27;</span><span class="hljs-built_in">console</span>.log(arr1[<span class="hljs-number">0</span>].a) <span class="hljs-comment">// new</span><span class="hljs-built_in">console</span>.log(arr2[<span class="hljs-number">0</span>].b) <span class="hljs-comment">// new</span></code></pre><ol start="2"><li>函数库 lodash 的_.cloneDeep 方法</li><li>jQuery.extend()方法</li></ol><p>手动实现深拷贝方法： 通过对需要拷贝的对象的属性进行递归遍历，如果对象的属性不是基本类型时，就继续递归，知道遍历到对象属性为基本类型，然后将属性和属性值赋给新对象。</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copy</span>(<span class="hljs-params">obj</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!obj || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">var</span> newObj = obj.constructor === <span class="hljs-built_in">Array</span> ? [] : &#123;&#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj) &#123;        <span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;                newObj[key] = copy(obj[key])            &#125; <span class="hljs-keyword">else</span> &#123;                newObj[key] = obj[key]            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> newObj&#125;<span class="hljs-keyword">var</span> old = &#123;    a: <span class="hljs-string">&#x27;old&#x27;</span>,    b: &#123;        c: <span class="hljs-string">&#x27;old&#x27;</span>    &#125;&#125;<span class="hljs-keyword">var</span> newObj = copy(old)newObj.b.c = <span class="hljs-string">&#x27;new&#x27;</span><span class="hljs-built_in">console</span>.log(old) <span class="hljs-comment">// &#123; a: &#x27;old&#x27;, b: &#123; c: &#x27;old&#x27; &#125; &#125;</span><span class="hljs-built_in">console</span>.log(newObj) <span class="hljs-comment">// &#123; a: &#x27;old&#x27;, b: &#123; c: &#x27;new&#x27; &#125; &#125;</span></code></pre><p>深拷贝的需要考虑的东西不止于上面几行代码可以解决的，例如你还需要注意：</p><ol><li>入参类型检查</li><li>当数据量较大并层次很深时，使用递归函数会导致栈溢出,而此处又无法使用尾递归,该怎么处理</li><li>typeof Date,Math,RegExp,Function,Null 都返回 Object 该怎么处理</li><li>Date,RegExp,Function 应该如何克隆</li><li>当对象的两个属性 v,s 引用同一个对象时，克隆之后也应该引用同一个对象</li><li>对象的原型 prototype 如何克隆</li><li>属性的 getOwnPropertyDescriptor 如何克隆</li><li>for-in 遍历的是原型链，需要用 hasOwnProperty 判断是否是自有属性</li><li>数组的兼容等…</li></ol><h2 id="介绍下浏览器缓存-强缓存和协商缓存"><a href="#介绍下浏览器缓存-强缓存和协商缓存" class="headerlink" title="介绍下浏览器缓存- 强缓存和协商缓存"></a>介绍下浏览器缓存- 强缓存和协商缓存</h2><ol><li>浏览器在加载资源时，根据请求头的 expires 和 cache-control 判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。</li><li>如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过 last-modified 和 etag 验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源</li><li>如果前面两者都没有命中，直接从服务器加载资源</li></ol><p>它们的相同点： 如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；</p><p>它们的不同点： 强缓存不发请求到服务器，协商缓存会发请求到服务器。</p><h2 id="介绍下-http-状态码，304-是指什么"><a href="#介绍下-http-状态码，304-是指什么" class="headerlink" title="介绍下 http 状态码，304 是指什么"></a>介绍下 http 状态码，304 是指什么</h2><h3 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h3><ol><li>1xx 表示临时响应并需要请求者继续执行操作的状态码。<table><thead><tr><th>状态码</th><th>解释</th></tr></thead><tbody><tr><td>100（继续）</td><td>请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</td></tr><tr><td>101（切换协议）</td><td>请求者已要求服务器切换协议，服务器已确认并准备切换。</td></tr></tbody></table></li><li>2xx 表示成功处理了请求的状态码。<table><thead><tr><th>状态码</th><th>解释</th></tr></thead><tbody><tr><td>200（成功）</td><td>服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。</td></tr><tr><td>201（已创建）</td><td>请求成功并且服务器创建了新的资源。</td></tr><tr><td>202（已接受）</td><td>服务器已接受请求，但尚未处理。</td></tr><tr><td>203（非授权信息）</td><td>服务器已成功处理了请求，但返回的信息可能来自另一来源。</td></tr><tr><td>204（无内容）</td><td>服务器成功处理了请求，但没有返回任何内容。</td></tr><tr><td>205（重置内容）</td><td>服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。</td></tr><tr><td>206（部分内容）</td><td>服务器成功处理了部分 GET 请求。</td></tr></tbody></table></li><li>3xx （重定向） 通常，这些状态码用来重定向。<table><thead><tr><th>状态码</th><th>解释</th></tr></thead><tbody><tr><td>300（多种选择）</td><td>针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</td></tr><tr><td>301（永久移动）</td><td>请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。</td></tr><tr><td>302（临时移动）</td><td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。</td></tr><tr><td>303（查看其他位置）</td><td>请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。</td></tr><tr><td>304（未修改）</td><td>自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。</td></tr><tr><td>305（使用代理）</td><td>请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。</td></tr><tr><td>307（临时重定向）</td><td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 &lt;a href=answer.py?answer=&gt;301</a> 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。</td></tr></tbody></table></li><li>4xx（请求错误） 这些状态码表示请求可能出错，妨碍了服务器的处理。<table><thead><tr><th>状态码</th><th>解释</th></tr></thead><tbody><tr><td>400（错误请求）</td><td>服务器不理解请求的语法。</td></tr><tr><td>401（未授权）</td><td>请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。</td></tr><tr><td>403（禁止）</td><td>服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。</td></tr><tr><td>404（未找到）</td><td>服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具“诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。</td></tr><tr><td>405（方法禁用）</td><td>禁用请求中指定的方法。</td></tr><tr><td>406（不接受）</td><td>无法使用请求的内容特性响应请求的网页。</td></tr><tr><td>407（需要代理授权）</td><td>此状态码与 &lt;a href=answer.py?answer=35128&gt;401（未授权）</a>类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。</td></tr><tr><td>408（请求超时）</td><td>服务器等候请求时发生超时。</td></tr><tr><td>409（冲突）</td><td>服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。</td></tr><tr><td>410（已删除）</td><td>如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。</td></tr><tr><td>411（需要有效长度）</td><td>服务器不接受不含有效内容长度标头字段的请求。</td></tr><tr><td>412（未满足前提条件）</td><td>服务器未满足请求者在请求中设置的其中一个前提条件。</td></tr><tr><td>413（请求实体过大）</td><td>服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</td></tr><tr><td>414（请求的 URI 过长）</td><td>请求的 URI（通常为网址）过长，服务器无法处理。</td></tr><tr><td>415（不支持的媒体类型）</td><td>请求的格式不受请求页面的支持。</td></tr><tr><td>416（请求范围不符合要求）</td><td>如果页面无法提供请求的范围，则服务器会返回此状态码。</td></tr><tr><td>417（未满足期望值）</td><td>服务器未满足”期望”请求标头字段的要求。</td></tr></tbody></table></li><li>5xx（服务器错误） 这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。<table><thead><tr><th>状态码</th><th>解释</th></tr></thead><tbody><tr><td>500（服务器内部错误）</td><td>服务器遇到错误，无法完成请求。</td></tr><tr><td>501（尚未实施）</td><td>服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</td></tr><tr><td>502（错误网关）</td><td>服务器作为网关或代理，从上游服务器收到无效响应。</td></tr><tr><td>503（服务不可用）</td><td>服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</td></tr><tr><td>504（网关超时）</td><td>服务器作为网关或代理，但是没有及时从上游服务器收到请求。</td></tr><tr><td>505（HTTP 版本不受支持）</td><td>服务器不支持请求中所用的 HTTP 协议版本。</td></tr></tbody></table></li></ol><h3 id="304-是指什么"><a href="#304-是指什么" class="headerlink" title="304 是指什么"></a>304 是指什么</h3><p>上面 304 状态码的解释是： 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。<br>它其实就是浏览器的一种缓存机制, 第一次访问 服务器返回 200 ， 按 F5 进行页面刷新，返回 304，强制刷新浏览器， 再次返回 200</p><h2 id="了解过前端工程化吗"><a href="#了解过前端工程化吗" class="headerlink" title="了解过前端工程化吗"></a>了解过前端工程化吗</h2><p>个人理解的前端工程化 是使用软件工程的技术和方法来统一前端开发的流程 ，降低开发的成本，提高开发的效率。<br>以前的开发模式随着项目的复杂度跟多元化，开发成本跟维护成本都要求很高，前端开发者需要维护一大堆的文件，并且开发过程会显得很凌乱，文件耦合度高。<br>所以我认为的前端工程化应该从 模块化，组件化，规范化，自动化方面考虑。</p><ol><li>模块化： 简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。</li><li>组件化：从 UI 拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。</li><li>规范化：规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。</li><li>自动化：前端工程化的很多脏活累活都应该交给自动化工具来完成。</li></ol><h2 id="如何实现移动端的适配"><a href="#如何实现移动端的适配" class="headerlink" title="如何实现移动端的适配"></a>如何实现移动端的适配</h2><ol><li>通过 meta 标签实现 ideal viewport</li><li>通过 rem、vw、vh css 长度单位实现等比缩放</li><li>缩放 init-sacle 的目的是解决 1px 的问题</li><li>关于图片的最佳展示，是根据 dpr 去选择不同倍图</li></ol><h2 id="webp-图文格式了解过吗"><a href="#webp-图文格式了解过吗" class="headerlink" title="webp 图文格式了解过吗"></a>webp 图文格式了解过吗</h2><ol><li>2010 年谷歌推出的新一代图片格式</li><li>保证图片质量的前提下缩小图片体积</li><li>兼容性不太好 （苹果移动端不支持）</li><li>移动应用或移动端网页游戏，界面需要大量图片，可以嵌入 webp 的解码包,能够节省用户流量，提升访问速度</li></ol><h2 id="数组里面有-10-万条数据，取第一个元素和第十万个元素时间相差多少"><a href="#数组里面有-10-万条数据，取第一个元素和第十万个元素时间相差多少" class="headerlink" title="数组里面有 10 万条数据，取第一个元素和第十万个元素时间相差多少"></a>数组里面有 10 万条数据，取第一个元素和第十万个元素时间相差多少</h2><p>js 中所有得数组其实都是对象，数组可以直接根据索引取得对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)<br>得出结论：消耗时间几乎一致，差异可以忽略不计</p><h2 id="如果要你手动实现一个懒加载你怎么实现"><a href="#如果要你手动实现一个懒加载你怎么实现" class="headerlink" title="如果要你手动实现一个懒加载你怎么实现"></a>如果要你手动实现一个懒加载你怎么实现</h2><p>img src 为空，给一个 data-xx 属性存放图片真实地址，当页面滚动到图片可视区域时用 js 取值并赋值该图片</p><h2 id="脚本攻击有哪些，如何防止"><a href="#脚本攻击有哪些，如何防止" class="headerlink" title="脚本攻击有哪些，如何防止"></a>脚本攻击有哪些，如何防止</h2><ol><li>XSS (Cross Site Script) ，跨站脚本攻击</li></ol><pre><code class="hljs JavaScript">永远不要相信用户的输入， 所有的输入都是有害的。跨站脚本是最常见的计算机安全漏洞， 跨站脚本攻击指的是恶意攻击者往Web页面里插入恶意html代码， 当用户浏览该页之时， 嵌入的恶意html代码会被执行， 对受害用户可能采取Cookie资料窃取、 会话劫持、 钓鱼欺骗等各种攻击。解决办法：过滤用户的输入行为， 将其转化为不被浏览器解释执行的字符</code></pre><ol start="2"><li>CSRF(Cross Site Request Forgery)，跨站点伪造请求。</li></ol><pre><code class="hljs JavaScript">CSRF攻击者通过各种方法伪造一个请求， 模仿用户提交表单的行为， 从而达到修改用户的数据， 或者执行特定任务的目的。解决办法：<span class="hljs-number">01.</span> 采用POST请求, 增加攻击的难度.用户点击一个链接就可以发起GET类型的请求。 而POST请求相对比较难， 攻击者往往需要借助javascript才能实现。<span class="hljs-number">02.</span> 对请求进行认证， 确保该请求确实是用户本人填写表单并提交的， 而不是第三者伪造的.具体可以在会话中增加token, 确保看到信息和提交信息的是同一个人。（ 验证码）</code></pre><ol start="3"><li>Http Heads 攻击</li></ol><pre><code class="hljs JavaScript">HTTP协议在Response header和content之间， 有一个空行， 即两组CRLF（ <span class="hljs-number">0x0D</span> <span class="hljs-number">0</span> A） 字符。 这个空行标志着headers的结束和content的开始。“ 聪明” 的攻击者可以利用这一点。 只要攻击者有办法将任意字符“ 注入” 到headers中， 这种攻击就可以发生。解决办法：过滤所有的response headers， 除去header中出现的非法字符， 尤其是CRLF。</code></pre><ol start="4"><li>Cookie 攻击</li></ol><pre><code class="hljs JavaScript">通过Java Script非常容易访问到当前网站的cookie解决办法：增强cookie的安全性， 例如 给 cookie 打上标记</code></pre><ol start="5"><li>重定向攻击</li></ol><pre><code class="hljs JavaScript">一种常用的攻击手段是“ 钓鱼”。 钓鱼攻击者， 通常会发送给受害者一个合法链接， 当链接被点击时， 用户被导向一个似是而非的非法网站， 从而达到骗取用户信任、 窃取用户资料的目的。 为防止这种行为, 我们必须对所有的重定向操作进行审核, 以避免重定向到一个危险的地方.解决办法：常见解决方案是白名单, 将合法的要重定向的url加到白名单中, 非白名单上的域名重定向时拒之, 第二种解决方案是重定向token, 在合法的url上加上token, 重定向时进行验证.</code></pre><ol start="6"><li>上传文件攻击</li></ol><pre><code class="hljs JavaScript"><span class="hljs-number">01.</span> 文件名攻击上传的文件采用上传之前的文件名, 可能造成: 客户端和服务端字符码不兼容, 导致文件名乱码问题;文件名包含脚本, 从而造成攻击.<span class="hljs-number">02.</span> 文件后缀攻击上传的文件的后缀可能是exe可执行程序, js脚本等文件, 这些程序可能被执行于受害者的客户端, 甚至可能执行于服务器上.因此我们必须过滤文件名后缀, 排除那些不被许可的文件名后缀.<span class="hljs-number">03.</span> 文件内容攻击IE6有一个很严重的问题, 它， 而是自动根据文件内容来识别文件的类型， 并根据所识别的类型来显示或执行文件.如果上传一个gif文件, 在文件末尾放一段js攻击脚本, 就有可能被执行.这种攻击, 它的文件名和content type看起来都是合法的gif图片, 然而其内容却包含脚本, 这样的攻击无法用文件名过滤来排除， 而是必须扫描其文件内容， 才能识别</code></pre><ol start="7"><li>DDos 攻击</li></ol><pre><code class="hljs JavaScript">DDos攻击常见三种方式：<span class="hljs-number">01.</span> SYN / ACK Flood攻击：这种攻击方法是经典最有效的DDOS攻击方法， 可通杀各种系统的网络服务， 主要是通过向受害主机发送大量伪造源IP和源端口的SYN（ 建立连接） 或ACK（ 响应） 包， 导致主机的缓存资源被耗尽或忙于发送回应包而造成拒绝服务， 由于源都是伪造的故追踪起来比较困难， 缺点是实施起来有一定难度， 需要高带宽的僵尸主机支持。 少量的这种攻击会导致主机服务器无法访问， 但却可以Ping的通， 在服务器上用Netstat - na命令会观察到存在大量的SYN_RECEIVED状态， 大量的这种攻击会导致Ping失败、 TCP / IP栈失效， 并会出现系统凝固现象， 即不响应键盘和鼠标。 普通防火墙大多无法抵御此种攻击。<span class="hljs-number">02.</span> TCP全连接攻击：这种攻击是为了绕过常规防火墙的检查而设计的， 一般情况下， 常规防火墙大多具备过滤TearDrop、 Land等DOS攻击的能力， 但对于正常的TCP连接是放过的， 殊不知很多网络服务程序（ 如： IIS、 Apache等Web服务器） 能接受的TCP连接数是有限的， 一旦有大量的TCP连接， 即便是正常的， 也会导致网站访问非常缓慢甚至无法访问， TCP全连接攻击就是通过许多僵尸主机不断地与受害服务器建立大量的TCP连接， 直到服务器的内存等资源被耗尽而被拖跨， 从而造成拒绝服务， 这种攻击的特点是可绕过一般防火墙的防护而达到攻击目的， 缺点是需要找很多僵尸主机， 并且由于僵尸主机的IP是暴露的， 因此此种DDOS攻击方式容易被追踪。<span class="hljs-number">03.</span> 刷Script脚本攻击：这种攻击主要是针对存在ASP、 JSP、 PHP、 CGI等脚本程序， 并调用MSSQLServer、 MySQLServer、 Oracle等数据库的网站系统而设计的， 特征是和服务器建立正常的TCP连接， 并不断的向脚本程序提交查询、 列表等大量耗费数据库资源的调用， 典型的以小博大的攻击方法。 一般来说， 提交一个GET或POST指令对客户端的耗费和带宽的占用是几乎可以忽略的， 而服务器为处理此请求却可能要从上万条记录中去查出某个记录， 这种处理过程对资源的耗费是很大的， 常见的数据库服务器很少能支持数百个查询指令同时执行， 而这对于客户端来说却是轻而易举的， 因此攻击者只需通过<span class="hljs-built_in">Proxy</span>代理向主机服务器大量递交查询指令， 只需数分钟就会把服务器资源消耗掉而导致拒绝服务， 常见的现象就是网站慢如蜗牛、 ASP程序失效、 PHP连接数据库失败、 数据库主程序占用CPU偏高。 这种攻击的特点是可以完全绕过普通的防火墙防护， 轻松找一些<span class="hljs-built_in">Proxy</span>代理就可实施攻击， 缺点是对付只有静态页面的网站效果会大打折扣， 并且有些<span class="hljs-built_in">Proxy</span>会暴露DDOS攻击者的IP地址。</code></pre><h2 id="vue-和-react-的区别"><a href="#vue-和-react-的区别" class="headerlink" title="vue 和 react 的区别"></a>vue 和 react 的区别</h2><ol><li>监听数据变化的实现原理不同<br>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化。<br>React 默认是通过比较引用的方式（diff）进行的，如果不优化可能导致大量不必要的 VDOM 的重新渲染。</li><li>数据流的不同<br>Vue1.0 中可以实现两种双向绑定：父子组件之间，props 可以双向绑定；组件与 DOM 之间可以通过 v-model 双向绑定。Vue2.x 中去掉了第一种，也就是父子组件之间不能双向绑定了（但是提供了一个语法糖自动帮你通过事件的方式修改），并且 Vue2.x 已经不鼓励组件对自己的 props 进行任何修改了。<br>React 一直不支持双向绑定，提倡的是单向数据流，称之为 onChange/setState()模式。不过由于我们一般都会用 Vuex 以及 Redux 等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。</li><li>HoC 和 mixins<br>Vue 组合不同功能的方式是通过 mixin<br>React 组合不同功能的方式是通过 HoC(高阶组件）</li><li>组件通信的区别<br>Vue 中有三种方式可以实现组件通信：1. 父组件通过 props 向子组件传递数据或者回调，虽然可以传递回调，但是我们一般只传数据；2. 子组件通过事件向父组件发送消息；3. 通过 V2.2.0 中新增的 provide/inject 来实现父组件向子组件注入数据，可以跨越多个层级。<br>React 中也有对应的三种方式：1. 父组件可以通过 props 方式传递数据；也可以通过 ref 方式传递数据；2. 子组件向父组件通信，通过回调函数方式传递数据； 3. 父组件向后代所有组件传递数据，如果组件层级过多，通过 props 的方式传递数据很繁琐，可以通过 Context. Provider 的方式；</li><li>模板渲染方式的不同<br>在表层上，模板的语法不同，React 是通过 JSX 渲染模板。而 Vue 是通过一种拓展的 HTML 语法进行渲染，但其实这只是表面现象，毕竟 React 并不必须依赖 JSX。<br>在深层上，模板的原理不同，这才是他们的本质区别：React 是在组件 JS 代码中，通过原生 JS 实现模板中的常见语法，比如插值，条件，循环等，都是通过 JS 语法实现的，更加纯粹更加原生。而 Vue 是在和组件 JS 代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现对这一点，这样的做法显得有些独特，会把 HTML 弄得很乱。<br>举个例子，说明 React 的好处：react 中 render 函数是支持闭包特性的，所以我们 import 的组件在 render 中可以直接调用。但是在 Vue 中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以我们 import 一个组件完了之后，还需要在 components 中再声明下，这样显然是很奇怪但又不得不这样的做法。</li><li>渲染过程不同<br>Vue 可以更快地计算出 Virtual DOM 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。<br>React 在应用的状态被改变时，全部子组件都会重新渲染。通过 shouldComponentUpdate 这个生命周期方法可以进行控制，但 Vue 将此视为默认的优化。<br>如果应用中交互复杂，需要处理大量的 UI 变化，那么使用 Virtual DOM 是一个好主意。如果更新元素并不频繁，那么 Virtual DOM 并不一定适用，性能很可能还不如直接操控 DOM。</li><li>框架本质不同<br>Vue 本质是 MVVM 框架，由 MVC 发展而来；<br>React 是前端组件化框架，由后端组件化发展而来。</li><li>Vuex 和 Redux 的区别<br>从表面上来说，store 注入和使用方式有一些区别。在 Vuex 中，$store被直接注入到了组件实例中，因此可以比较灵活的使用：使用dispatch、commit提交更新，通过mapState或者直接通过this.$store 来读取数据。在 Redux 中，我们每一个组件都需要显示的用 connect 把需要的 props 和 dispatch 连接起来。另外，Vuex 更加灵活一些，组件中既可以 dispatch action，也可以 commit updates，而 Redux 中只能进行 dispatch，不能直接调用 reducer 进行修改。<br>从实现原理上来说，最大的区别是两点：Redux 使用的是不可变数据，而 Vuex 的数据是可变的，因此，Redux 每次都是用新 state 替换旧 state，而 Vuex 是直接修改。Redux 在检测数据变化的时候，是通过 diff 的方式比较差异的，而 Vuex 其实和 Vue 的原理一样，是通过 getter/setter 来比较的，这两点的区别，也是因为 React 和 Vue 的设计理念不同。React 更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue 更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。因此也会给人一种大型项目用 React，小型项目用 Vue 的感觉。</li></ol><h2 id="ios-双击能缩放，怎么禁止"><a href="#ios-双击能缩放，怎么禁止" class="headerlink" title="ios 双击能缩放，怎么禁止"></a>ios 双击能缩放，怎么禁止</h2><p>在 ios10 以前 ，我们可以使用 meta 标签并设置 viewport</p><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover&quot;</span>&gt;</span></code></pre><p>ios10 之后， 上面的方法失效，可以监听点击事件阻止事件传播，代码：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> lastTouchEnd = <span class="hljs-number">0</span>;<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;    <span class="hljs-keyword">if</span> (event.touches.length &gt; <span class="hljs-number">1</span>) &#123;        event.preventDefault();    &#125;&#125;);<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;touchend&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;    <span class="hljs-keyword">const</span> now = (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).getTime();    <span class="hljs-keyword">if</span> (now - lastTouchEnd &lt;= <span class="hljs-number">300</span>) &#123;        event.preventDefault();    &#125;    lastTouchEnd = now;&#125;, <span class="hljs-literal">false</span>);</code></pre><p>上述方法是阻止页面双击放大， 阻止缩放代码：</p><pre><code class="hljs JavaScript"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;gesturestart&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;    event.preventDefault();&#125;);</code></pre><h2 id="iPhone-刘海机型背景覆盖"><a href="#iPhone-刘海机型背景覆盖" class="headerlink" title="iPhone 刘海机型背景覆盖"></a>iPhone 刘海机型背景覆盖</h2><p>设置 meta 时，content 内增加 viewport-fit=cover</p><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover&quot;</span>&gt;</span></code></pre><h2 id="阻止-ios-“橡皮筋”效果"><a href="#阻止-ios-“橡皮筋”效果" class="headerlink" title="阻止 ios “橡皮筋”效果"></a>阻止 ios “橡皮筋”效果</h2><ol><li>阻止 window 滚动；<br>要加{passive:false}否则在 iOS 上不起作用，因为 iOS Safari 不会阻止默认页面滚动。</li></ol><pre><code class="hljs JavaScript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;touchmove&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;    e.preventDefault();&#125;, &#123;    passive: <span class="hljs-literal">false</span>&#125;);</code></pre><ol start="2"><li>开启容器滚动；（需要滚动时）<br>一定要阻止冒泡。</li></ol><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> content = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.content&#x27;</span>);content?.addEventListener(<span class="hljs-string">&#x27;touchmove&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;    e.stopPropagation();&#125;, &#123;    passive: <span class="hljs-literal">false</span>,    capture: <span class="hljs-literal">false</span>&#125;);</code></pre><ol start="3"><li>开启硬件加速；<br>关键属性-webkit-overflow-scrolling<br>这个属性可以触发浏览器的硬件加速，如果没有这个属性，那么滑动的过程会很卡，一抖一抖的掉帧严重，甚至带动整个页面移动。本身它的作用是启用滑动回弹效果，使滑动更流畅。<br>取值：<br>auto: 使用普通滚动，手指从触摸屏离开滚动即停止；<br>touch：使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果，继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。</li></ol><pre><code class="hljs css"><span class="hljs-selector-class">.content</span> &#123;    <span class="hljs-attribute">overflow</span>: auto;    <span class="hljs-attribute">-webkit-overflow-scrolling</span>: touch;&#125;</code></pre><ol start="4"><li>阻止滚动越界；<br>当滚动到页面顶部或底部时，手指离开停下，再继续向下向上滑动，就会出现滚动越界现象，此时需要进行滚动修复，阻止继续滚动带动整个页面移动。</li></ol><pre><code class="hljs JavaScript">content?.addEventListener(<span class="hljs-string">&#x27;touchmove&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (content.scrollTop &lt;= <span class="hljs-number">0</span>) &#123;        content.scrollTop = <span class="hljs-number">1</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (content.scrollTop + content.clientHeight &gt;= content.scrollHeight) &#123;        content.scrollTop = content.scrollHeight - content.clientHeight - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 别忘了阻止冒泡</span>    e.stopPropagation();&#125;, &#123;    passive: <span class="hljs-literal">false</span>,    capture: <span class="hljs-literal">false</span>&#125;);</code></pre><h2 id="cookie-和-session-的区别，cookie-有什么限制"><a href="#cookie-和-session-的区别，cookie-有什么限制" class="headerlink" title="cookie 和 session 的区别，cookie 有什么限制"></a>cookie 和 session 的区别，cookie 有什么限制</h2><p>由于 http 的无状态性，为了使某个域名下的所有网页能够共享某些数据，session 和 cookie 出现了。</p><ol><li>cookie 数据存放在客户的浏览器（客户端）上，session 数据放在服务器上，但是服务端的 session 的实现对客户端的 cookie 有依赖关系的；</li><li>cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗，考虑到安全应当使用 session；</li><li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用 COOKIE；</li></ol><p>cookie 有什么限制： 各浏览器之间对 cookie 的不同限制，在进行页面 cookie 操作的时候，应该尽量保证 cookie 个数小于 20 个，总大小 小于 4KB</p><h2 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h2><p>负载均衡是由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，都可以单独对外供应效力而无须其他服务器的辅助。经过某种负载分管技术，将外部发送来的央求均匀分配到对称结构中的某一台服务器上，而接收到央求的服务器独登时回应客户的央求。均衡负载可以平均分配客户央求到服务器列阵，籍此供应快速获取重要数据，解决很多并发访问效力问题。这种群集技术可以用最少的出资取得接近于大型主机的性能。</p><h2 id="如何抓包"><a href="#如何抓包" class="headerlink" title="如何抓包"></a>如何抓包</h2><p>window 可以使用 Fiddler<br>mac 可以使用 Charles</p><h2 id="数组方法，用过-reduce-吗"><a href="#数组方法，用过-reduce-吗" class="headerlink" title="数组方法，用过 reduce 吗"></a>数组方法，用过 reduce 吗</h2><p>数组方法：</p><ol><li>push() 尾端添加元素</li><li>pop() 尾端提取元素</li><li>shift() 首端提取元素</li><li>unshift() 首端添加元素</li><li>splice() 添加，删除和插入元素 ， 返回被删除后的数组</li><li>slice() 浅拷贝数组，返回拷贝的数组，原数组不会被改变</li><li>concat() 用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</li></ol><p>reduce 方法：<br>Array.reduce()接受两个参数：一个是对数组每个元素执行的回调方法，一个是初始值。<br>这个回调也接受两个参数：accumulator 是当前聚合值，current 是数组循环时的当前元素。无论你返回什么值，都将作为累加器提供给循环中的下一个元素。初始值将作为第一次循环的累加器。</p><h2 id="es6-新特性"><a href="#es6-新特性" class="headerlink" title="es6 新特性"></a>es6 新特性</h2><ol><li>let 、const、</li><li>模板字符串</li><li>箭头函数</li><li>函数的参数默认值</li><li>Spread / Rest 操作符 …</li><li>二进制和八进制字面量</li><li>对象和数组解构</li><li>对象超类, ES6 允许在对象中使用 super 方法</li><li>for…of 和 for…in</li><li>ES6 中的类</li></ol><h2 id="promise-有几个状态"><a href="#promise-有几个状态" class="headerlink" title="promise 有几个状态"></a>promise 有几个状态</h2><p>Promise 的三种状态：<br>pending、fulfilled、rejected(未决定，履行，拒绝)，同一时间只能存在一种状态, 且状态一旦改变就不能再变。promise 是一个构造函数，promise 对象代表一项有两种可能结果（成功或失败）的任务，它还持有多个回调，出现不同结果时分别发出相应回调。</p><ol><li>初始化，状态：pending 2. 当调用 resolve(成功)，状态：pengding=&gt;fulfilled 3. 当调用 reject(失败)，状态：pending=&gt;rejected</li></ol><p>promise 的优缺点：<br>优点：<br>01. Promise 分离了异步数据获取和业务逻辑，有利于代码复用。<br>​2. 可以采用链式写法<br>​3. 一旦 Promise 的值确定为 fulfilled 或者 rejected 后，不可改变。<br>缺点：<br>代码冗余，语义不清。</p><h2 id="为什么用-Promise"><a href="#为什么用-Promise" class="headerlink" title="为什么用 Promise"></a>为什么用 Promise</h2><ol><li>解决回调地狱 2. 解决异步</li></ol><h2 id="new-一个对象的过程发生了什么"><a href="#new-一个对象的过程发生了什么" class="headerlink" title="new 一个对象的过程发生了什么"></a>new 一个对象的过程发生了什么</h2><p>（1）创建一个新对象；</p><p>（2）将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</p><p>（3）执行构造函数中的代码（为这个新对象添加属性）；</p><p>（4）返回新对象。</p><h2 id="说说闭包，用途，哪些场景会引起闭包"><a href="#说说闭包，用途，哪些场景会引起闭包" class="headerlink" title="说说闭包，用途，哪些场景会引起闭包"></a>说说闭包，用途，哪些场景会引起闭包</h2><p>由于 JavaScript 的链式作用域，子对象会一级一级的向上寻找，所以，父对象的所有变量，对子对象都是可见的，反之则不成立。<br>既然父对象的所有变量对子对象可见，那么只要把子对象作为返回值返回，我们就可以在外部访问局部变量了</p><p>所以我的理解是：<br>闭包就是能够读取其他函数内部变量的函数（可以想象成 儿子拿着父亲的东西出去浪 ）。</p><p>用途：<br>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p><p>场景：</p><ol><li>匿名自执行函数</li><li>结果缓存</li><li>封装</li><li>实现类和继承</li></ol><p>优缺点：<br>优点： 1. 可以读取函数内部的变量 2. 可以让这些局部变量保存在内存中，实现变量数据共享。</p><p>缺点： 1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p><h2 id="说说-eventloop-说说什么是宏任务和微任务，分别有哪些"><a href="#说说-eventloop-说说什么是宏任务和微任务，分别有哪些" class="headerlink" title="说说 eventloop, 说说什么是宏任务和微任务，分别有哪些"></a>说说 eventloop, 说说什么是宏任务和微任务，分别有哪些</h2><h3 id="浏览器中的事件循环"><a href="#浏览器中的事件循环" class="headerlink" title="浏览器中的事件循环"></a>浏览器中的事件循环</h3><p>JavaScript 代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来搞定另外一些代码的执行。整个执行过程，我们称为事件循环过程。一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列又分为 macro-task（宏任务）与 micro-task（微任务），在最新标准中，它们被分别称为 task 与 jobs。</p><p>macro-task（宏任务）大概包括： 1. script(整体代码) 2. setTimeout 3. setInterval 4. setImmediate 5. I/O 6. UI render</p><p>micro-task（微任务）大概包括: 1. process.nextTick 2. Promise 3. Async/Await(实际就是 promise) 4. MutationObserver(html5 新特性)</p><p>执行机制：<br>先执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环</p><p>注意 async/await 执行顺序<br>我们知道 async 隐式返回 Promise 作为结果的函数, 那么可以简单理解为，await 后面的函数执行完毕时，await 会产生一个微任务(Promise.then 是微任务)。<br>但是我们要注意这个微任务产生的时机，它是执行完 await 之后，直接跳出 async 函数，执行其他代码(此处就是协程的运作，A 暂停执行，控制权交给 B)。<br>其他代码执行完毕后，再回到 async 函数去执行剩下的代码，然后把 await 后面的代码注册到微任务队列当中。<br>但是 ， 新版的 chrome 浏览器中因为 chrome 优化了, await 变得更快了， 但是这种做法其实是违反了规范的，当然规范也是可以更改的，这是 V8 团队的一个 PR ，目前新版打印已经修改。<br>知乎上也有相关讨论, 可以看看 <a href="https://www.zhihu.com/question/268007969">https://www.zhihu.com/question/268007969</a></p><p>我们可以分 2 种情况来理解： 1. 如果 await 后面直接跟的为一个变量，比如：await 1；这种情况的话相当于直接把 await 后面的代码注册为一个微任务，可以简单理解为 promise.then(await 下面的代码)。然后跳出 async1 函数，执行其他代码，当遇到 promise 函数的时候，会注册 promise.then()函数到微任务队列，注意此时微任务队列里面已经存在 await 后面的微任务。所以这种情况会先执行 await 后面的代码（async1 end），再执行 async1 函数后面注册的微任务代码(promise1, promise2)。 2. 如果 await 后面跟的是一个异步函数的调用，此时执行完 awit 并不先把 await 后面的代码注册到微任务队列中去，而是执行完 await 之后，直接跳出 async1 函数，执行其他代码。然后遇到 promise 的时候，把 promise.then 注册为微任务。其他代码执行完毕后，需要回到 async1 函数去执行剩下的代码，然后把 await 后面的代码注册到微任务队列当中，注意此时微任务队列中是有之前注册的微任务的。所以这种情况会先执行 async1 函数之外的微任务(promise1, promise2)，然后才执行 async1 内注册的微任务(async1 end). 可以理解为，这种情况下，await 后面的代码会在本轮循环的最后被执行.</p><h3 id="node-中的事件循环"><a href="#node-中的事件循环" class="headerlink" title="node 中的事件循环"></a>node 中的事件循环</h3><p>浏览器中有事件循环，node 中也有，事件循环是 node 处理非阻塞 I/O 操作的机制，node 中事件循环的实现是依靠的 libuv 引擎。由于 node 11 之后，事件循环的一些原理发生了变化，这里就以新的标准去讲，最后再列上变化点让大家了解前因后果。</p><p>macro-task（宏任务）大概包括： 1. setTimeout 2. setInterval 3. setImmediate 4. script（整体代码) 5. I/O 操作等。</p><p>micro-task（微任务）大概包括: 1. process.nextTick(与普通微任务有区别，在微任务队列执行之前执行) 2. new Promise().then(回调)等。</p><p>执行机制：<br>输入数据阶段(incoming data)-&gt;轮询阶段(poll)-&gt;检查阶段(check)-&gt;关闭事件回调阶段(close callback)-&gt;定时器检测阶段(timers)-&gt;I/O 事件回调阶段(I/O callbacks)-&gt;闲置阶段(idle, prepare)-&gt;轮询阶段…</p><p>node 的事件循环是阶段性的， 当连接服务器的时候 进入 输入数据阶段， 然后进入轮询阶段，然后进入检查阶段，接下来是关闭事件回调阶段 ， 定时器检测阶段 ，i/o 事件回调阶段，闲置阶段 ， 最后再次进入轮询阶段</p><p>阶段概述：</p><ol><li>定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数。</li><li>I/O 事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些 I/O 回调。</li><li>闲置阶段(idle, prepare)：仅系统内部使用。</li><li>轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。</li><li>检查阶段(check)：setImmediate() 回调函数在这里执行</li><li>关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on(‘close’, …)。</li></ol><p>三大重点阶段：<br>日常开发中的绝大部分异步任务都是在 poll、check、timers 这 3 个阶段处理的</p><p>timers 阶段:<br>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。</p><p>poll 阶段：<br>poll 是一个至关重要的阶段，poll 阶段的执行逻辑流程如下：<br>如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到 timers 阶段。<br>如果没有定时器, 会去看回调函数队列。<br>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制<br>如果 poll 队列为空时，会有两件事发生<br>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调<br>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去, 一段时间后自动进入 check 阶段。<br>check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。<br>process.nextTick 是一个独立于 eventLoop 的任务队列。<br>在每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行。</p><p>node 和 浏览器 eventLoop 的主要区别<br>两者最主要的区别在于： 浏览器中的微任务是在每个相应的宏任务中执行的，而 nodejs 中的微任务是在不同阶段之间执行的。</p><h2 id="apply，call，bind-三者的区别"><a href="#apply，call，bind-三者的区别" class="headerlink" title="apply，call，bind 三者的区别"></a>apply，call，bind 三者的区别</h2><ol><li>三者都可以改变函数的 this 对象指向。</li><li>三者第一个参数都是 this 要指向的对象，如果如果没有这个参数或参数为 undefined 或 null，则默认指向全局 window。</li><li>三者都可以传参，但是 apply 是数组，而 call 是参数列表，且 apply 和 call 是一次性传入参数，而 bind 可以分为多次传入。</li><li>bind 是返回绑定 this 之后的函数，便于稍后调用；apply 、call 则是立即执行 。</li></ol><h2 id="如何判断一个变量是不是数组"><a href="#如何判断一个变量是不是数组" class="headerlink" title="如何判断一个变量是不是数组"></a>如何判断一个变量是不是数组</h2><ol><li>isArray</li><li>instanceof （不能准确判断）<br>instanceof 操作符的问题在于，它假定只有一个全局环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。<br>如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。</li><li>Object.prototype.toString.call</li><li>constructor （不能准确判断）<br>constructor 可以被重写，所以不能确保一定是数组</li></ol><h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h2><ol><li>语法更加简洁、清晰</li><li>箭头函数不会创建自己的 this</li><li>箭头函数继承而来的 this 指向永远不变</li><li>.call()/.apply()/.bind()无法改变箭头函数中 this 的指向</li><li>箭头函数不能作为构造函数使用</li><li>箭头函数没有自己的 arguments</li><li>箭头函数没有原型 prototype</li><li>箭头函数不能用作 Generator 函数，不能使用 yeild 关键字</li></ol><h2 id="let-const-var-的区别"><a href="#let-const-var-的区别" class="headerlink" title="let const var 的区别"></a>let const var 的区别</h2><ol><li>var 具有 变量提</li><li>let const 具有暂时性死区 ，不具备变量提升</li><li>let const 不允许重复声明</li><li>const 声明的是常量，不允许更改</li><li>ES5 中只有全局作用域跟函数作用域， const let 增加了块级作用域</li></ol><h2 id="js-继承的实现方法"><a href="#js-继承的实现方法" class="headerlink" title="js 继承的实现方法"></a>js 继承的实现方法</h2><p>JavaScript 中继承的方式有很多， 每种继承方式都有它的优缺点， 接下来我们了解下每种继承的方式，首先继承需要一个父类，es6 中的 class 实际上是 es5 的语法糖，这里我们使用 es5 的写法：</p><pre><code class="hljs JavaScript"><span class="hljs-comment">// 父类 People</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">name</span>) </span>&#123;    <span class="hljs-comment">//属性</span>    <span class="hljs-built_in">this</span>.name = name || Annie    <span class="hljs-comment">//实例方法</span>    <span class="hljs-built_in">this</span>.sleep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;正在睡觉&#x27;</span>)    &#125;&#125;<span class="hljs-comment">//原型方法</span>People.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">food</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;正在吃：&#x27;</span> + food);&#125;</code></pre><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><pre><code class="hljs JavaScript"><span class="hljs-comment">// 原型链继承</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">woMan</span>(<span class="hljs-params"></span>) </span>&#123;&#125;woMan.prototype = <span class="hljs-keyword">new</span> People()woMan.prototype.name = <span class="hljs-string">&#x27;lynn&#x27;</span><span class="hljs-keyword">let</span> woManObj = <span class="hljs-keyword">new</span> woMan()</code></pre><p>优点：简单易于实现，父类的新增的实例与属性子类都能访问<br>缺点：<br>1.1 可以在子类中增加实例属性，如果要新增加原型属性和方法需要在 new 父类构造函数的后面<br>1.2 无法实现多继承<br>1.3 创建子类实例时，不能向父类构造函数中传参数</p><h3 id="借用构造函数继承（伪造对象、经典继承）"><a href="#借用构造函数继承（伪造对象、经典继承）" class="headerlink" title="借用构造函数继承（伪造对象、经典继承）"></a>借用构造函数继承（伪造对象、经典继承）</h3><pre><code class="hljs JavaScript"><span class="hljs-comment">// 复制父类的实例属性给子类</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">woMan</span>(<span class="hljs-params">name</span>) </span>&#123;    People.call(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// People.call(this，&#x27;xing&#x27;)</span>    <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;lynn&#x27;</span>&#125;<span class="hljs-keyword">let</span> woManObj = <span class="hljs-keyword">new</span> woMan()</code></pre><p>优点：<br>2.1 解决了子类构造函数向父类构造函数中传递参数<br>2.2 可以实现多继承（call 或者 apply 多个父类）<br>缺点:<br>2.1 方法都在构造函数中定义，无法复用<br>2.2 不能继承原型属性/方法，只能继承父类的实例属性和方法<br>2.3 每个新实例都有父类构造函数的副本，臃肿</p><h3 id="实例继承（原型式继承）"><a href="#实例继承（原型式继承）" class="headerlink" title="实例继承（原型式继承）"></a>实例继承（原型式继承）</h3><pre><code class="hljs JavaScript"><span class="hljs-comment">// 原型式继承</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">woMan</span>(<span class="hljs-params">name</span>) </span>&#123;    <span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> People()    instance.name = name || <span class="hljs-string">&#x27;xing&#x27;</span>;    <span class="hljs-keyword">return</span> instance;&#125;<span class="hljs-keyword">let</span> woManObj = <span class="hljs-keyword">new</span> woMan()</code></pre><p>优点：<br>3.1 不限制调用方式<br>3.2 简单，易实现<br>缺点：不能多次继承</p><h3 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h3><pre><code class="hljs JavaScript"><span class="hljs-comment">// 调用父类构造函数，继承父类的属性，通过将父类实例作为子类原型，实现函数复用</span><span class="hljs-comment">// 父类</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;xing&#x27;</span>    <span class="hljs-built_in">this</span>.age = age || <span class="hljs-number">27</span>&#125;People.prototype.sleep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;正在睡觉&#x27;</span>)&#125;People.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name + <span class="hljs-built_in">this</span>.age + <span class="hljs-string">&#x27;eat sleep&#x27;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">woMan</span>(<span class="hljs-params">name, age</span>) </span>&#123;    People.call(<span class="hljs-built_in">this</span>, name, age)&#125;woMan.prototype = <span class="hljs-keyword">new</span> People()woMan.prototype.constructor = woMan<span class="hljs-keyword">let</span> woManObj = <span class="hljs-keyword">new</span> woMan(<span class="hljs-string">&#x27;lynn&#x27;</span>, <span class="hljs-number">27</span>)woManObj.eat()</code></pre><p>优点：<br>4.1 函数可以复用<br>4.2 不存在引用属性问题<br>4.3 可以继承属性和方法，并且可以继承原型的属性和方法<br>缺点：<br>4.1 由于调用了两次父类，所以产生了两份实例</p><h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><pre><code class="hljs JavaScript"><span class="hljs-comment">// 通过寄生的方式来修复组合式继承的不足，完美的实现继承</span><span class="hljs-comment">// 父类</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;xing&#x27;</span>    <span class="hljs-built_in">this</span>.age = age || <span class="hljs-number">27</span>&#125;People.prototype.sleep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;正在睡觉&#x27;</span>)&#125;People.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name + <span class="hljs-built_in">this</span>.age + <span class="hljs-string">&#x27;eat sleep&#x27;</span>&#125;<span class="hljs-comment">// 子类</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">woMan</span>(<span class="hljs-params">name, age</span>) </span>&#123;    People.call(<span class="hljs-built_in">this</span>, name, age)&#125;<span class="hljs-comment">//继承父类方法</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 创建空类</span>    <span class="hljs-keyword">let</span> Super = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;    Super.prototype = People.prototype;    <span class="hljs-comment">//父类的实例作为子类的原型</span>    woMan.prototype = <span class="hljs-keyword">new</span> Super();&#125;)();<span class="hljs-comment">//修复构造函数指向问题</span>woMan.prototype.constructor = woMan<span class="hljs-keyword">let</span> woManObj = <span class="hljs-keyword">new</span> woMan(<span class="hljs-string">&#x27;lynn&#x27;</span>, <span class="hljs-number">27</span>)woManObj.eat()</code></pre><h3 id="es6-继承"><a href="#es6-继承" class="headerlink" title="es6 继承"></a>es6 继承</h3><pre><code class="hljs JavaScript"><span class="hljs-comment">// 父类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(name = &#x27;xing&#x27;, age = &#x27;27&#x27;) &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.age = age;    &#125;    eat() &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.age&#125;</span> eat food`</span>)    &#125;&#125;<span class="hljs-comment">// 子类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-title">extend</span> <span class="hljs-title">People</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(name = &#x27;lynn&#x27;, age = &#x27;27&#x27;) &#123;        <span class="hljs-comment">//继承父类属性</span>        <span class="hljs-built_in">super</span>(name, age);    &#125;    eat() &#123;        <span class="hljs-comment">//继承父类方法</span>        <span class="hljs-built_in">super</span>.eat()    &#125;    sleep() &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;正在睡觉&#x27;</span>)    &#125;&#125;<span class="hljs-keyword">let</span> wonmanObj = <span class="hljs-keyword">new</span> Woman(<span class="hljs-string">&#x27;lynn&#x27;</span>);wonmanObj.eat();</code></pre><h3 id="ES5-继承和-ES6-继承的区别"><a href="#ES5-继承和-ES6-继承的区别" class="headerlink" title="ES5 继承和 ES6 继承的区别"></a>ES5 继承和 ES6 继承的区别</h3><p>es5 继承首先是在子类中创建自己的 this 指向，最后将方法添加到 this 中<br>Child.prototype=new Parent() || Parent.apply(this) || Parent.call(this)<br>es6 继承是使用关键字先创建父类的实例对象 this，最后在子类 class 中修改 this</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个数组的交集</title>
    <link href="/articles/2020/11/02/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <url>/articles/2020/11/02/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><p>示例 1：</p><pre><code class="hljs javascript">输入：nums1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], nums2 = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]输出：[<span class="hljs-number">2</span>]</code></pre><p>示例 2：</p><pre><code class="hljs javascript">输入：nums1 = [<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>], nums2 = [<span class="hljs-number">9</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>]输出：[<span class="hljs-number">9</span>,<span class="hljs-number">4</span>]</code></pre><details>  <summary>    <b>答案</b>  </summary>  <p>  set集合解题法：    使用set集合解题， 判断集合的每一项是否存在另一个集合当中<pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums1</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums2</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> intersection = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums1, nums2</span>) </span>&#123; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set_intersection</span>(<span class="hljs-params">set1, set2</span>) </span>&#123;  <span class="hljs-keyword">if</span> (set1.size &gt; set2.size) &#123;   <span class="hljs-comment">// 目的 保证长的集合是第一个参数</span>   <span class="hljs-keyword">return</span> set_intersection(set2, set1);  &#125;  <span class="hljs-keyword">const</span> intersection = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();  <span class="hljs-comment">// 遍历判断是否存在 另一个集合当中</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> set1) &#123;   <span class="hljs-keyword">if</span> (set2.has(num)) &#123;    intersection.add(num);   &#125;  &#125;  <span class="hljs-keyword">return</span> [...intersection]; &#125; <span class="hljs-keyword">let</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(nums1); <span class="hljs-keyword">let</span> set2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(nums2); <span class="hljs-keyword">return</span> set_intersection(set1, set2);&#125;;<span class="hljs-keyword">let</span> nums1 = [<span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>];<span class="hljs-keyword">let</span> nums2 = [<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>];<span class="hljs-keyword">const</span> intersection_res = intersection(nums1, nums2);</code></pre><p>哈希 解题法：</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums1</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums2</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> intersection = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums1, nums2</span>) </span>&#123; <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(); nums1.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;  map.set(item, <span class="hljs-literal">true</span>); &#125;); <span class="hljs-keyword">return</span> nums2.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (map.has(item)) &#123;   map.delete(item);   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;);&#125;;<span class="hljs-keyword">const</span> intersection_res = intersection([<span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);</code></pre>  </p></details><hr>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>set 集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求根到叶子节点数字之和</title>
    <link href="/articles/2020/10/29/%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    <url>/articles/2020/10/29/%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="求根到叶子节点数字之和"><a href="#求根到叶子节点数字之和" class="headerlink" title="求根到叶子节点数字之和"></a>求根到叶子节点数字之和</h2><p>给定一个二叉树，它的每个结点都存放一个  0-9  的数字，每条从根到叶子节点的路径都代表一个数字。</p><p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p><p>计算从根到叶子节点生成的所有数字之和。</p><p>说明:  叶子节点是指没有子节点的节点。</p><p>示例 1：</p><pre><code class="hljs javascript">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]    <span class="hljs-number">1</span>   / \  <span class="hljs-number">2</span>   <span class="hljs-number">3</span>输出: <span class="hljs-number">25</span>解释:从根到叶子节点路径 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span> 代表数字 <span class="hljs-number">12.</span>从根到叶子节点路径 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span> 代表数字 <span class="hljs-number">13.</span>因此，数字总和 = <span class="hljs-number">12</span> + <span class="hljs-number">13</span> = <span class="hljs-number">25.</span></code></pre><p>示例 2：</p><pre><code class="hljs javascript">输入: [<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>]    <span class="hljs-number">4</span>   / \  <span class="hljs-number">9</span>   <span class="hljs-number">0</span> / \<span class="hljs-number">5</span>   <span class="hljs-number">1</span>输出: <span class="hljs-number">1026</span>解释:从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">9</span>-&gt;<span class="hljs-number">5</span> 代表数字 <span class="hljs-number">495.</span>从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">9</span>-&gt;<span class="hljs-number">1</span> 代表数字 <span class="hljs-number">491.</span>从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">0</span> 代表数字 <span class="hljs-number">40.</span>因此，数字总和 = <span class="hljs-number">495</span> + <span class="hljs-number">491</span> + <span class="hljs-number">40</span> = <span class="hljs-number">1026.</span></code></pre><details>  <summary>    <b>答案</b>  </summary>  <p>深度优先搜索解题法：<p>从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历。</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> sumNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123; <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">root, prevSum</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-keyword">let</span> sum = prevSum * <span class="hljs-number">10</span> + root.val; <span class="hljs-comment">// 这里假设父节点 为 0 ， 得到节点上的对应的数字</span>  <span class="hljs-keyword">if</span> (root.left === <span class="hljs-literal">null</span> &amp;&amp; root.right === <span class="hljs-literal">null</span>) &#123;   <span class="hljs-keyword">return</span> sum;  &#125;  <span class="hljs-keyword">let</span> res = dfs(root.left, sum) + dfs(root.right, sum);  <span class="hljs-keyword">return</span> res; &#125;; <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>);&#125;;<span class="hljs-keyword">let</span> root = &#123; val: <span class="hljs-number">4</span>, left: &#123;  val: <span class="hljs-number">9</span>,  left: &#123;   val: <span class="hljs-number">5</span>,   left: <span class="hljs-literal">null</span>,   right: <span class="hljs-literal">null</span>,  &#125;,  right: &#123;   val: <span class="hljs-number">1</span>,   left: <span class="hljs-literal">null</span>,   right: <span class="hljs-literal">null</span>,  &#125;, &#125;, right: &#123;  val: <span class="hljs-number">0</span>,  left: <span class="hljs-literal">null</span>,  right: <span class="hljs-literal">null</span>, &#125;,&#125;;<span class="hljs-keyword">const</span> num = sumNumbers(root);</code></pre><p>广度优先搜索解题法：</p><p>使用广度优先搜索，需要维护两个队列，分别存储节点和节点对应的数字。</p><p>初始时，将根节点和根节点的值分别加入两个队列。每次从两个队列分别取出一个节点和一个数字，进行如下操作：</p><p>如果当前节点是叶子节点，则将该节点对应的数字加到数字之和；</p><p>如果当前节点不是叶子节点，则获得当前节点的非空子节点，并根据当前节点对应的数字和子节点的值计算子节点对应的数字，然后将子节点和子节点对应的数字分别加入两个队列。</p><p>搜索结束后，即可得到所有叶子节点对应的数字之和。</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> sumNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123; <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>; <span class="hljs-keyword">const</span> nodeQueue = []; <span class="hljs-keyword">const</span> numQueue = []; nodeQueue.push(root); numQueue.push(root.val); <span class="hljs-keyword">while</span> (nodeQueue.length) &#123;  <span class="hljs-keyword">const</span> node = nodeQueue.shift(); <span class="hljs-comment">// shift 返回数组中第一个元素</span>  <span class="hljs-keyword">const</span> num = numQueue.shift();  <span class="hljs-keyword">const</span> left = node.left;  <span class="hljs-keyword">const</span> right = node.right;  <span class="hljs-keyword">if</span> (left === <span class="hljs-literal">null</span> &amp;&amp; right === <span class="hljs-literal">null</span>) &#123;   sum += num;  &#125; <span class="hljs-keyword">else</span> &#123;   <span class="hljs-keyword">if</span> (left !== <span class="hljs-literal">null</span>) &#123;    nodeQueue.push(left);    numQueue.push(num * <span class="hljs-number">10</span> + left.val);   &#125;   <span class="hljs-keyword">if</span> (right !== <span class="hljs-literal">null</span>) &#123;    nodeQueue.push(right);    numQueue.push(num * <span class="hljs-number">10</span> + right.val);   &#125;  &#125; &#125; <span class="hljs-keyword">return</span> sum;&#125;;<span class="hljs-keyword">let</span> root = &#123; val: <span class="hljs-number">4</span>, left: &#123;  val: <span class="hljs-number">9</span>,  left: &#123;   val: <span class="hljs-number">5</span>,   left: <span class="hljs-literal">null</span>,   right: <span class="hljs-literal">null</span>,  &#125;,  right: &#123;   val: <span class="hljs-number">1</span>,   left: <span class="hljs-literal">null</span>,   right: <span class="hljs-literal">null</span>,  &#125;, &#125;, right: &#123;  val: <span class="hljs-number">0</span>,  left: <span class="hljs-literal">null</span>,  right: <span class="hljs-literal">null</span>, &#125;,&#125;;<span class="hljs-keyword">const</span> num = sumNumbers(root);</code></pre>  </p></details><hr>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git之合并分支</title>
    <link href="/articles/2020/10/28/Git%E4%B9%8B%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/"/>
    <url>/articles/2020/10/28/Git%E4%B9%8B%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h2><p><a href="https://backlog.com/git-tutorial/cn/stepup/stepup1_1.html">原文链接</a></p><p>完成作业后的分支，最后要合并回merge分支。合并分支有2种方法：使用merge或rebase。使用这2种方法，合并后分支的历史记录会有很大的差别。</p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>使用merge可以合并多个历史记录的流程。</p><p>如下图所示，bugfix分支是从master分支分叉出来的。</p><p><img src="/images/bugfix.png" alt="bugfix"></p><p>合并 bugfix分支到master分支时，如果master分支的状态没有被更改过，那么这个合并是非常简单的。 bugfix分支的历史记录包含master分支所有的历史记录，所以通过把master分支的位置移动到bugfix的最新分支上，Git 就会合并。这样的合并被称为fast-forward（快进）合并。</p><p><img src="/images/bugfix1.png" alt="bugfix1"></p><p>但是，master分支的历史记录有可能在bugfix分支分叉出去后有新的更新。这种情况下，要把master分支的修改内容和bugfix分支的修改内容汇合起来。</p><p><img src="/images/bugfix2.png" alt="bugfix2"></p><p>因此，合并两个修改会生成一个提交。这时，master分支的HEAD会移动到该提交上。</p><p><img src="/images/bugfix3.png" alt="bugfix3"></p><p>执行合并时，如果设定了non fast-forward选项，即使在能够fast-forward合并的情况下也会生成新的提交并合并。</p><p><img src="/images/bugfix4.png" alt="bugfix4"></p><p>执行non fast-forward后，分支会维持原状。那么要查明在这个分支里的操作就很容易了。</p><hr><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>跟merge的例子一样，如下图所示，bugfix分支是从master分支分叉出来的。</p><p><img src="/images/rebase.png" alt="rebase"></p><p>如果使用rebase方法进行分支合并，会出现下图所显示的历史记录。现在我们来简单地讲解一下合并的流程吧。</p><p><img src="/images/rebase1.png" alt="rebase1"></p><p>首先，rebase bugfix分支到master分支, bugfix分支的历史记录会添加在master分支的后面。如图所示，历史记录成一条线，相当整洁。</p><p>这时移动提交X和Y有可能会发生冲突，所以需要修改各自的提交时发生冲突的部分。</p><p><img src="/images/rebase3.png" alt="rebase2"></p><p>rebase之后，master的HEAD位置不变。因此，要合并master分支和bugfix分支，即是将master的HEAD移动到bugfix的HEAD这里。</p><p><img src="/images/rebase4.png" alt="rebase3"></p><p>Merge和rebase都是合并历史记录，但是各自的特征不同。</p><ul><li>merge<br>保持修改内容的历史记录，但是历史记录会很复杂。</li><li>rebase<br>历史记录简单，是在原有提交的基础上将差异内容反映进去。<br>因此，可能导致原本的提交内容无法正常运行。</li></ul><hr><p>上述是 merge 跟 rebase 的区别之处，接下来 ，我们通过实践来加深下体会。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="使用-merge-合并分支"><a href="#使用-merge-合并分支" class="headerlink" title="使用 merge 合并分支"></a>使用 merge 合并分支</h3><pre><code>mkdir testcd testgit init</code></pre><p>使用 <code>vscode</code> 打开 test 文件夹后新建文件 <code>index.txt</code> , 输入 文字：</p><pre><code>master分支新建</code></pre><p>然后 git 提交:</p><pre><code>git add index.txtgit commit -m &#39;第一次提交&#39;</code></pre><p>你可以使用 <code>vscode</code> 的git分支图形可视化来观察当前的分支状态</p><p><img src="/images/merge-1.png" alt="merge-vscode"></p><p>目前的历史记录是这样的。</p><h3 id="建立分支"><a href="#建立分支" class="headerlink" title="建立分支"></a>建立分支</h3><p>命令: <code>git branch &lt;branchname&gt;</code></p><p>创建名为dev的分支。</p><p><code>git branch dev</code></p><p>不指定参数直接执行branch命令的话，可以显示分支列表。 前面有*的就是现在的分支。</p><pre><code>  git branch    issue1  * master</code></pre><p>创建分支后,目前的历史记录是这样的：</p><p><img src="/images/merge-2.png" alt="merge-vscode"></p><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>若要在新建的dev分支进行提交，需要切换到dev分支。</p><p>要执行checkout命令以退出分支。</p><p><code>git checkout &lt;branch&gt;</code></p><pre><code>git checkout dev</code></pre><p>创建分支并切换到该分支可以把上面创建和切换两个命令合并为一个：</p><pre><code>git checkout -b &lt;branch&gt;</code></pre><p>在 dev 分支上 修改 index.txt 文件 , 新增内容：</p><pre><code>master分支新建dev分支新建  // 新增内容</code></pre><p>然后提交。</p><p>目前的历史记录是这样的。</p><p><img src="/images/merge-3.png" alt="alt"></p><h3 id="merge-合并分支"><a href="#merge-合并分支" class="headerlink" title="merge 合并分支"></a>merge 合并分支</h3><p>先切换至 <code>master</code>分支:</p><pre><code>git checkout master</code></pre><p>然后执行命令合并dev分支：</p><pre><code>git merge dev</code></pre><p>如图, <code>master</code>分支指向的提交移动到和dev同样的位置。<br>这个是fast-forward（快进）合并。</p><p><img src="/images/merge-4.png" alt="alt"></p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p><code>git branch -d &lt;branch&gt;</code> 命令删除分支 , 现在我要删除 dev ：</p><pre><code>git branch -d dev</code></pre><p>确认是否删除成功：</p><pre><code>git branch* master</code></pre><h3 id="并行操作"><a href="#并行操作" class="headerlink" title="并行操作"></a>并行操作</h3><p>在日常开发中， 我们可能会存在多个分支，多个分支中可能会存在并行的情况， 接下来看看merge后的结果会是怎么样。</p><p>同时创建两个分支，一个 dev 分支， 一个 bugfix 分支：</p><pre><code>git branch devgit branch bugfix</code></pre><p>现在是这个样子：</p><p><img src="/images/more-merger.png" alt="alt"></p><p>假设我们现在 切换到 dev 上我们进行开发，在 index.txt 文件上新增内容并提交。</p><p>这个时候 分支变成这个样子：<br><img src="/images/more-dev.png" alt="alt"></p><p>然后我们再切换到 bugfix 分支 ，进行一些代码的修改， 并且文件还是 index.txt。</p><p>这个时候 分支变成这个样子：<br><img src="/images/more-bugfix.png" alt="alt"></p><p>现在 dev 跟 bugfix 分支的操作就并行进行了。</p><h3 id="解决合并的冲突"><a href="#解决合并的冲突" class="headerlink" title="解决合并的冲突"></a>解决合并的冲突</h3><p>  现在我们把 dev 跟 bugfix 分支 合并入master去。<br>  切换到 master 分支， merge dev分支。</p><pre><code>git checkout mastergit merge dev</code></pre><p>执行fast-forward（快进）合并。</p><p><img src="/images/dev-1.png" alt="alt"></p><p>接着再合并 bugfix :</p><pre><code>git merge bugfix</code></pre><p>在 dev 上 和 bugfix 上 我们都修改了 index.txt 文件， 那么冲突就此产生了。</p><p><img src="/images/bugfix-1.png" alt="alt"></p><p>解决冲突，重新提交代码(这里选择了保留两个的输入)：</p><p>  git add index.txt<br>  git commit -m ‘解决冲突’</p><p>历史记录如下图所示。因为在这次合并中修改了冲突部分，所以会重新创建合并修改的提交记录。这样，master的HEAD就移动到这里了。这种合并不是fast-forward合并，而是non fast-forward合并。</p><p><img src="/images/dev-2.png" alt="alt"></p><p>至此 ，merge 讲解结束了。</p><hr><h3 id="rebase-合并分支"><a href="#rebase-合并分支" class="headerlink" title="rebase 合并分支"></a>rebase 合并分支</h3><p>我们在master 合并完dev分支的时候， 使用 rebase 来合并 bugfix 分支，看看会有什么样的效果。</p><p>使用命令 回退刚刚我们合并 bugfix 的历史记录， 让 master 回归到合并dev的记录那时候：</p><pre><code>git reset --hard HEAD~ </code></pre><p>回退后， 我们首先要切换到 bugfix 分支去。<br>对master执行rebase。</p><pre><code>git checkout bugfixgit rebase master</code></pre><p>和merge时的操作相同，修改在 index.txt 发生冲突的部分。<br>冲突解决完毕之后， 重新提交我们刚刚所修改的文件。</p><pre><code>git add index.txt</code></pre><p>rebase的时候，修改冲突后的提交不是使用commit命令，而是执行rebase命令指定 –continue选项。若要取消rebase，指定 –abort选项。</p><pre><code>git rebase --continue</code></pre><p>如图，历史记录很干净了。</p><p><img src="/images/bugfix001.png" alt="alt"></p><p>这样，在master分支的bugfix分支就可以fast-forward合并了。切换到master分支后执行合并。</p><pre><code>git checkout mastergit merge bugfix</code></pre><p>这就是 rebase 结合 merge 使 分支历史记录变得很干净了。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git 学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git之修改commit的message</title>
    <link href="/articles/2020/10/28/Git%E4%B9%8B%E4%BF%AE%E6%94%B9commit%E7%9A%84message/"/>
    <url>/articles/2020/10/28/Git%E4%B9%8B%E4%BF%AE%E6%94%B9commit%E7%9A%84message/</url>
    
    <content type="html"><![CDATA[<h2 id="修改commit-message"><a href="#修改commit-message" class="headerlink" title="修改commit message"></a>修改commit message</h2><p>上面我们讲的是如何在自己的分支 净化 commit 提交记录， 接下来 讲讲如何 利用 <code>rebase</code> 修改 commit message 的信息。</p><h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>在使用git提交代码的时候，可能会出现message写错的情况，<br>如果此时commit已经push到远程服务器了，<br>修改起来就比较麻烦了。</p><p><strong>注</strong>：<br>在修复历史commit message的时候，请确保当前分支是最新代码，<br>且已经提交了所有本地修改。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="查看历史，确定要修改的提交"><a href="#查看历史，确定要修改的提交" class="headerlink" title="查看历史，确定要修改的提交"></a>查看历史，确定要修改的提交</h4><p>首先你要先确定你要修改的提交 commit id , 这个我们可以使用 <code>git log --oneline</code> 打印查看。</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>使用<code>git rebase -i HEAD~5</code>确定要修改哪些commit</p><p>跟上篇文章 《Git之多个commit合并.md》 其实一样的步骤。</p><p>但是 需要把 之前的 <code>squash</code> 更改为 <code>edit</code></p><p>假设现在你要更改最近的 5次提交message ， 那么在这最近5次的 pick 更改 为 edit , 然后保存退出后， 你会注意到 git 分支会变成 第一个edit的 commit id, 例如：</p><pre><code>test-rebase git:(master) &gt; // 这个是之前在mastertest-rebase git:(f429786) &gt;  // 保存后会变成 commit id</code></pre><p>然后在这个 id 下 ，我们输入命令： <code>git commit --amend</code><br>回车后会进入 vim 模式就可以修改了。</p><p>修改保存之后， 再次在命令行输入: <code>git rebase --continue</code></p><p>命令执行完 git 分支会进入第二个（如果有的话）, 重复上面的操作：</p><ul><li>先用git commit –amend修改message，然后保存，</li><li>再执行，git rebase –continue。</li></ul><p>我们标记了几个edit，这个过程就需要重复执行几次。<br>全部修改完成后，会提示，</p><pre><code>Successfully rebased and updated refs/heads/master.</code></pre><h4 id="使用git-push-f强制更新远程服务器"><a href="#使用git-push-f强制更新远程服务器" class="headerlink" title="使用git push -f强制更新远程服务器"></a>使用git push -f强制更新远程服务器</h4><pre><code>git push -f</code></pre><p>切记一定要加<code>-f</code>，否则我们edit的commit会添加到commit后面，<br>而不是更新原commit。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git 学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git之多个commit合并</title>
    <link href="/articles/2020/10/28/Git%E4%B9%8B%E5%A4%9A%E4%B8%AAcommit%E5%90%88%E5%B9%B6/"/>
    <url>/articles/2020/10/28/Git%E4%B9%8B%E5%A4%9A%E4%B8%AAcommit%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="净化-commit-提交"><a href="#净化-commit-提交" class="headerlink" title="净化 commit 提交"></a>净化 commit 提交</h2><p>把多次的 commit 合并成一个commit 记录。</p><h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>有时候我们修改一个 <code>Bug</code> 或者一段代码的时候， <code>commit</code> 一次之后，发现 <code>Bug</code> 没改对或者这段代码需要再优化之类的，改完之后又 <code>commit</code> 了一次或多次，这样就会感觉提交历史不太美观（有点强迫症），这个时候我们就希望只想保留一次提交历史记录，合并为一个完整的提交，该怎么办呢？<code>git rebase</code> 应运而生！</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="查看历史，确定要合并的提交"><a href="#查看历史，确定要合并的提交" class="headerlink" title="查看历史，确定要合并的提交"></a>查看历史，确定要合并的提交</h4><p>首先你要先确定你要修改的提交 <code>commit id</code> , 这个我们可以使用 <code>git log --oneline</code> 打印查看。</p><blockquote><p>注意： 不要合并其他人的提交</p></blockquote><h4 id="命令合并"><a href="#命令合并" class="headerlink" title="命令合并"></a>命令合并</h4><p>命令行输入：<code>git rebase -i HEAD~6</code> 或者 <code>git rebase -i ***</code></p><blockquote><p><code>***</code> 指的是你的某个提交 <code>commit id</code><br><strong>注意:</strong> 这个<code>commit id</code> 不包含在内<br><code>HEAD~6</code> 指的是最近的 6 次提交 , 这个数字 6 代表几次， 如下图 ，我是修改前3次，所以是 3</p></blockquote><p>输入 以上命令后,命令行输出如下图内容:</p><p><img src="/images/rebase-one.png" alt="内容输出"></p><p>键盘 i 进入 vim 编辑模式, 把 除了第一个 <code>commit message</code> 之外的 <code>pick</code> 修改为 <code>squash</code> or <code>s</code> , 然后 esc 退出 vim 编辑模式后键盘输入 <code>:wq</code> or <code>x</code> 保存退出，如下图：</p><p><img src="/images/rebase2.png" alt="s"></p><p>这里说明下， 为什么除了第一个不用改 是因为要把下面的两次 commit 合并到第一个 commit 去。</p><ul><li><code>pick</code> 的意思是要执行这个 commit</li><li><code>squash</code> 的意思是这个 commit 会被合并到前一个 commit</li></ul><h4 id="中间可能会出现的情况"><a href="#中间可能会出现的情况" class="headerlink" title="中间可能会出现的情况"></a>中间可能会出现的情况</h4><p>git 会压缩提交历史，若有冲突，需要进行修改，修改的时候保留最新的历史记录，修改完之后输入以下命令：</p><pre><code>git add .git rebase --continue</code></pre><p>若想退出放弃此次压缩，执行命令：</p><pre><code>git rebase --abort</code></pre><p>若无冲突 or 冲突已 fix，则会出现一个 <code>commit message</code> 编辑页面，修改 <code>commit message</code> ，然后 输入<code>:wq</code> or <code>x</code> 保存退出。</p><h4 id="同步到远程-git-仓库"><a href="#同步到远程-git-仓库" class="headerlink" title="同步到远程 git 仓库"></a>同步到远程 git 仓库</h4><p>输入：<code>git push -f</code> or <code>git push --force</code></p><p>查看远程仓库效果，多次 commit 已被合并成一次 commit。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git 学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的前序遍历</title>
    <link href="/articles/2020/10/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/articles/2020/10/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是二叉树前序遍历"><a href="#什么是二叉树前序遍历" class="headerlink" title="什么是二叉树前序遍历"></a>什么是二叉树前序遍历</h2><p><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="二叉树前序遍历"></p><p>前序遍历：1  2  4  5  7  8  3  6</p><p>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</p><blockquote><p>前序遍历:<br>是二叉树遍历的一种， 也叫做 先根遍历 、先序遍历、前序周游，可记做根左右。前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。<br>前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。<br>若二叉树为空则结束返回，否则：<br>（1）访问根结点。<br>（2）前序遍历左子树。<br>（3）前序遍历右子树 。<br>需要注意的是：遍历左右子树时仍然采用前序遍历方法。<br>如上图所示二叉树<br>前序遍历结果：12457836</p></blockquote><h2 id="题目：-二叉树的前序遍历"><a href="#题目：-二叉树的前序遍历" class="headerlink" title="题目： 二叉树的前序遍历"></a>题目： 二叉树的前序遍历</h2><p>给定一个二叉树，返回它的 前序 遍历。</p><p>示例 1：</p><pre><code class="hljs javascript">输入: [<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-number">1</span>  \  <span class="hljs-number">2</span>  /<span class="hljs-number">3</span>;输出: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</code></pre><details>  <summary>    <b>答案</b>  </summary>  <p>  递归解题法：    preOrder 函数将根节点 root 的val值加入数组，然后递归调用自身 获取left 跟 right 的 val值 , 递归止于 节点为null的时候。<pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><span class="hljs-comment"> * this.val = (val===undefined ? 0 : val)</span><span class="hljs-comment"> * this.left = (left===undefined ? null : left)</span><span class="hljs-comment"> * this.right = (right===undefined ? null : right)</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> preorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123; <span class="hljs-keyword">const</span> res = []; <span class="hljs-keyword">const</span> preOrder = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;  res.push(root.val);  preOrder(root.left);  preOrder(root.right); &#125;; preOrder(root); <span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-keyword">const</span> root = &#123; val: <span class="hljs-number">1</span>, left: <span class="hljs-literal">null</span>, right: &#123;  val: <span class="hljs-number">2</span>,  left: &#123; <span class="hljs-attr">val</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">left</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">right</span>: <span class="hljs-literal">null</span> &#125;,  right: <span class="hljs-literal">null</span>, &#125;,&#125;;<span class="hljs-keyword">const</span> res = preorderTraversal(root);</code></pre><p>迭代解题法：<br>维护一个栈 stack，模拟递归的压栈出栈。<br>遍历 获取 val 值 ，把 right 节点 压入 stack 栈内 ， 把 left 节点 赋值 给 根节点 root<br>进入第二次遍历，判断栈 stack 是否有值，如果有 把 栈内的数据 pop 出来，赋值 给 root，并获取 root 的 val，<br>把 left 节点 赋值 给 root ，进入第三次遍历， 重复 第一次 遍历所做的事情</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><span class="hljs-comment"> * this.val = (val===undefined ? 0 : val)</span><span class="hljs-comment"> * this.left = (left===undefined ? null : left)</span><span class="hljs-comment"> * this.right = (right===undefined ? null : right)</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> preorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123; <span class="hljs-keyword">const</span> res = []; <span class="hljs-keyword">let</span> stack = []; <span class="hljs-keyword">while</span> (root) &#123;  res.push(root.val);  <span class="hljs-keyword">if</span> (root.right) stack.push(root.right);  root = root.left; &#125; <span class="hljs-keyword">while</span> (stack.length) &#123;  root = stack.pop();  res.push(root.val);  <span class="hljs-keyword">if</span> (root.right) stack.push(root.right);  root = root.left;  <span class="hljs-keyword">while</span> (root) &#123;   res.push(root.val);   <span class="hljs-keyword">if</span> (root.right) stack.push(root.right);   root = root.left;  &#125; &#125; <span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-keyword">const</span> root = &#123; val: <span class="hljs-number">1</span>, left: <span class="hljs-literal">null</span>, right: &#123;  val: <span class="hljs-number">2</span>,  left: &#123; <span class="hljs-attr">val</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">left</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">right</span>: <span class="hljs-literal">null</span> &#125;,  right: <span class="hljs-literal">null</span>, &#125;,&#125;;<span class="hljs-keyword">const</span> res = preorderTraversal(root);</code></pre>  </p></details><hr>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 自动部署</title>
    <link href="/articles/2020/09/02/Hexo-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <url>/articles/2020/09/02/Hexo-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近 Git Pages 好像因为被墙的原因导致网速感人，遂决定重新部署个人博客到阿里云服务器，因为菜所以磕磕碰碰 ， 记录下 ，为以后健忘症的我埋下点东西，以后方便查阅。</p><h2 id="物料准备"><a href="#物料准备" class="headerlink" title="物料准备"></a>物料准备</h2><ul><li><p>一台服务器。（作者使用的是阿里云服务器）</p></li><li><p>一台电脑。（作者使用的是 Mac Pro）</p></li><li><p>带上耳机开始撸。</p></li></ul><h2 id="什么是-Hexo"><a href="#什么是-Hexo" class="headerlink" title="什么是 Hexo"></a>什么是 Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。</p><p>Hexo 使用 Markdown 解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>它的官网地址是： <a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p><h2 id="搭建本地-Hexo-环境"><a href="#搭建本地-Hexo-环境" class="headerlink" title="搭建本地 Hexo 环境"></a>搭建本地 Hexo 环境</h2><p>安装 Node：<br>进入 Node 官网下载安装，各位小伙伴这个我就不细说了吧。</p><p>Npm：<br>只要你安装了 Node ，那么 npm 也会安装好的。</p><p>验证是否安装成功，打开终端输入：</p><pre><code class="hljs bash">node --versionnpm --version</code></pre><p>如果命令行有输出版本那么恭喜小伙伴安装成功，如果输出了：</p><pre><code class="hljs bash"><span class="hljs-built_in">command</span> not found: node<span class="hljs-built_in">command</span> not found: npm</code></pre><p>可能是环境没变量没有配置好 或者安装出了问题，因为这不是本文重点所以请各位小伙伴自行搜索解决，实在不行可以私聊作者协助解决。</p><p>安装<code>git</code>（mac 系统自带 <code>git</code> ，所以不需要安装）:<br>进入<code>Git</code>官网下载安装，这个我也不细说了。<br>完成安装后，进入<code>Hexo</code>官网查看安装命令。</p><pre><code class="hljs bash">npm install hexo-cli -g</code></pre><p>意思就是要我们全局安装 <code>hexo-cli</code> ， 终端执行安装。<br>当然你不想全局安装 <code>hexo</code>文档也有局部安装，具体查看<code>Hexo</code>文档。<br>安装好<code>hexo</code>脚手架之后，我们利用它来初始化一个项目。</p><pre><code class="hljs bash">hexo init &lt;文件夹名称&gt;</code></pre><p>等<code>hexo</code>初始化好项目之后，我们使用<code>vscode</code>打开项目，在根目录下打开终端执行：</p><pre><code class="hljs bash">npm install</code></pre><p>安装好项目的各种依赖之后呢，就可以预览我们的项目了，执行：</p><pre><code class="hljs bash">hexo s</code></pre><p>到这里，我们本地的环境 已经搭建完毕并且也准备了一个项目。</p><h2 id="搭建服务器环境"><a href="#搭建服务器环境" class="headerlink" title="搭建服务器环境"></a>搭建服务器环境</h2><p>作者这里使用的是阿里云服务器，本地<code>ssh</code> 远程登录到阿里云服务器之后，安装以下软件：</p><ol><li>Nginx</li><li>Git</li></ol><p>那么我们先来安装 Git：</p><pre><code class="hljs bash">yum install git</code></pre><p>安装之后 ，命令 <code>git --version</code> 检查是否安装成功。<br>接下来创建 <code>git</code> 用户， 注意 这里是创建 系统用户， 名字叫 <code>git</code> ，当然 你也可以取其他的名称，创建这个用户主要是用来 实现自动化部署的， 虽然服务器就只有我一个人使用好像多此一举，但是 装逼下没啥大问题。</p><pre><code class="hljs bash">sudo adduser git</code></pre><p>我们现在创建了一个 git 用户， 接下来的操作都跟它有关， 但是到目前为止我们先不管它，当然你也可以先跳过这一步骤。<br>接着往下， 我们的博客文件肯定需要有个地方来存放没毛病吧，作者选择在 <code>/home</code> 目录下创建存放博客的目录，地址为 <code>/home/www/hexo</code> 。</p><pre><code class="hljs bash">mkdir -p /home/www/hexo</code></pre><h2 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h2><p>注：以下步骤都在 服务器上操作的哦。</p><p>准备好这些之后，我们要搞点复杂的东西了，安装配置<code>nginx</code>：<br>安装 EPEL 源：</p><pre><code class="hljs bash">sudo yum install -y epel-release</code></pre><p>更新 yum：</p><pre><code class="hljs bash">sudo yum -y update</code></pre><p>接着安装 Nginx：</p><pre><code class="hljs bash">sudo yum install -y nginx</code></pre><p>安装成功后，默认的网站目录为：<code>/usr/share/nginx/html</code></p><p>默认的配置文件为：<code>/etc/nginx/nginx.conf</code></p><p>自定义配置文件目录为: <code>/etc/nginx/conf.d/</code></p><p>如果你的服务器打开了防火墙，你需要运行下面的命令，打开 80 和 443 端口。</p><pre><code class="hljs bash">sudo firewall-cmd --permanent --zone=public --add-service=httpsudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload</code></pre><p>启动 Nginx：</p><pre><code class="hljs bash">systemctl start nginx</code></pre><p>开机启动 Nginx：</p><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> nginx</code></pre><p>校验 Nginx 是否安装成功，你可以打开你的公网地址进行访问，看看能否访问到 nginx 的默认网页，如果不行 ，抱歉 ，自行搜下解决办法 或者联系作者协助安装。</p><h2 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h2><p>作者还配置了<code>https</code> ， 所以这里再讲一下如何配置免费的 <code>https</code> 。</p><p>安装<code>Https</code>免费证书(以阿里云域名为例)</p><p>一键安装 acme.sh：</p><pre><code class="hljs bash">curl https://get.acme.sh | sh <span class="hljs-comment"># 安装</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;alias acme.sh=~/.acme.sh/acme.sh&#x27;</span> &gt;&gt; ~/.bashrc <span class="hljs-comment"># 环境变量</span><span class="hljs-built_in">source</span> ~/.bashrc <span class="hljs-comment"># 更新生效配置</span></code></pre><p>生成 Https 证书：</p><pre><code class="hljs bash"><span class="hljs-built_in">export</span> Ali_Key=<span class="hljs-string">&quot;**********&quot;</span>  <span class="hljs-comment"># 在阿里云 AccessKey 管理页面获取</span><span class="hljs-built_in">export</span> Ali_Secret=<span class="hljs-string">&quot;**********&quot;</span>  <span class="hljs-comment"># 在阿里云 AccessKey 管理页面获取</span>acme.sh --issue --dns dns_ali -d domain <span class="hljs-comment"># domain 是你的域名，没有d的话使用公网ip就可以</span></code></pre><p>关于 <code>Ali_key</code> 和 <code>Ali_Secret</code> 的获取：</p><p>点击阿里云后台，右上角用户头像，菜单中选择<code>accesskeys</code>。<br>查看<code>AccessKey ID</code> 和 <code>Access Key Secret</code>，即对应上面的<code>Ali_Key</code> 和 <code>Ali_Secret</code>。</p><p><code>domain</code> 对应该账户下购买的阿里云域名。</p><p>拷贝证书到 nginx：</p><pre><code class="hljs bash">mkdir -p /etc/nginx/ssl <span class="hljs-comment"># 先创建 ssl 文件夹用来存放 https 的 key 等文件</span><span class="hljs-comment"># domain 是你的域名 没有的话使用 ip 也可以</span>acme.sh --install-cert -d domain \--key-file       /etc/nginx/ssl/domain.key  \--fullchain-file /etc/nginx/ssl/domain.cer \--reloadcmd     <span class="hljs-string">&quot;service nginx force-reload&quot;</span></code></pre><p>https 证书拷贝是否成功 ， 可以进入 <code>/etc/nginx/ssl</code> 文件夹 查看是否有文件存在 。</p><p>目前 https 证书在 60 天以后会自动更新, 你无需任何操作. 今后有可能会缩短这个时间, 不过都是自动的, 你不用关心.</p><p>接着 删除或者注释 <code>/etc/nginx/nginx.conf</code> 中的<code>server</code>部分代码。</p><p>然后在 <code>/etc/nginx/conf.d</code> 创建自定义配置文件 <code>default.conf</code> ，写入以下内容：</p><pre><code class="hljs bash">server &#123;    listen 80;    listen 443 ssl;    server_name  chalicelee.xin www.chalicelee.xin; <span class="hljs-comment"># 改成 你自己的域名</span>​    location / &#123;        root   /home/www/hexo; <span class="hljs-comment"># 如果你的存放地址跟我一致则不需要改动</span>        index  index.html index.htm;    &#125;​    ssl on;    ssl_certificate /etc/nginx/ssl/chalicelee.xin.cer; <span class="hljs-comment"># https 的 cer 文件</span>    ssl_certificate_key /etc/nginx/ssl/chalicelee.xin.key; <span class="hljs-comment"># https 的 key 文件</span>    ssl_session_timeout  5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE;    ssl_prefer_server_ciphers  on;​    error_page 497  https://<span class="hljs-variable">$host</span><span class="hljs-variable">$uri</span>?<span class="hljs-variable">$args</span>; <span class="hljs-comment"># 强制http跳转到https</span>&#125;</code></pre><p>至此 ， Nginx 配置完毕，接下来我们要部署我们的 hexo 博客了。</p><h2 id="配置-git-用户"><a href="#配置-git-用户" class="headerlink" title="配置 git 用户"></a>配置 git 用户</h2><p>还记得前面我们创建了一个系统用户 git 吧 ， 接下来我们要配置下它：</p><p>修改 git 用户的权限：</p><pre><code class="hljs bash">chmod 740 /etc/sudoers</code></pre><p>然后打开文件 ： <code>/etc/sudoers</code> ， 增加 git 用户 。</p><p><img src="/images/WX20200901-162034.png" alt="git"></p><p>修改后记得把权限改回来哦。</p><pre><code class="hljs bash">chmod 400 /etc/sudoers</code></pre><p>设置 git 用户密码 （可选）</p><pre><code class="hljs bash">sudo passwd git</code></pre><p>然后在终端输入你的密码。</p><p>至此 完成了 Git 用户的创建，接下来我们向 Git 用户添加公钥，就像配置 Github 那样。</p><h2 id="配置-ssh-公钥"><a href="#配置-ssh-公钥" class="headerlink" title="配置 ssh 公钥"></a>配置 ssh 公钥</h2><p>我们拉取代码的时候有配置过仓库的 ssh 实现免密码登录即可拉取仓库代码的经历吧，这一步其实是一样的原理。</p><p>总体思路：</p><ol><li><p>先在你本地生成 密钥对 。</p></li><li><p>然后把生成的公钥上传到服务器。</p></li><li><p>把上传的公钥内容 copy 到 authorized_keys 文件中。</p></li></ol><p>接下来我们开始吧。</p><p>本地生成密钥对</p><p>各位小伙伴注意：这一步操作是在本地 进行的哦。</p><p>本地打开你的终端 ， 输入命令：</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ～ <span class="hljs-comment"># 进入根目录</span><span class="hljs-built_in">cd</span> .ssh <span class="hljs-comment"># 进入 .ssh 目录</span>ssh-keygen <span class="hljs-comment"># 生成密钥对</span></code></pre><p>相信如果有配置过 ssh 的同学 ，都应该会有 <code>.ssh</code> 目录存在 ，它是个隐藏目录 ，所以想要发现它 ，必须 加入 <code>ls -a</code> 。</p><p>如果你发现你没有这个目录，也别紧张 ，新建<code>.ssh</code>目录就好了。</p><p>密钥对生成之后 为私钥设置权限：</p><pre><code class="hljs bash">chmod 700 ~/.sshchmod 600 ~/.ssh/id_rsa</code></pre><p>至此 ，密钥对生成完毕。</p><p>上传公钥至服务器</p><p>各位小伙伴注意：这一步是在服务器 终端操作的。</p><p>mac 可以使用 <code>scp</code> 命令 上传服务器，各位小伙伴实在觉得这一步有点麻烦，那么可以试一下本地打开 <code>.ssh</code> 目录下的 <code>id_rsa.pub</code> 文件 ， 把它的内容 <code>copy</code> 过来，然后 阿里云远程登录到服务器，然后 切换到 git 用户。</p><pre><code class="hljs bash">su git <span class="hljs-comment"># 切换到git 用户</span><span class="hljs-built_in">cd</span> ~ <span class="hljs-comment"># 进入根目录</span>mkdir .ssh  <span class="hljs-comment"># 如果没有这个文件夹则创建 如果有则忽略这个命令</span></code></pre><p>创建好 <code>.ssh</code> 文件夹后 ，进入到这个文件夹 ， 创建 <code>authorized_keys</code> 文件 ，并把 刚刚你<code>copy</code>的公钥内容粘贴进去保存。</p><p>然后修改 文件权限：</p><pre><code class="hljs bash">chmod 600 ~/.ssh/authorized_keyschmod 700 ~/.ssh</code></pre><p>重启服务器 ，然后本地试下 ssh 连接是否能够成功。</p><pre><code class="hljs bash">ssh -v git@xxx.xxx.xxx.xxx（你的公网 IP）</code></pre><p>注意：因为作者 是使用了 <code>git</code> 名称 ，所以这里连接的时候也是 <code>git</code> ，假如你的是别的名称， 应该换成对应的。</p><p>如果上述操作失败，那么各位小伙伴就要根据对应的操作系统来把 本地生成的公钥 上传到 服务器 然后在服务器<code>copy</code>公钥的内容到 <code>authorized_keys</code> 文件内。</p><p>但是讲道理应该是可以成功的。</p><p>哈哈，感觉很不负责任的话。</p><p>好了，至此 如果你能够通过 ssh 本地连接远程的 git 用户了 ， 那么服务端公钥的配置也结束了。</p><h2 id="服务器配置-git-仓库"><a href="#服务器配置-git-仓库" class="headerlink" title="服务器配置 git 仓库"></a>服务器配置 git 仓库</h2><p>各位小伙伴注意，以下操作为服务器操作 ， 并且不是 <code>root</code> 用户 而是 <code>git</code> 用户哦。</p><p>通过前面的步骤，我们已经可以通过本地 <code>ssh</code> 连接到我们的服务器 <code>git</code> 用户， 那么接着我们使用<code>git</code>用户配置我们的<code>git</code>仓库吧。（好怪，有点后悔随大众 取名 为 <code>git</code> 了。）</p><p>登录服务器，进行操作：</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~ <span class="hljs-comment"># 进入根目录</span>git init --bare hexo.git  <span class="hljs-comment"># 初始化git裸仓库</span></code></pre><p>详细说一下使用 <code>--bare</code> 参数的含义，使用 <code>--bare</code> 参数初始化的仓库，我们一般称之为裸仓库， 因为这样创建的仓库并不包含 工作区 ， 也就是说，我们并不能在这个目录下执行我们一般使用的 Git 命令。</p><p>接着我们 创建并 写入 post-receive 钩子文件：</p><pre><code class="hljs bash">vi ~/hexo.git/hooks/post-receive</code></pre><p>写入内容如下：</p><pre><code class="hljs bash">git --work-tree=/home/www/hexo --git-dir=/home/git/hexo.git checkout -f</code></pre><p>注意 文件的地址要保持一致哦。</p><p>授予钩子文件可执行权限。</p><pre><code class="hljs bash">chmod +x ~/hexo.git/hooks/post-receive<span class="hljs-built_in">cd</span> ~sudo chmod -R 777 /home/www/hexo</code></pre><p>重启服务器实例。<br>至此，我们就完成了服务端的配置</p><h2 id="项目中的配置"><a href="#项目中的配置" class="headerlink" title="项目中的配置"></a>项目中的配置</h2><p>哟吼，配置接近尾声 ， 不激动， 慢慢来。</p><p>注意： 这一步骤的所有操作都在本地 刚刚我们初始化的 项目中。</p><p>打开我们刚刚初始化的项目， 然后 打开 hexo 的 配置文件： _config.yml ：</p><pre><code class="hljs bash"><span class="hljs-comment"># Deployment</span><span class="hljs-comment">## 修改 这个字段 repo 是你的 服务器 存放目录</span>deploy:  <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;git&#x27;</span>  repo: <span class="hljs-string">&#x27;git@47.102.126.177:/home/git/hexo.git&#x27;</span>  branch: <span class="hljs-string">&#x27;master&#x27;</span></code></pre><p>哦 ， 除了这里之外 ，还需要配置 url 字段:</p><pre><code class="hljs bash"><span class="hljs-comment"># URL</span><span class="hljs-comment">##  填写你的域名 或者 公网 ip</span>url: http://chalicelee.xin</code></pre><h2 id="Hexo-自动部署"><a href="#Hexo-自动部署" class="headerlink" title="Hexo 自动部署"></a>Hexo 自动部署</h2><p>以上步骤完成 ，我们就来测试下是否成功部署，打开我们初始化的项目，根目录打开终端，输入命令：</p><pre><code class="hljs bash">hexo new 文章名称</code></pre><p>这样我们的<code>source</code>文件夹下的 <code>_posts</code> 文件夹下会自动生成 <code>文章名称.md</code> 。<br>我们随便写点东西吧。</p><p>写完之后 ，我们终端执行命令：</p><pre><code class="hljs bash">hexo clhexo ghexo d</code></pre><p>一个命令一个命令执行后 ， 我们打开我们的域名或者 ip ，看看能否访问到我们初始化的博客页面， 看看我们新增的文章是否有显示吧。</p><p>如果有， 恭喜你， 自动部署已经成功，之后我们写文章 ，就可以直接在本地写完之后， 通过上述三个 hexo 命令 ，就可以发布到我们的服务器上了。</p><h2 id="配置-hexo-主题"><a href="#配置-hexo-主题" class="headerlink" title="配置 hexo 主题"></a>配置 hexo 主题</h2><p>默认的主题好像不太喜欢。</p><p>没关系 ，我们可以换一个， 打开 hexo 官网， 找到主题， 直接选择一个自己喜欢的点击进入 github ，然后下载下来在 放到我们的 themes 目录下，然后配置下 _config.yml ：</p><pre><code class="hljs bash"><span class="hljs-comment"># Extensions</span><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><span class="hljs-comment">## Themes: https://hexo.io/themes/</span>theme: fluid  <span class="hljs-comment"># 这个 fluid 就是主题名称 一般是你下载的主题文件夹名称 具体看主题文档 写入</span></code></pre><p>更多的主题配置 你可以查看你所下载的主题文档， 或者 去 hexo 文档查看配置。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述配置看起来复杂其实还算是很简单的，整体流程下来也没有遇到什么坑，但是有一点疑惑的是 nginx 配置代理后 ，网页打开 url 后 会多了个 /? 的问题，不知道怎么回事，懂的大佬请赐教。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue.config配置</title>
    <link href="/articles/2020/09/01/vue-config%E9%85%8D%E7%BD%AE/"/>
    <url>/articles/2020/09/01/vue-config%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="代码规范配置"><a href="#代码规范配置" class="headerlink" title="代码规范配置"></a>代码规范配置</h2><p>使用 vue created 命令搭建一个基本的架子出来 , 把 vuex router 等都勾选上.</p><p>接下来打开项目开始进行配置:</p><p>我们先来配置一下这个代码规范的问题，在这里我们需要使用到的工具有:vetur，eslint，prettier，首先我们要在项目中安装一个包：@vue/prettier</p><pre><code class="hljs bash">yarn add -D @vue/eslint-config-prettier</code></pre><p>安装好之后，在 .eslintrc.js 给它加上：</p><pre><code class="hljs javascript"><span class="hljs-string">&quot;extends&quot;</span>: [  <span class="hljs-string">&quot;plugin:vue/essential&quot;</span>,  <span class="hljs-string">&quot;eslint:recommended&quot;</span>,  <span class="hljs-string">&quot;@vue/prettier&quot;</span>],</code></pre><p>现在我们执行 npm run lint 的时候，可以看到 eslint 已经帮我们启动了代码规范， 但是很多东西都不能按照我们的想法来执行的，这个时候我们还需要做一些配置：</p><p>在项目的根目录下创建一个.prettierrc.js 文件，然后在其中加入：</p><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123; semi: <span class="hljs-literal">false</span>, <span class="hljs-comment">//行位是否使用分号，默认为true</span> singleQuote: <span class="hljs-literal">true</span>, <span class="hljs-comment">//  是否使用单引号</span> <span class="hljs-comment">// bracketSpacing: true, //对象大括号直接是否有空格，默认为true，效果：&#123; foo: bar &#125;</span> <span class="hljs-comment">// &quot;printWidth&quot;: 80, //一行的字符数，如果超过会进行换行，默认为80</span> <span class="hljs-comment">// &quot;tabWidth&quot;: 2, //一个tab代表几个空格数，默认为80</span> <span class="hljs-comment">// &quot;useTabs&quot;: false, //是否使用tab进行缩进，默认为false，表示用空格进行缩减</span> <span class="hljs-comment">// &quot;trailingComma&quot;: &quot;none&quot;, //是否使用尾逗号，有三个可选值&quot;&lt;none|es5|all&gt;&quot;</span> <span class="hljs-comment">// parser: &quot;babylon&quot; //代码的解析引擎，默认为babylon，与babel相同。</span>&#125;;</code></pre><p>到了这里，即时有上千个 VUE 文件，我们也可以通过 npm run lint 处理我们的错误规范代码</p><p>配置到这里我们已经可以实现代码规范了， 但是为了能够在 vscode 编辑器看到我们的错误规范，我们还需要装一个插件，这个插件就叫 Eslint。</p><p>安装好 eslint 后，因为 eslint 并不认识我们 vue 文件里面包含了 js 语法，所以我们还需要打开我们的 vscode 配置文件，这里的配置只是配置我们个人的文件，并没有达到团队的配置效果，所以我们要在项目中创建一个.vscode 文件夹，但是这里需要注意一个问题：.vscode 这个文件夹在.gitignore 文件里面，所以千万要记得把.vscode 删除</p><p>做好上面的一步之后，在.vscode 里面创建文件 settings.json 文件，添加如下代码：</p><pre><code class="hljs json">&#123; <span class="hljs-attr">&quot;eslint.autoFixOnSave&quot;</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">&quot;eslint.validate&quot;</span>: [  <span class="hljs-string">&quot;javascript&quot;</span>,  <span class="hljs-string">&quot;javascriptreact&quot;</span>,  &#123;   <span class="hljs-attr">&quot;language&quot;</span>: <span class="hljs-string">&quot;vue&quot;</span>,   <span class="hljs-attr">&quot;autoFix&quot;</span>: <span class="hljs-literal">true</span>  &#125; ]&#125;</code></pre><p>上面的配置就是在保存的时候校验并修改我们的代码，它会自动帮我们整理代码规范</p><p>配置到这里其实已经结束了，但是因为我们安装了很多插件，例如 Prettier ， 因为我们不只开发 vue 项目，可能还有其它类型的 js 项目特别是传统 js 项目，需要用到 prettier 进行美化，而 prettier 的一些功能是会和 eslint 相冲突的，比如说我们在全局设置了 prettier 的 formatOnSave，这个功能就会和 eslint 的 autoFixOnSave 打架，为了避免这个矛盾，我们通常还会在本项目的 settings.json 文件里再多加几个选项，类似于这样：</p><pre><code class="hljs json">&quot;editor.tabSize&quot;: 2,&quot;editor.formatOnSave&quot;: false,&quot;prettier.semi&quot;: false,&quot;prettier.singleQuote&quot;: true</code></pre><p>有了这些设置，基本上 prettier 就不会和 eslint 打架了。</p><h2 id="配置-git-hook-以及提交规范"><a href="#配置-git-hook-以及提交规范" class="headerlink" title="配置 git hook 以及提交规范"></a>配置 git hook 以及提交规范</h2><p>项目级安装:</p><p>如果想要在全局安装, 可以看这篇<a href="https://juejin.im/post/5afc5242f265da0b7f44bee4">文章</a></p><pre><code class="hljs bash">npm install -D commitizen cz-conventional-changelog</code></pre><p>然后在 package.json 中配置:</p><pre><code class="hljs json">&quot;script&quot;: &#123;&quot;commit&quot;: &quot;git-cz&quot;,&#125;,&quot;config&quot;: &#123;    &quot;commitizen&quot;: &#123;        &quot;path&quot;: &quot;node_modules/cz-conventional-changelog&quot;    &#125;&#125;</code></pre><p>如果全局安装过 commitizen, 那么在对应的项目中执行 git cz 或者 npm run commit 都可以。</p><p>注意： 如果没有全局安装 commitizen ， git cz 是无法执行的。</p><p>走完上述操作后其实已经可以实现我们提交的规范了, 但是 Angular 这一套规范我们可能不太习惯, 那么可以通过指定 Adapter cz-customizable 指定一套符合自己团队的规范.</p><p>项目级安装 cz-customizable</p><pre><code class="hljs bash">npm i -D cz-customizable</code></pre><p>然后修改 package.json 中的 config 为:</p><pre><code class="hljs json">&quot;config&quot;: &#123;    &quot;commitizen&quot;: &#123;        &quot;path&quot;: &quot;node_modules/cz-customizable&quot;    &#125;&#125;</code></pre><p>然后在项目目录下创建 .cz-config.js 文件 , 注明: 配置出自 GitHub： <a href="https://gist.github.com/leohxj/7bc928f60bfa46a3856ddf7c0f91ab98">Leo Hui</a></p><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<span class="hljs-built_in">module</span>.exports = &#123; types: [  &#123;   value: <span class="hljs-string">&#x27;WIP&#x27;</span>,   name: <span class="hljs-string">&#x27;💪  WIP:      Work in progress&#x27;</span>,  &#125;,  &#123;   value: <span class="hljs-string">&#x27;feat&#x27;</span>,   name: <span class="hljs-string">&#x27;✨  feat:     A new feature&#x27;</span>,  &#125;,  &#123;   value: <span class="hljs-string">&#x27;fix&#x27;</span>,   name: <span class="hljs-string">&#x27;🐞  fix:      A bug fix&#x27;</span>,  &#125;,  &#123;   value: <span class="hljs-string">&#x27;refactor&#x27;</span>,   name: <span class="hljs-string">&#x27;🛠  refactor: A code change that neither fixes a bug nor adds a feature&#x27;</span>,  &#125;,  &#123;   value: <span class="hljs-string">&#x27;docs&#x27;</span>,   name: <span class="hljs-string">&#x27;📚  docs:     Documentation only changes&#x27;</span>,  &#125;,  &#123;   value: <span class="hljs-string">&#x27;test&#x27;</span>,   name: <span class="hljs-string">&#x27;🏁  test:     Add missing tests or correcting existing tests&#x27;</span>,  &#125;,  &#123;   value: <span class="hljs-string">&#x27;chore&#x27;</span>,   name: <span class="hljs-string">&quot;🗯  chore:    Changes that don&#x27;t modify src or test files. Such as updating build tasks, package manager&quot;</span>,  &#125;,  &#123;   value: <span class="hljs-string">&#x27;style&#x27;</span>,   name: <span class="hljs-string">&#x27;💅  style:    Code Style, Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)&#x27;</span>,  &#125;,  &#123;   value: <span class="hljs-string">&#x27;revert&#x27;</span>,   name: <span class="hljs-string">&#x27;⏪  revert:   Revert to a commit&#x27;</span>,  &#125;, ], scopes: [], allowCustomScopes: <span class="hljs-literal">true</span>, allowBreakingChanges: [<span class="hljs-string">&#x27;feat&#x27;</span>, <span class="hljs-string">&#x27;fix&#x27;</span>],&#125;;</code></pre><p>接下来我们再配置 校验 message 是否合法 , 如果不合法则拒绝提交.</p><p>项目级安装：</p><pre><code class="hljs bash">npm i -D @commitlint/config-conventional @commitlint/cli</code></pre><p>同时需要在项目目录下创建配置文件 .commitlintrc.js, 写入<a href="https://github.com/conventional-changelog/commitlint/blob/master/@commitlint/config-conventional/index.js">示例配置</a>:</p><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123; <span class="hljs-keyword">extends</span>: [<span class="hljs-string">&#x27;@commitlint/config-conventional&#x27;</span>], rules: &#123;&#125;,&#125;;</code></pre><p>如果您是自定义的 Adapter 那么您可能需要针对自定义的 Adapter 进行 Lint：</p><p>上述配置是使用了 符合 Angular 团队规范 的 Adapter , 而要根据我们自定义的 commitizen adapter , 则需要安装:</p><pre><code class="hljs bash">npm i -D commitlint-config-cz @commitlint/cli</code></pre><p>.commitlintrc.js 中写入:</p><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123; <span class="hljs-keyword">extends</span>: [<span class="hljs-string">&#x27;cz&#x27;</span>], rules: &#123;&#125;,&#125;;</code></pre><p>结合 Husky:</p><p>校验 commit message 的最佳方式是结合 git hook, 所以需要配合 <a href="https://github.com/typicode/husky">Husky</a>.</p><p>这个插件是可以让我们在 git commit 之前 都执行一次 hook 脚本</p><pre><code class="hljs bash">npm install husky --save-dev</code></pre><p>package.json 中添加:</p><pre><code class="hljs json">&quot;husky&quot;: &#123;    &quot;hooks&quot;: &#123;        &quot;pre-commit&quot;: &quot;npm run lint&quot;,        &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;    &#125;&#125;,</code></pre><p>或者 创建 .huskyrc.js 添加:</p><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123; hooks: &#123;  <span class="hljs-string">&#x27;pre-commit&#x27;</span>: <span class="hljs-string">&#x27;npm run lint&#x27;</span>,  <span class="hljs-string">&#x27;commit-msg&#x27;</span>: <span class="hljs-string">&#x27;commitlint -E HUSKY_GIT_PARAMS&#x27;</span>, &#125;,&#125;;</code></pre><p>配置后在后续的每一次 git commit 之前，都会执行一次对应的 hook 脚本 npm run lint 。其他 hook 同理</p><p>standard-version: 自动生成 CHANGELOG</p><p>通过以上工具的帮助, 我们的工程 commit message 应该是符合 Angular 团队那套, 这样也便于我们借助 <a href="https://github.com/conventional-changelog/standard-version">standard-version</a> 这样的工具, 自动生成 CHANGELOG, 甚至是 语义化的版本号(<a href="https://semver.org/lang/zh-CN/">Semantic Version</a>).</p><p>安装使用:</p><pre><code class="hljs bash">npm i -S standard-version</code></pre><p>package.json 配置:</p><pre><code class="hljs json">&quot;scirpt&quot;: &#123;    &quot;release&quot;: &quot;standard-version&quot;&#125;</code></pre><h3 id="vue-国际化配置"><a href="#vue-国际化配置" class="headerlink" title="vue 国际化配置"></a>vue 国际化配置</h3><p>我们使用 vue-i18n 来实现国际化。</p><p>首先当然是安装啦：</p><pre><code class="hljs bash">npm install vue-i18n -S</code></pre><p>安装完毕后，写配置文件，我们先来完成语言包吧：</p><pre><code class="hljs javascript"><span class="hljs-comment">//新建中文语言包：zh.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; input: &#123;  placeholder: <span class="hljs-string">&#x27;请输入用户名&#x27;</span>,  password: <span class="hljs-string">&#x27;请输入密码&#x27;</span>, &#125;,&#125;;</code></pre><p>然后再新建英文语言包：</p><pre><code class="hljs javascript"><span class="hljs-comment">// en.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; input: &#123;  placeholder: <span class="hljs-string">&#x27;Please enter a user name&#x27;</span>,  password: <span class="hljs-string">&#x27;Please enter your password&#x27;</span>, &#125;,&#125;;</code></pre><p>这是 demo ，所以就弄这两种语言试试水。</p><p>接下来新建一个 i18n.js 配置文件。</p><pre><code class="hljs javascript"><span class="hljs-comment">// i18n.js</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<span class="hljs-keyword">import</span> VueI18n <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-i18n&#x27;</span>;<span class="hljs-keyword">import</span> elementEnLocale <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui/lib/locale/lang/en&#x27;</span>; <span class="hljs-comment">// element-ui lang</span><span class="hljs-keyword">import</span> elementZhLocale <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui/lib/locale/lang/zh-CN&#x27;</span>; <span class="hljs-comment">// element-ui lang</span><span class="hljs-keyword">import</span> enLocale <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./lang/en&#x27;</span>;<span class="hljs-keyword">import</span> zhLocale <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./lang/zh&#x27;</span>;Vue.use(VueI18n);<span class="hljs-keyword">const</span> messages = &#123; en: &#123;  ...enLocale,  ...elementEnLocale, &#125;, zh: &#123;  ...zhLocale,  ...elementZhLocale, &#125;,&#125;;<span class="hljs-keyword">const</span> i18n = <span class="hljs-keyword">new</span> VueI18n(&#123; locale: <span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&#x27;locale&#x27;</span>) || <span class="hljs-string">&#x27;zh&#x27;</span>, <span class="hljs-comment">// set locale</span> messages, <span class="hljs-comment">// set locale messages</span>&#125;);<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> i18n;</code></pre><p>然后我们再来配置 mian.js.</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span>;<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./registerServiceWorker&#x27;</span>;<span class="hljs-comment">// 引入element ui框架</span><span class="hljs-keyword">import</span> ElementUI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>;<span class="hljs-comment">// 引入element ui 样式文件</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;<span class="hljs-comment">// 引入阿里icon</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;../public/img/icons/iconfont.css&#x27;</span>;<span class="hljs-comment">// 如果是使用svg就要引入iconfont.js这个文件</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;../public/img/icons/iconfont&#x27;</span>;<span class="hljs-comment">// 国际化</span><span class="hljs-keyword">import</span> i18n <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./common/i18n.js&#x27;</span>;<span class="hljs-comment">//全局注册组件</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./components/index&#x27;</span>;<span class="hljs-comment">//全局使用插件</span>Vue.use(ElementUI, &#123; size: <span class="hljs-string">&#x27;medium&#x27;</span>, <span class="hljs-comment">// set element-ui default size</span> i18n: <span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span> i18n.t(key, value),&#125;);Vue.config.productionTip = <span class="hljs-literal">false</span>;<span class="hljs-keyword">new</span> Vue(&#123; router, store, i18n, <span class="hljs-comment">// 国际化</span> render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App),&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>);</code></pre><p>入口文件这里其他的我就不解释了，主要讲国际化，把我们的国际化配置文件引进来，引进来之后，注入到 vue 的实例里面去，这里有一个很重要的点，为了让 element 的内部组件语言也改变，所以下面这段代码不能少：</p><pre><code class="hljs javascript"><span class="hljs-comment">//全局使用插件</span>Vue.use(ElementUI, &#123; size: <span class="hljs-string">&#x27;medium&#x27;</span>, <span class="hljs-comment">// set element-ui default size</span> i18n: <span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span> i18n.t(key, value),&#125;);</code></pre><p>具体原因别问我，我不懂，因为我也踩了好久的坑，才百度到这个。</p><p>接下来就是使用了。</p><pre><code class="hljs vue">&lt;template&gt; &lt;div class&#x3D;&quot;login&quot;&gt;  &lt;el-input :placeholder&#x3D;&quot;$t(&#39;input.placeholder&#39;)&quot; prefix-icon&#x3D;&quot;icon-tubiao-15&quot; v-model&#x3D;&quot;input21&quot; &#x2F;&gt;  &lt;el-input :placeholder&#x3D;&quot;$t(&#39;input.password&#39;)&quot; prefix-icon&#x3D;&quot;icon-tubiao-15&quot; v-model&#x3D;&quot;input&quot; &#x2F;&gt;  &lt;div class&#x3D;&quot;lang&quot;&gt;   &lt;el-dropdown @command&#x3D;&quot;handleCommand&quot; size&#x3D;&quot;small&quot;&gt;    &lt;span class&#x3D;&quot;el-dropdown-link&quot;&gt; &#123;&#123; locale &#125;&#125;&lt;i class&#x3D;&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;&#x2F;i&gt; &lt;&#x2F;span&gt;    &lt;el-dropdown-menu slot&#x3D;&quot;dropdown&quot;&gt;     &lt;el-dropdown-item command&#x3D;&quot;zh-CN&quot; :disabled&#x3D;&quot;locale &#x3D;&#x3D;&#x3D; &#39;中文&#39;&quot;&gt;中文&lt;&#x2F;el-dropdown-item&gt;     &lt;el-dropdown-item command&#x3D;&quot;en-US&quot; :disabled&#x3D;&quot;locale &#x3D;&#x3D;&#x3D; &#39;English&#39;&quot;&gt;English&lt;&#x2F;el-dropdown-item&gt;    &lt;&#x2F;el-dropdown-menu&gt;   &lt;&#x2F;el-dropdown&gt;  &lt;&#x2F;div&gt;  &lt;el-date-picker v-model&#x3D;&quot;value1&quot; type&#x3D;&quot;datetime&quot; :placeholder&#x3D;&quot;$t(&#39;input.placeholder&#39;)&quot;&gt; &lt;&#x2F;el-date-picker&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;login&#39;, data() &#123;  return &#123;   input21: &#39;&#39;,   input: &#39;&#39;,   value1: &#39;&#39;,  &#125;; &#125;, computed: &#123;  locale() &#123;   if (this.$i18n.locale &#x3D;&#x3D;&#x3D; &#39;zh&#39;) &#123;    return &#39;中文&#39;;   &#125; else &#123;    return &#39;English&#39;;   &#125;  &#125;, &#125;, methods: &#123;  handleCommand(command) &#123;   if (command &#x3D;&#x3D; &#39;zh-CN&#39;) &#123;    localStorage.setItem(&#39;locale&#39;, &#39;zh&#39;);    this.$i18n.locale &#x3D; localStorage.getItem(&#39;locale&#39;);    console.log(this.$i18n.locale);    this.$message(&#123;     message: &#39;切换为中文！&#39;,     type: &#39;success&#39;,    &#125;);   &#125; else if (command &#x3D;&#x3D; &#39;en-US&#39;) &#123;    localStorage.setItem(&#39;locale&#39;, &#39;en&#39;);    this.$i18n.locale &#x3D; localStorage.getItem(&#39;locale&#39;);    console.log(this.$i18n.locale);    this.$message(&#123;     message: &#39;Switch to English!&#39;,     type: &#39;success&#39;,    &#125;);   &#125;  &#125;, &#125;,&#125;;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt;</code></pre><p>使用的话就是：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">:placeholder</span>=<span class="hljs-string">&quot;$t(&#x27;input.placeholder&#x27;)&quot;</span> <span class="hljs-attr">prefix-icon</span>=<span class="hljs-string">&quot;icon-tubiao-15&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;input21&quot;</span> /&gt;</span> // 属性里面这样用 <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;$t(&#x27;input.placeholder&#x27;)&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> // 标签内这样用。</code></pre><p>这里面的值是我们写的语言包对象，key 是 input，value 是 placeholder，</p><p>至于我们如何来根据事件更换语言包呢？</p><p>直接改变它的值：this.$i18n.locale 就可以实现了，具体就是当你触发点击事件的时候，把这个值改变成你相应的语言包名字就可以了，注意，每次更换一点要把本地存储的值给覆盖哦。</p><pre><code class="hljs javascript">handleCommand (command) &#123;  <span class="hljs-keyword">if</span> (command == <span class="hljs-string">&#x27;zh-CN&#x27;</span>) &#123;    <span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&#x27;locale&#x27;</span>, <span class="hljs-string">&#x27;zh&#x27;</span>)    <span class="hljs-built_in">this</span>.$i18n.locale = <span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&#x27;locale&#x27;</span>)    <span class="hljs-comment">// console.log(this.$i18n.locale);</span>    <span class="hljs-built_in">this</span>.$message(&#123;      message: <span class="hljs-string">&#x27;切换为中文！&#x27;</span>,      type: <span class="hljs-string">&#x27;success&#x27;</span>    &#125;)  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (command == <span class="hljs-string">&#x27;en-US&#x27;</span>) &#123;    <span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&#x27;locale&#x27;</span>, <span class="hljs-string">&#x27;en&#x27;</span>)    <span class="hljs-built_in">this</span>.$i18n.locale = <span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&#x27;locale&#x27;</span>)    <span class="hljs-comment">// console.log(this.$i18n.locale);</span>    <span class="hljs-built_in">this</span>.$message(&#123;      message: <span class="hljs-string">&#x27;Switch to English!&#x27;</span>,      type: <span class="hljs-string">&#x27;success&#x27;</span>    &#125;)  &#125;&#125;</code></pre><p>这样国际化就实现啦<del>~</del></p><p>这里再提一个 bug，但是我想不清楚应该怎么解决，只能临时找到个比较 bug 的方式</p><p>假如，我们有一个数组，也是需要配置国际化的，例如下拉框，看代码如下：</p><pre><div class="caption"><span>javascript</span></div><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;value&quot;</span> <span class="hljs-attr">:placeholder</span>=<span class="hljs-string">&quot;$t(&#x27;input.placeholder&#x27;)&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">el-option</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in options&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">:label</span>=<span class="hljs-string">&quot;item.label&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-option</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-select</span>&gt;</span>data () &#123;    return &#123;        options: this.$t(&#x27;input.options&#x27;)    &#125;&#125;,</code></pre><p>我们都知道，vue 更改数组是要使用 this.$set()方法才能更新视图的，但是，这里是直接从语言包里面拿到一个数据，当你切换语言包的时候，视图并不会更新，需要手动刷新一次才能够显示，我这里暂时的解决方案是直接在切换语言的时候在那个事件上调用:</p><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$router.go(<span class="hljs-number">0</span>);</code></pre><p>但是用户体验真心不好，哪位大哥知道更好的方法，求加微信：294999978 指教，本人小白一枚，真心感谢</p><pre><code class="hljs javascript">handleCommand (command) &#123;  <span class="hljs-keyword">if</span> (command == <span class="hljs-string">&#x27;zh-CN&#x27;</span>) &#123;    <span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&#x27;locale&#x27;</span>, <span class="hljs-string">&#x27;zh&#x27;</span>)    <span class="hljs-built_in">this</span>.$i18n.locale = <span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&#x27;locale&#x27;</span>)    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.$i18n.locale);    <span class="hljs-built_in">this</span>.$router.go(<span class="hljs-number">0</span>)<span class="hljs-comment">// 刷新页面，为的就是触发视图</span>    <span class="hljs-built_in">this</span>.$message(&#123;      message: <span class="hljs-string">&#x27;切换为中文！&#x27;</span>,      type: <span class="hljs-string">&#x27;success&#x27;</span>    &#125;)  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (command == <span class="hljs-string">&#x27;en-US&#x27;</span>) &#123;    <span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&#x27;locale&#x27;</span>, <span class="hljs-string">&#x27;en&#x27;</span>)    <span class="hljs-built_in">this</span>.$i18n.locale = <span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&#x27;locale&#x27;</span>)    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.$i18n.locale);    <span class="hljs-built_in">this</span>.$router.go(<span class="hljs-number">0</span>)  <span class="hljs-comment">// 刷新页面，为的就是触发视图</span>    <span class="hljs-built_in">this</span>.$message(&#123;      message: <span class="hljs-string">&#x27;Switch to English!&#x27;</span>,      type: <span class="hljs-string">&#x27;success&#x27;</span>    &#125;)  &#125;&#125;</code></pre><h3 id="最后奉上项目的整体配置-以及源码的地址"><a href="#最后奉上项目的整体配置-以及源码的地址" class="headerlink" title="最后奉上项目的整体配置 , 以及源码的地址"></a>最后奉上项目的整体配置 , 以及<a href="https://github.com/ChaliceLee92/vue_admin">源码的地址</a></h3><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-keyword">let</span> LodashModuleReplacementPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash-webpack-plugin&#x27;</span>);<span class="hljs-keyword">const</span> BundleAnalyzerPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-bundle-analyzer&#x27;</span>).BundleAnalyzerPlugin;<span class="hljs-comment">// 配置别名</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">dir</span>) </span>&#123; <span class="hljs-keyword">return</span> path.join(__dirname, dir);&#125;<span class="hljs-comment">// gzip压缩</span><span class="hljs-keyword">const</span> CompressionWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;compression-webpack-plugin&#x27;</span>);<span class="hljs-comment">// 代码压缩</span><span class="hljs-keyword">const</span> UglifyJsPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;uglifyjs-webpack-plugin&#x27;</span>);<span class="hljs-comment">// 是否为生产环境</span><span class="hljs-keyword">const</span> isProduction = process.env.NODE_ENV !== <span class="hljs-string">&#x27;development&#x27;</span>;<span class="hljs-comment">// 本地环境是否需要使用cdn</span><span class="hljs-keyword">const</span> devNeedCdn = <span class="hljs-literal">false</span>;<span class="hljs-comment">// cdn链接</span><span class="hljs-keyword">const</span> cdn = &#123; <span class="hljs-comment">// cdn：模块名称和模块作用域命名（对应window里面挂载的变量名称）</span> externals: &#123;  vue: <span class="hljs-string">&#x27;Vue&#x27;</span>,  vuex: <span class="hljs-string">&#x27;Vuex&#x27;</span>,  <span class="hljs-string">&#x27;vue-router&#x27;</span>: <span class="hljs-string">&#x27;VueRouter&#x27;</span>,  <span class="hljs-string">&#x27;element-ui&#x27;</span>: <span class="hljs-string">&#x27;ELEMENT&#x27;</span>,  axios: <span class="hljs-string">&#x27;axios&#x27;</span>, &#125;, <span class="hljs-comment">// cdn的css链接</span> css: [<span class="hljs-string">&#x27;https://unpkg.com/element-ui/lib/theme-chalk/index.css&#x27;</span>], <span class="hljs-comment">// cdn的js链接</span> js: [<span class="hljs-string">&#x27;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&#x27;</span>, <span class="hljs-string">&#x27;https://cdn.bootcss.com/vuex/3.1.1/vuex.min.js&#x27;</span>, <span class="hljs-string">&#x27;https://cdn.bootcss.com/vue-router/3.1.3/vue-router.min.js&#x27;</span>, <span class="hljs-string">&#x27;https://unpkg.com/element-ui/lib/index.js&#x27;</span>, <span class="hljs-string">&#x27;https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.min.js&#x27;</span>],&#125;;<span class="hljs-comment">// 获取baseurl</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProxy</span>(<span class="hljs-params">path, type</span>) </span>&#123; <span class="hljs-keyword">if</span> (path === <span class="hljs-string">&#x27;/api&#x27;</span>) &#123;  <span class="hljs-keyword">switch</span> (type) &#123;   <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;localhost&#x27;</span>:    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;http://106.52.38.245:9000/sys&#x27;</span>;   <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;service&#x27;</span>:    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;http://106.52.38.245:9000/sys&#x27;</span>;  &#125; &#125;&#125;<span class="hljs-built_in">module</span>.exports = &#123; productionSourceMap: <span class="hljs-literal">false</span>, chainWebpack: <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;  config.resolve.alias.set(<span class="hljs-string">&#x27;@&#x27;</span>, resolve(<span class="hljs-string">&#x27;src&#x27;</span>)).set(<span class="hljs-string">&#x27;@assets&#x27;</span>, resolve(<span class="hljs-string">&#x27;src/assets&#x27;</span>)).set(<span class="hljs-string">&#x27;@components&#x27;</span>, resolve(<span class="hljs-string">&#x27;src/components&#x27;</span>)).set(<span class="hljs-string">&#x27;@router&#x27;</span>, resolve(<span class="hljs-string">&#x27;src/router&#x27;</span>)).set(<span class="hljs-string">&#x27;@views&#x27;</span>, resolve(<span class="hljs-string">&#x27;src/views&#x27;</span>)).set(<span class="hljs-string">&#x27;@store&#x27;</span>, resolve(<span class="hljs-string">&#x27;src/store&#x27;</span>)).set(<span class="hljs-string">&#x27;@utils&#x27;</span>, resolve(<span class="hljs-string">&#x27;src/utils&#x27;</span>)).set(<span class="hljs-string">&#x27;@interface&#x27;</span>, resolve(<span class="hljs-string">&#x27;src/http/interface&#x27;</span>));  <span class="hljs-comment">// ============压缩图片 start============</span>  config.module   .rule(<span class="hljs-string">&#x27;images&#x27;</span>)   .use(<span class="hljs-string">&#x27;image-webpack-loader&#x27;</span>)   .loader(<span class="hljs-string">&#x27;image-webpack-loader&#x27;</span>)   .options(    &#123;     mozjpeg: &#123; <span class="hljs-attr">progressive</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">quality</span>: <span class="hljs-number">65</span> &#125;,     optipng: &#123; <span class="hljs-attr">enabled</span>: <span class="hljs-literal">false</span> &#125;,     pngquant: &#123; <span class="hljs-attr">quality</span>: [<span class="hljs-number">0.65</span>, <span class="hljs-number">0.9</span>], <span class="hljs-attr">speed</span>: <span class="hljs-number">4</span> &#125;,     gifsicle: &#123; <span class="hljs-attr">interlaced</span>: <span class="hljs-literal">false</span> &#125;,     <span class="hljs-comment">// webp: &#123; quality: 75 &#125;</span>    &#125;,    &#123; <span class="hljs-attr">bypassOnDebug</span>: <span class="hljs-literal">true</span> &#125;   )   .end();  <span class="hljs-comment">// ============压缩图片 end============</span>  <span class="hljs-comment">// ============注入cdn start============</span>  config.plugin(<span class="hljs-string">&#x27;html&#x27;</span>).tap(<span class="hljs-function"><span class="hljs-params">args</span> =&gt;</span> &#123;   <span class="hljs-comment">// 生产环境或本地需要cdn时，才注入cdn</span>   <span class="hljs-keyword">if</span> (isProduction || devNeedCdn) args[<span class="hljs-number">0</span>].cdn = cdn;   <span class="hljs-comment">// 修复 Lazy loading routes Error</span>   args[<span class="hljs-number">0</span>].chunksSortMode = <span class="hljs-string">&#x27;none&#x27;</span>;   <span class="hljs-keyword">return</span> args;  &#125;);  <span class="hljs-comment">// ============注入cdn end============</span>  <span class="hljs-comment">// 修复HMR</span>  config.resolve.symlinks(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// 移除 prefetch 插件不会加载其他路由文件，只加载当前路由文件</span>  config.plugins.delete(<span class="hljs-string">&#x27;prefetch&#x27;</span>);  <span class="hljs-comment">// preload插件作用，暂时未知</span>  config.plugins.delete(<span class="hljs-string">&#x27;preload&#x27;</span>);  <span class="hljs-comment">// 配置TypeScript</span>  config.resolve.extensions   .add(<span class="hljs-string">&#x27;.ts&#x27;</span>)   .add(<span class="hljs-string">&#x27;.tsx&#x27;</span>)   .end()   .end()   .module.rule(<span class="hljs-string">&#x27;typescript&#x27;</span>)   .test(<span class="hljs-regexp">/\.tsx?$/</span>)   .use(<span class="hljs-string">&#x27;babel-loader&#x27;</span>)   .loader(<span class="hljs-string">&#x27;babel-loader&#x27;</span>)   .end()   .use(<span class="hljs-string">&#x27;ts-loader&#x27;</span>)   .loader(<span class="hljs-string">&#x27;ts-loader&#x27;</span>)   .options(&#123;    transpileOnly: <span class="hljs-literal">true</span>,    appendTsSuffixTo: [<span class="hljs-string">&#x27;\\.vue$&#x27;</span>],    happyPackMode: <span class="hljs-literal">false</span>,   &#125;)   .end(); &#125;, <span class="hljs-comment">// 如果你不需要使用eslint，把lintOnSave设为false即可</span> lintOnSave: <span class="hljs-literal">true</span>, css: &#123;  sourceMap: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 开启 CSS source maps</span>  extract: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否使用css分离插件 ExtractTextPlugin</span>  requireModuleExtension: <span class="hljs-literal">true</span>, <span class="hljs-comment">// false 会导致样式失效</span>  loaderOptions: &#123;   sass: &#123;    prependData: <span class="hljs-string">`@import &quot;@/assets/styles/varibles.scss&quot;;`</span>,   &#125;,  &#125;, &#125;, devServer: &#123;  <span class="hljs-comment">// historyApiFallback: true  // history 异步路由没有缓存在页面中，第一次进入页面会找不到 , 这个解决</span>  <span class="hljs-comment">// open: true,</span>  <span class="hljs-comment">// host: &#x27;localhost&#x27;,</span>  <span class="hljs-comment">// port: 8081,</span>  <span class="hljs-comment">// https: false,</span>  <span class="hljs-comment">// overlay: &#123;</span>  <span class="hljs-comment">//     warnings: true,</span>  <span class="hljs-comment">//     errors: true</span>  <span class="hljs-comment">// &#125;,</span>  <span class="hljs-comment">// proxy: &#123;</span>  <span class="hljs-comment">// 这里配置了 /sys 相当于就是 服务器的地址 . 例如: sys/login = http:localhost:8081/api/login</span>  <span class="hljs-comment">// &#x27;/sys&#x27;: &#123;</span>  <span class="hljs-comment">//     target: getProxy(&#x27;/api&#x27;, process.env.VUE_APP_TYPE),</span>  <span class="hljs-comment">//     ws: true,</span>  <span class="hljs-comment">//     changOrigin: true, //允许跨域</span>  <span class="hljs-comment">//     pathRewrite: &#123;</span>  <span class="hljs-comment">//         &#x27;^/sys&#x27;: &#x27;&#x27;</span>  <span class="hljs-comment">//     &#125;</span>  <span class="hljs-comment">// &#125;</span>  <span class="hljs-comment">// &#125;</span> &#125;, configureWebpack: <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;  <span class="hljs-comment">// 生产环境相关配置</span>  <span class="hljs-keyword">if</span> (isProduction) &#123;   <span class="hljs-comment">// 代码压缩</span>   config.plugins.push(    <span class="hljs-keyword">new</span> UglifyJsPlugin(&#123;     uglifyOptions: &#123;      warnings: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 若打包错误，则注释这行</span>      <span class="hljs-comment">//生产环境自动删除console</span>      compress: &#123;       drop_debugger: <span class="hljs-literal">true</span>,       drop_console: <span class="hljs-literal">true</span>,       pure_funcs: [<span class="hljs-string">&#x27;console.log&#x27;</span>],      &#125;,     &#125;,     sourceMap: <span class="hljs-literal">false</span>,     parallel: <span class="hljs-literal">true</span>,    &#125;)   );   <span class="hljs-comment">// gzip压缩</span>   <span class="hljs-keyword">const</span> productionGzipExtensions = [<span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-string">&#x27;css&#x27;</span>];   config.plugins.push(    <span class="hljs-keyword">new</span> CompressionWebpackPlugin(&#123;     filename: <span class="hljs-string">&#x27;[path].gz[query]&#x27;</span>,     algorithm: <span class="hljs-string">&#x27;gzip&#x27;</span>,     test: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;\\.(&#x27;</span> + productionGzipExtensions.join(<span class="hljs-string">&#x27;|&#x27;</span>) + <span class="hljs-string">&#x27;)$&#x27;</span>),     threshold: <span class="hljs-number">10240</span>, <span class="hljs-comment">// 只有大小大于该值的资源会被处理 10240</span>     minRatio: <span class="hljs-number">0.8</span>, <span class="hljs-comment">// 只有压缩率小于这个值的资源才会被处理</span>     deleteOriginalAssets: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 删除原文件</span>    &#125;)   );   <span class="hljs-comment">// 公共代码抽离  构建优化上我们使用了 happypack 来利用多核CPU 加快打包的速度。</span>   config.optimization = &#123;    <span class="hljs-comment">// https://webpack.js.org/plugins/split-chunks-plugin/</span>    splitChunks: &#123;     <span class="hljs-comment">// minSize: 1000000, // 单个文件的最小size</span>     <span class="hljs-comment">// maxSize: 2000000, // 单个文件最大的size</span>     <span class="hljs-comment">// minChunks: 2, // 最小被引用</span>     <span class="hljs-comment">// maxAsyncRequests: 5, // 首页加载资源</span>     <span class="hljs-comment">// maxInitialRequests: 3,</span>     <span class="hljs-comment">// automaticNameDelimiter: &#x27;~&#x27;, // 打包文件自定义的链接符</span>     <span class="hljs-comment">// name: true,</span>     <span class="hljs-comment">// chunks: &#x27;async&#x27;, // initial(初始块)、async(按需加载块)、all(默认，全部块)</span>     <span class="hljs-comment">// 这里需要注意的是如果使用initial 会将首页需要的依赖和项目本身的依赖打包2次增大文件体积</span>     cacheGroups: &#123;      <span class="hljs-keyword">default</span>: <span class="hljs-literal">false</span>,      vendors: &#123;       name: <span class="hljs-string">&#x27;chunk-vendors&#x27;</span>,       test: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,       chunks: <span class="hljs-string">&#x27;initial&#x27;</span>,       priority: <span class="hljs-number">2</span>,       reuseExistingChunk: <span class="hljs-literal">true</span>,       enforce: <span class="hljs-literal">true</span>,      &#125;,      common: &#123;       name: <span class="hljs-string">&#x27;chunk-common&#x27;</span>,       chunks: <span class="hljs-string">&#x27;initial&#x27;</span>,       minChunks: <span class="hljs-number">2</span>,       maxInitialRequests: <span class="hljs-number">5</span>,       minSize: <span class="hljs-number">0</span>,       priority: <span class="hljs-number">1</span>,       reuseExistingChunk: <span class="hljs-literal">true</span>,       enforce: <span class="hljs-literal">true</span>,      &#125;,      elementUI: &#123;       name: <span class="hljs-string">&#x27;chunk-elementui&#x27;</span>,       test: <span class="hljs-regexp">/[\\/]node_modules[\\/]element-ui[\\/]/</span>,       chunks: <span class="hljs-string">&#x27;all&#x27;</span>,       priority: <span class="hljs-number">3</span>,       reuseExistingChunk: <span class="hljs-literal">true</span>,       enforce: <span class="hljs-literal">true</span>,      &#125;,      echarts: &#123;       name: <span class="hljs-string">&#x27;chunk-echarts&#x27;</span>,       test: <span class="hljs-regexp">/[\\/]node_modules[\\/](vue-)?echarts[\\/]/</span>,       chunks: <span class="hljs-string">&#x27;all&#x27;</span>,       priority: <span class="hljs-number">4</span>,       reuseExistingChunk: <span class="hljs-literal">true</span>,       enforce: <span class="hljs-literal">true</span>,      &#125;,      vue: &#123;       test(<span class="hljs-built_in">module</span>) &#123;        <span class="hljs-keyword">let</span> path = <span class="hljs-built_in">module</span>.resource;        <span class="hljs-keyword">if</span> (!path) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        path = path.replace(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">&#x27;/&#x27;</span>);        <span class="hljs-comment">// return path &amp;&amp; path.indexOf(&#x27;node_modules&#x27;) &gt; -1 &amp;&amp; path.indexOf(&#x27;vuetify&#x27;) &gt; -1</span>        <span class="hljs-keyword">return</span> path &amp;&amp; <span class="hljs-regexp">/node_modules\/vue/</span>.test(path);       &#125;,       name: <span class="hljs-string">&#x27;chunk-vuetify&#x27;</span>,       priority: <span class="hljs-number">9</span>,       enforce: <span class="hljs-literal">true</span>,      &#125;,      styles: &#123;       name: <span class="hljs-string">&#x27;styles&#x27;</span>,       test: <span class="hljs-regexp">/\.(sa|sc|c)ss$/</span>,       chunks: <span class="hljs-string">&#x27;all&#x27;</span>,       enforce: <span class="hljs-literal">true</span>,      &#125;,      runtimeChunk: &#123;       name: <span class="hljs-string">&#x27;manifest&#x27;</span>,      &#125;,     &#125;,    &#125;,   &#125;;   <span class="hljs-comment">// 可视化包大小</span>   config.plugins.push(    <span class="hljs-keyword">new</span> BundleAnalyzerPlugin(&#123;     analyzerMode: <span class="hljs-string">&#x27;server&#x27;</span>,     analyzerHost: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,     analyzerPort: <span class="hljs-number">8889</span>,     reportFilename: <span class="hljs-string">&#x27;report.html&#x27;</span>,     defaultSizes: <span class="hljs-string">&#x27;parsed&#x27;</span>,     openAnalyzer: <span class="hljs-literal">false</span>,     generateStatsFile: <span class="hljs-literal">false</span>,     statsFilename: <span class="hljs-string">&#x27;stats.json&#x27;</span>,     statsOptions: <span class="hljs-literal">null</span>,     logLevel: <span class="hljs-string">&#x27;info&#x27;</span>,    &#125;)   );  &#125;  config.plugins.push(<span class="hljs-keyword">new</span> LodashModuleReplacementPlugin());  <span class="hljs-comment">// 用cdn方式引入，则构建时要忽略相关资源</span>  <span class="hljs-keyword">if</span> (isProduction || devNeedCdn) config.externals = cdn.externals;  <span class="hljs-comment">// 取消webpack警告的性能提示</span>  config.performance = &#123;   hints: <span class="hljs-string">&#x27;warning&#x27;</span>,   <span class="hljs-comment">//入口起点的最大体积</span>   maxEntrypointSize: <span class="hljs-number">50000000</span>,   <span class="hljs-comment">//生成文件的最大体积</span>   maxAssetSize: <span class="hljs-number">30000000</span>,   <span class="hljs-comment">//只给出 js 文件的性能提示</span>   assetFilter: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">assetFilename</span>) </span>&#123;    <span class="hljs-keyword">return</span> assetFilename.endsWith(<span class="hljs-string">&#x27;.js&#x27;</span>);   &#125;,  &#125;;  <span class="hljs-comment">// 配置TS</span>  <span class="hljs-comment">// config.resolve = &#123; extensions: [&#x27;.ts&#x27;, &#x27;.tsx&#x27;, &#x27;.js&#x27;, &#x27;.json&#x27;] &#125;</span>  <span class="hljs-comment">// config.module = &#123;</span>  <span class="hljs-comment">//     rules: [</span>  <span class="hljs-comment">//         &#123;</span>  <span class="hljs-comment">//             test: /.tsx?$/,</span>  <span class="hljs-comment">//             loader: &#x27;ts-loader&#x27;,</span>  <span class="hljs-comment">//             exclude: /node_modules/,</span>  <span class="hljs-comment">//             options: &#123;</span>  <span class="hljs-comment">//                 appendTsSuffixTo: [/.vue$/]</span>  <span class="hljs-comment">//             &#125;</span>  <span class="hljs-comment">//         &#125;</span>  <span class="hljs-comment">//     ]</span>  <span class="hljs-comment">// &#125;</span> &#125;, <span class="hljs-comment">// 第三方插件配置</span> pluginOptions: &#123;&#125;,&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue.config TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh配置连接多台服务器快捷键</title>
    <link href="/articles/2020/09/01/ssh%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/articles/2020/09/01/ssh%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>创建 SSH 密钥对：</p><pre><code class="hljs bash"><span class="hljs-comment"># 生成密钥对 我们可以使用 ssh-keygen 命令来生成密钥对：</span>ssh-keygen -t ecdsa -b 521 -C <span class="hljs-string">&quot;<span class="hljs-subst">$(whoami)</span>@<span class="hljs-subst">$(hostname)</span>-<span class="hljs-subst">$(date -I)</span>&quot;</span></code></pre><p>其中可使用 -t 指定加密算法，使用 -b 自定生成密钥长度，使用 -C 添加密钥对的说明comment。生成的密钥对默认存储在用户目录下的 .ssh 目录中，私钥默认名称为 id_*** (即 id_ + 加密算法名称)。还可以使用 -f 指定生成的私钥存储的文件全路径名称；也可以不使用 -f 指定密钥文件路径，在密钥的创建过程中还会提示用户输入密钥文件全路径名称。私钥对应的公钥文件为私钥文件全名称 + .pub。</p><p>上面例子中创建了一对长度为512位的椭圆加密算法(ECDSA)加密的密钥对。创建 SSH 密钥对可选择多种加密算法，例如 RSA 、 DSA 、 ECDSA 等。</p><p>正常你的.ssh目录下会有以下文件：</p><pre><code class="hljs bash">config      id_rsa     id_rsa.pub  known_hosts</code></pre><p>即使没有config文件的话，你可以touch config文件。</p><p>内容如下：</p><pre><code class="hljs bash">Host        devHostName        111.111.111.111Port            22User            xxIdentityFile    ~/.ssh/id_rsaHost        pro1HostName        111.111.111.112Port            22User            xxIdentityFile    ~/.ssh/id_rsa</code></pre><p>配置完事之后，你就可以在命令窗口，直接ssh dev，就可以直接连到服务器111.111.111.111上了，不用像以前那样去写<br>ssh [-l login_name] [-p port] [user@]hostname。</p><p>前提是你要打通本机与服务器的ssh。</p><p>另外再提一下：</p><p>使用Windows下的putty客户端可以直接使用.ppk密钥文件进行认证登录远程服务器。</p><p>Mac系统虽然自带了Terminal，但是Mac下的Terminal使用.pem文件，而不是.ppk文件，而.pem文件可以从.ppk文件转换而来。</p><p>一种方法是使用Windows下的puttygen进行转换。</p><p>另一种方法是在Mac系统下安装putty并进行转换，步骤如下：</p><ol><li><p>使用Homebrew安装putty(homebrew是Mac下的包管理工具)：</p> <pre><code class="hljs bash">brew install putty</code></pre><p> 同时会安装puttygen。</p></li><li><p>使用puttygen从.ppk文件产生.pem文件：</p> <pre><code class="hljs bash">puttygen privatekey.ppk -O private-openssh -o privatekey.pem</code></pre><p> 注意：前面一个是大写O，后面一个小写o。</p></li><li><p>连接的话就把 config 内的 IdentityFile 字段指向这个 .pem 文件 ，然后终端 ssh 快捷连接即可</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>SSH</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置 config</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac最新版本系统安装MongoDB</title>
    <link href="/articles/2020/09/01/Mac%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85MongoDB/"/>
    <url>/articles/2020/09/01/Mac%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85MongoDB/</url>
    
    <content type="html"><![CDATA[<h2 id="MongoDB安装（4-2-x）"><a href="#MongoDB安装（4-2-x）" class="headerlink" title="MongoDB安装（4.2.x）"></a>MongoDB安装（4.2.x）</h2><p>Mac环境下，使用homebrew安装：</p><blockquote><p>现MongoDB不再是开源，官方已经从Homebrew中移除，所以无法通过 brew install mongodb 安装，会提示 No available formula with the name “mongodb”，需使用最新的方法安装社区版。</p></blockquote><p>首先使用 brew tap 命令设定到MongoDB第三方库，执行下方命令：</p><pre><code class="hljs bash">brew tap mongodb/brew</code></pre><p>加载完成后，开始安装MongoDB，根据需求选择安装的版本：</p><pre><code class="hljs bash">brew install mongodb-community   // 安装MongoDB社区服务器的最新可用生产版本brew install mongodb-community@4.2   // 安装MongoDB最新4.2.xbrew install mongodb-community@4.0   // 安装MongoDB最新4.0.x</code></pre><p>等待安装完成.</p><p>验证是否安装成功，可输入查看版本信息：</p><pre><code class="hljs bash">mongo -version</code></pre><p>显示版本信息则表示安装成功！！</p><h3 id="默认配置文件"><a href="#默认配置文件" class="headerlink" title="默认配置文件"></a>默认配置文件</h3><p>正常情况下，不需要自己修改配置，直接用默认配置即可:</p><pre><code class="hljs bash">配置文件：/usr/<span class="hljs-built_in">local</span>/etc/mongod.conf日志目录路径：/usr/<span class="hljs-built_in">local</span>/var/<span class="hljs-built_in">log</span>/mongodb数据目录路径：/usr/<span class="hljs-built_in">local</span>/var/mongodb</code></pre><h3 id="启动和停止服务器"><a href="#启动和停止服务器" class="headerlink" title="启动和停止服务器"></a>启动和停止服务器</h3><blockquote><p>有两种启动方式，使用brew服务启动、手动启动；同时注意的是，用什么方式启动的，就用什么方式停止，否则有可能出现下次无法启动的问题</p></blockquote><p>第一种: 使用brew服务启动，此方式启动，会自动后台运行，关闭终端不影响运行（推荐！）</p><pre><code class="hljs bash">sudo brew services start mongodb-community  // 启动sudo brew services start mongodb-community  // 停止sudo brew services restart mongodb-community  // 重启</code></pre><p>第二种: 手动启动，如果不想或不需要后台MongoDB服务，可手动启动.</p><pre><code class="hljs bash">sudo mongod --config /usr/<span class="hljs-built_in">local</span>/etc/mongod.conf // 启动mongo admin --<span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;db.shutdownServer()&quot;</span> // 关闭</code></pre><h3 id="启动异常说明"><a href="#启动异常说明" class="headerlink" title="启动异常说明"></a>启动异常说明</h3><ol><li><p>启动时提示‘exception in initAndListen: NonExistentPath: Data directory /data/db not found., terminating’</p><p> 未加–config启动，使用的dbPath是 /data/db ，不存在或没有创建这个文件件的话或报这个错误。</p> <pre><code class="hljs bash">sudo mkdir -p /data/db // 创建db文件可解决！</code></pre><p> 最新系统中创建会提示: mkdir: /data/db: Read-only file system<br> 这个问题可以看看<a href="https://xuezenghui.com/posts/update-catalina-bug/">文章</a>, 或者谷歌一下其他的<a href="https://blog.csdn.net/nightwishh/article/details/102535869">方法</a></p></li><li><p>启动报‘exception in initAndListen: DBPathInUse: Unable to lock the lock file: (Unknown error). Another mongod instance is already running on the /data/db directory, terminating.’</p><p> mongodb非正常关闭，删除mongod.lock文件即可，然后重启</p> <pre><code class="hljs bash">sudo rm /data/db/mongod.lock</code></pre></li><li><p>输入启动命令没有任何反应</p> <pre><code class="hljs bash">大部分是Mac系统权限的问题，启动的时候加入 sudo 尝试</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安装MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript重点之原型与原型链</title>
    <link href="/articles/2020/09/01/JavaScript%E9%87%8D%E7%82%B9%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/articles/2020/09/01/JavaScript%E9%87%8D%E7%82%B9%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="JavaScript-之-原型链"><a href="#JavaScript-之-原型链" class="headerlink" title="JavaScript 之 原型链"></a>JavaScript 之 原型链</h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>理解原型链 的前提是要搞清楚 对象 ，JavaScript中 <strong>万物皆对象</strong> ，但是 对象也是有区别的 ， 它分为 普通对象 和 函数对象。</p><p><strong>Object</strong> 、<strong>Function</strong> 是 JavaScript 中自带的函数对象。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 在 浏览器 中打印 Object 以及 Function 这两个对象</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>); <span class="hljs-comment">//function </span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Function</span>); <span class="hljs-comment">//function  </span><span class="hljs-comment">// 普通对象</span><span class="hljs-keyword">var</span> o1 = &#123;&#125;; <span class="hljs-keyword">var</span> o2 =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<span class="hljs-keyword">var</span> o3 = <span class="hljs-keyword">new</span> f1();<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> o1); <span class="hljs-comment">//object </span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> o2); <span class="hljs-comment">//object </span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> o3); <span class="hljs-comment">//object</span><span class="hljs-comment">// 函数对象</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;&#125;; <span class="hljs-keyword">var</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<span class="hljs-keyword">var</span> f3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;str&#x27;</span>,<span class="hljs-string">&#x27;console.log(str)&#x27;</span>);<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> f1); <span class="hljs-comment">//function </span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> f2); <span class="hljs-comment">//function </span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> f3); <span class="hljs-comment">//function   </span></code></pre><p>这个例子 可以看出 ，凡是通过 <strong>new Function</strong> 创建的对象都是函数对象 ， 其他的都是普通对象。</p><blockquote><p>注意： f1 , f2 归根结底 都是通过new Function 创建出来的 ， Function 以及 Object也都是通过new Function 创建的；JavaScript 中 其他内置对象也都是 通过new Function 创建出来的。</p></blockquote><p>分清楚普通对象 以及 函数对象 这两点 <strong>很重要！！！</strong></p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>记住普通对象和函数对象的区别之后，我们再来看看 构造函数。</p><p>先来看个实例：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 我们声明了一个 Person 类 ， 它具有名字 年龄 以及一个行为 sayName 方法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123; <span class="hljs-built_in">this</span>.name = name; <span class="hljs-built_in">this</span>.age = age; <span class="hljs-built_in">this</span>.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    alert(<span class="hljs-built_in">this</span>.name)  &#125; &#125;<span class="hljs-comment">// 实例化</span><span class="hljs-keyword">let</span> xiaoming = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-number">18</span>)<span class="hljs-keyword">let</span> xiaohong = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小红&quot;</span>,<span class="hljs-number">18</span>)</code></pre><p>例子中xiaoming 以及 xiaohong 都是Person类的实例，这两个实例都会有一个 constructor（构造函数） 属性,这个属性指向的就是Person这个类，它其实就是一个指针，我们来证明下他们之间的关系:</p><pre><code class="hljs javascript">xiaoming.constructor === Person <span class="hljs-comment">// true</span>xiaohong.constructor === person <span class="hljs-comment">// true</span></code></pre><p>在这里我们需要记住两个点: </p><ul><li>构造函数</li><li>实例</li></ul><p>总结一句话其实就是: <strong>实例的构造函数属性指向构造函数</strong>。</p><h4 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h4><p>记住了构造函数和对象的知识点后，我们再来看看<strong>原型对象</strong>。</p><p>在JavaScript中 ，每声明一个对象（函数也是对象）的时候，对象中都会包含一些预定义的属性。其中 <strong>函数对象</strong>都会有一个<code>prototype</code> 属性 ，而这个 <code>prototype</code>属性指向函数的原型对象</p><p>看下实例：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;Person.prototype.name = <span class="hljs-string">&#x27;xing&#x27;</span>; <span class="hljs-comment">// 在原型对象上添加了 name 属性</span>Person.prototype.age  = <span class="hljs-number">28</span>; <span class="hljs-comment">// 在原型对象上添加了 age 属性</span>Person.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// 在原型对象上添加了 sayName 方法</span>  alert(<span class="hljs-built_in">this</span>.name);&#125;  <span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person();  <span class="hljs-comment">// 实例化</span>person1.sayName(); <span class="hljs-comment">// &#x27;xing&#x27;</span><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person(); <span class="hljs-comment">// 实例化</span>person2.sayName(); <span class="hljs-comment">// &#x27;xing&#x27;</span><span class="hljs-built_in">console</span>.log(person1.sayName == person2.sayName); <span class="hljs-comment">//true</span></code></pre><p>我们在Person的prototype属性上添加了各种属性 ， 最后在调用的时候它们其实都是同一个 ， 这是因为 prototype属性指向的是函数的原型对象，如果你还不理解 ，那 直接不要想那么多 ，它 就是一个<strong>普通对象</strong>；你只需要记住: prototype 指 函数的原型对象，就如上述例子: <strong>Person.prototype 就是原型对象</strong></p><p>哦!对了，你还需要记住一个知识点:</p><blockquote><p>在默认情况下，所有的<strong>原型对象</strong>都会<strong>自动获得</strong>一个 <code>constructor</code>（构造函数）属性，这个属性（是一个指针）指向 <code>prototype</code> 属性所在的函数（Person）</p></blockquote><p>好像听不太懂的样子. - -!!!</p><p>没关系 ，翻译一下就是: <strong>Person.prototype</strong>  有一个 <code>constructor</code> 默认属性（自动获得）, 这个属性（<code>constructor</code>）指向了 Person ， 也就是:    <font color=red><code>Person.prototype.constructor == Person</code></font></p><p>到了这里 有没有突然反应过来什么?</p><p>在上面 讲<code>构造函数</code>的时候 ， 是不是讲过 <strong>实例的构造函数属性指向构造函数</strong>  ， 也就是 <font color=red><code>xiaoming.constructor === Person</code></font>；好像这样的话 它们之间是不是就会有点联系了啊???</p><p>是的!!!</p><p>控制台打印看看:</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name,age</span>)</span>&#123;    <span class="hljs-built_in">this</span>.name = name    <span class="hljs-built_in">this</span>.age = age    <span class="hljs-built_in">this</span>.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)    &#125;&#125;<span class="hljs-keyword">let</span> xiaoming = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小红&quot;</span>, <span class="hljs-number">18</span>)<span class="hljs-keyword">let</span> xiaohong = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)xiaohong.constructor == Person<span class="hljs-comment">// true</span>xiaoming.constructor == Person<span class="hljs-comment">// true</span>Person.prototype.constructor == xiaohong.constructor<span class="hljs-comment">// true</span>Person.prototype.constructor == xiaoming.constructor<span class="hljs-comment">// true</span></code></pre><p>但是为什么xiaoming 跟 xiaohong 会有 constructor 属性呢? 因为 他们是Person 的实例啊!!!</p><p>那Person.prototype 为什么也会有constructor属性呢? 因为他也是Person的实例啊!!!</p><p>其实就是 Person 在创建的时候 ，创建了一个它的实例并赋值给了它的prototype属性。</p><p><strong>结论：原型对象（Person.prototype）是 构造函数（Person）的一个实例。</strong></p><p>原型对象其实就是普通对象，但 <strong>Function.prototype</strong> 除外，它是函数对象，但它很<strong>特殊</strong>，他没有prototype属性。</p><p>看下实例: </p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<span class="hljs-built_in">console</span>.log(Person.prototype) <span class="hljs-comment">//Person&#123;&#125;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> Person.prototype) <span class="hljs-comment">//Object</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Function</span>.prototype) <span class="hljs-comment">// Function，这个特殊</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.prototype) <span class="hljs-comment">// Object</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Function</span>.prototype.prototype) <span class="hljs-comment">//undefined</span></code></pre><p><code>Function.prototype</code> 为什么是函数对象呢？</p><p>  上面提到过 <font color=red>凡是通过 <strong>new Function</strong> 创建的对象都是函数对象 ， 其他的都是普通对象。</font></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;  <span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>();  <span class="hljs-built_in">Function</span>.prototype = temp; <span class="hljs-comment">//由new Function()产生的对象都是函数对象  </span></code></pre><p>那原型对象是用来做什么的呢？</p><p>主要作用是用于继承。</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Person = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123;<span class="hljs-built_in">this</span>.name = name; <span class="hljs-comment">// tip: 当函数执行时这个 this 指的是谁？</span>&#125;;Person.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;  <span class="hljs-comment">// tip: 当函数执行时这个 this 指的是谁？</span>&#125;<span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;xing&#x27;</span>);person1.getName(); <span class="hljs-comment">//xing</span></code></pre><p>从这个例子可以看出，通过给 <code>Person.prototype</code> 设置了一个函数对象的属性，那有 Person 的实例（person1）出来的普通对象就继承了这个属性，而这个 this 两次都是指向了 person1</p><h4 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h4><p>JavaScript 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做<code>__proto__</code> 的内置属性，用于指向创建它的构造函数的原型对象。 </p><blockquote><p>记住:</p><p>​        最普通的对象: 有__proto__属性（指向其原型链），没有prototype属性。 </p><p>​        原型对象： 有__proto__属性 , 还有constructor属性（指向构造函数对象）)</p><p>​        函数对象： 拥有__proto__、prototype属性（指向原型对象 , 凡是通过new Function()创建的都是函数对象）。</p></blockquote><p>对象 person1 有一个 <code>__proto__</code>属性，创建它的构造函数是 Person，构造函数的原型对象是 Person.prototype ，所以： <code>person1.__proto__ == Person.prototype</code></p><p>贴一张《JavaScript 高级程序设计》的图:</p><p><img src="/images/WX20200320-193040@2x.png"></p><p>根据上面这个连接图，我们能得到：</p><pre><code class="hljs javascript">Person.prototype.constructor == Person;person1.__proto__ == Person.prototype;person1.constructor == Person;</code></pre><blockquote><p>不过要明确一点重要信息就是，这个链接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。</p></blockquote><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>熟悉 JavaScript的同学都知道，创建一个对象我们可以使用字面量的方式来创建一个对象，例如: </p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;</code></pre><p>它等同于：</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()</code></pre><p>那么 obj 就是 Object的一个实例 ，所以:</p><pre><code class="hljs javascript">obj.constructor === <span class="hljs-built_in">Object</span>obj.__proto__ === <span class="hljs-built_in">Object</span>.prototype</code></pre><p>同理，可以创建对象的构造器不仅仅有 Object，也可以是 Array，Date，Function等。<br>所以我们也可以构造函数来创建 Array、 Date、Function</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();b.constructor === <span class="hljs-built_in">Array</span>;b.__proto__ === <span class="hljs-built_in">Array</span>.prototype;<span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); c.constructor === <span class="hljs-built_in">Date</span>;c.__proto__ === <span class="hljs-built_in">Date</span>.prototype;<span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>();d.constructor === <span class="hljs-built_in">Function</span>;d.__proto__ === <span class="hljs-built_in">Function</span>.prototype;</code></pre><p><strong>这些构造器都是函数对象：</strong></p><p><img src="/img/WX20200322-153422@2x.png" alt="函数对象"></p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><ul><li>什么是原型链呢?</li></ul><pre><code class="hljs javascript">原型链的核心就是依赖对象的_proto_的指向，当自身不存在的属性时，就一层层的扒出创建对象的构造函数，直至到<span class="hljs-built_in">Object</span>时，就没有_proto_指向了。</code></pre><ul><li>分析原型链（属性查找）</li></ul><pre><code class="hljs javascript">因为_proto_实质找的是prototype，所以我们只要找这个链条上的构造函数的prototype。其中<span class="hljs-built_in">Object</span>.prototype是没有_proto_属性的，它==<span class="hljs-literal">null</span>。</code></pre><p>练习题：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>)</span>&#123;  <span class="hljs-built_in">this</span>.name = name&#125;<span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;xing&quot;</span>)题目一： person1.__proto__ 是什么？题目二： Person.__proto__ 是什么？题目三： Person.prototype.__proto__ 是什么？题目四： <span class="hljs-built_in">Object</span>.__proto__ 是什么？题目五： <span class="hljs-built_in">Object</span>.prototype.__proto__ 是什么？</code></pre><p>题目一：</p><pre><code class="hljs javascript">person1.__proto__ === Person.prototype <span class="hljs-comment">// 实例的__proto__ 指向 实例的构造函数的prototype ，结果为true</span></code></pre><p>题目二：</p><pre><code class="hljs javascript">Person.__proto__ === <span class="hljs-built_in">Function</span>.prototype <span class="hljs-comment">// Person 的 __proto__ 指向 创建它的构造函数的prototype ，结果为true</span></code></pre><p>题目三：</p><pre><code class="hljs javascript">Person.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype <span class="hljs-comment">// 记住： 原型对象其实就是普通对象，那么它的构造函数肯定就是 Object.prototype</span></code></pre><p>题目四：</p><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype <span class="hljs-comment">// 跟题目二是一样的， Object 其实也是构造函数</span></code></pre><p>题目五：</p><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.__proto__ === <span class="hljs-literal">null</span> <span class="hljs-comment">// Object.prototype 对象也有proto属性，但它比较特殊，为 null 。因为 null 处于原型链的顶端，这个只能记住。</span></code></pre><h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><h5 id="所有函数对象的proto都指向Function-prototype，它是一个空函数（Empty-function）"><a href="#所有函数对象的proto都指向Function-prototype，它是一个空函数（Empty-function）" class="headerlink" title="所有函数对象的proto都指向Function.prototype，它是一个空函数（Empty function）"></a>所有<em>函数对象</em>的<strong>proto</strong>都指向Function.prototype，它是一个空函数（Empty function）</h5><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype  <span class="hljs-comment">// true</span><span class="hljs-built_in">Number</span>.constructor == <span class="hljs-built_in">Function</span> <span class="hljs-comment">//true</span><span class="hljs-built_in">Boolean</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype <span class="hljs-comment">// true</span><span class="hljs-built_in">Boolean</span>.constructor == <span class="hljs-built_in">Function</span> <span class="hljs-comment">//true</span><span class="hljs-built_in">String</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype  <span class="hljs-comment">// true</span><span class="hljs-built_in">String</span>.constructor == <span class="hljs-built_in">Function</span> <span class="hljs-comment">//true</span><span class="hljs-comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span><span class="hljs-built_in">Object</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype  <span class="hljs-comment">// true</span><span class="hljs-built_in">Object</span>.constructor == <span class="hljs-built_in">Function</span> <span class="hljs-comment">// true</span><span class="hljs-comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span><span class="hljs-built_in">Function</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype <span class="hljs-comment">// true</span><span class="hljs-built_in">Function</span>.constructor == <span class="hljs-built_in">Function</span> <span class="hljs-comment">//true</span><span class="hljs-built_in">Array</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype   <span class="hljs-comment">// true</span><span class="hljs-built_in">Array</span>.constructor == <span class="hljs-built_in">Function</span> <span class="hljs-comment">//true</span><span class="hljs-built_in">RegExp</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype  <span class="hljs-comment">// true</span><span class="hljs-built_in">RegExp</span>.constructor == <span class="hljs-built_in">Function</span> <span class="hljs-comment">//true</span><span class="hljs-built_in">Error</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype   <span class="hljs-comment">// true</span><span class="hljs-built_in">Error</span>.constructor == <span class="hljs-built_in">Function</span> <span class="hljs-comment">//true</span><span class="hljs-built_in">Date</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype    <span class="hljs-comment">// true</span><span class="hljs-built_in">Date</span>.constructor == <span class="hljs-built_in">Function</span> <span class="hljs-comment">//true</span></code></pre><p>JavaScript中有内置(build-in)构造器/对象共计12个（ES5中新加了JSON），这里列举了可访问的8个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。它们的<strong>proto</strong>是Object.prototype。如下：</p><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.__proto__ === <span class="hljs-built_in">Object</span>.prototype  <span class="hljs-comment">// true</span><span class="hljs-built_in">Math</span>.construrctor == <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><span class="hljs-built_in">JSON</span>.__proto__ === <span class="hljs-built_in">Object</span>.prototype  <span class="hljs-comment">// true</span><span class="hljs-built_in">JSON</span>.construrctor == <span class="hljs-built_in">Object</span> <span class="hljs-comment">//true</span></code></pre><p>上面说的<strong>函数对象</strong>当然包括自定义的。如下:</p><pre><code class="hljs javascript"><span class="hljs-comment">// 函数声明</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-comment">// 函数表达式</span><span class="hljs-keyword">var</span> Perosn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-built_in">console</span>.log(Person.__proto__ === <span class="hljs-built_in">Function</span>.prototype) <span class="hljs-comment">// true</span></code></pre><blockquote><p>所有的构造器都来自于 <code>Function.prototype</code>，甚至包括根构造器<code>Object</code>及<code>Function</code>自身。所有构造器都继承了Function.prototype 的属性及方法。如length、call、apply、bind</p></blockquote><p>除了 <code>Function.prototype</code> 既是对象又是函数对象之外，其它的构造器的<code>prototype</code>都是一个对象:</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Function</span>.prototype) <span class="hljs-comment">// function</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.prototype)   <span class="hljs-comment">// object</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Number</span>.prototype)   <span class="hljs-comment">// object</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Boolean</span>.prototype)  <span class="hljs-comment">// object</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">String</span>.prototype)   <span class="hljs-comment">// object</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Array</span>.prototype)    <span class="hljs-comment">// object</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">RegExp</span>.prototype)   <span class="hljs-comment">// object</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Error</span>.prototype)    <span class="hljs-comment">// object</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Date</span>.prototype)     <span class="hljs-comment">// object</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.prototype)   <span class="hljs-comment">// object</span></code></pre><p>上面提到 <code>Function.prototype    </code>是一个空的函数 ， 你可以试着打印看看这个空函数:</p><p><code>console.log(Function.prototype)</code></p><p>知道了所有构造器（含内置及自定义）的<code>__proto__</code>都是<code>Function.prototype</code>，那<code>Function.prototype</code>的<code>__proto__</code>是谁呢？</p><p>相信都听说过JavaScript中函数也是一等公民，那从哪能体现呢？如下:</p><p><code>console.log(Function.prototype.__proto__ === Object.prototype) // true</code></p><p>这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。</p><p>最后Object.prototype的<strong>proto</strong>是谁？<br><code>Object.prototype.__proto__ === null // true</code></p><p><code>Object.prototype</code>的原型是<code>null</code>，<code>null</code>指空对象。世界上最难的事情是从0生出1，无中生出有，<code>Object.prototype</code>就是照着<code>null</code>的样子创造了1。</p><h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><blockquote><p>在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 <code>prototype</code> 属性了。对于 ECMAScript 中的引用类型而言，<code>prototype</code> 是保存着它们所有实例方法的真正所在。换句话所说，诸如 <code>toString()</code>和 <code>valuseOf()</code> 等方法实际上都保存在 <code>prototype</code> 名下，只不过是通过各自对象的实例访问罢了</p><p>— 《JavaScript 高级程序设计》第三版 P116</p></blockquote><p>我们知道 JS 内置了一些方法供我们使用，比如：</p><pre><code class="hljs delphi">对象可以用 <span class="hljs-function"><span class="hljs-keyword">constructor</span>/<span class="hljs-title">toString</span><span class="hljs-params">()</span>/<span class="hljs-title">valueOf</span><span class="hljs-params">()</span> 等方法;</span>数组可以用 map()/filter()/reducer() 等方法；数字可以用 parseInt()/parseFloat()等方法;</code></pre><p>当我们创建一个对象时:</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> Person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<span class="hljs-comment">// Person 是 Object 的实例，所以 Person 继承了Object 的原型对象Object.prototype上所有的方法：</span><span class="hljs-built_in">console</span>.dir(<span class="hljs-built_in">Object</span>.prototype) <span class="hljs-comment">// Object.prototype 其实就是一个普通对象</span><span class="hljs-comment">/**</span><span class="hljs-comment">  Object</span><span class="hljs-comment">  constructor: ƒ Object()</span><span class="hljs-comment">  __defineGetter__: ƒ __defineGetter__()</span><span class="hljs-comment">  __defineSetter__: ƒ __defineSetter__()</span><span class="hljs-comment">  hasOwnProperty: ƒ hasOwnProperty()</span><span class="hljs-comment">  __lookupGetter__: ƒ __lookupGetter__()</span><span class="hljs-comment">  __lookupSetter__: ƒ __lookupSetter__()</span><span class="hljs-comment">  isPrototypeOf: ƒ isPrototypeOf()</span><span class="hljs-comment">  propertyIsEnumerable: ƒ propertyIsEnumerable()</span><span class="hljs-comment">  toString: ƒ toString()</span><span class="hljs-comment">  valueOf: ƒ valueOf()</span><span class="hljs-comment">  toLocaleString: ƒ toLocaleString()</span><span class="hljs-comment">  get __proto__: ƒ __proto__()</span><span class="hljs-comment">  set __proto__: ƒ __proto__()</span><span class="hljs-comment">*/</span></code></pre><p><strong>Object 的每个实例都具有以上的属性和方法。</strong><br>所以我可以用 <code>Person.constructor</code> 也可以用 <code>Person.hasOwnProperty</code>。</p><p>当我们创建一个数组时：</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>()<span class="hljs-comment">// num 是 Array 的实例，所以 num 继承了Array 的原型对象Array.prototype上所有的方法：</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.prototype)<span class="hljs-comment">/**</span><span class="hljs-comment">[constructor: ƒ, concat: ƒ, copyWithin: ƒ, fill: ƒ, find: ƒ, …]</span><span class="hljs-comment">  length: 0</span><span class="hljs-comment">  constructor: ƒ Array()</span><span class="hljs-comment">  concat: ƒ concat()</span><span class="hljs-comment">  copyWithin: ƒ copyWithin()</span><span class="hljs-comment">  fill: ƒ fill()</span><span class="hljs-comment">  find: ƒ find()</span><span class="hljs-comment">  findIndex: ƒ findIndex()</span><span class="hljs-comment">  lastIndexOf: ƒ lastIndexOf()</span><span class="hljs-comment">  pop: ƒ pop()</span><span class="hljs-comment">  push: ƒ push()</span><span class="hljs-comment">  reverse: ƒ reverse()</span><span class="hljs-comment">  shift: ƒ shift()</span><span class="hljs-comment">  unshift: ƒ unshift()</span><span class="hljs-comment">  slice: ƒ slice()</span><span class="hljs-comment">  sort: ƒ sort()</span><span class="hljs-comment">  splice: ƒ splice()</span><span class="hljs-comment">  includes: ƒ includes()</span><span class="hljs-comment">  indexOf: ƒ indexOf()</span><span class="hljs-comment">  join: ƒ join()</span><span class="hljs-comment">  keys: ƒ keys()</span><span class="hljs-comment">  entries: ƒ entries()</span><span class="hljs-comment">  values: ƒ values()</span><span class="hljs-comment">  forEach: ƒ forEach()</span><span class="hljs-comment">  filter: ƒ filter()</span><span class="hljs-comment">  flat: ƒ flat()</span><span class="hljs-comment">  flatMap: ƒ flatMap()</span><span class="hljs-comment">  map: ƒ map()</span><span class="hljs-comment">  every: ƒ every()</span><span class="hljs-comment">  some: ƒ some()</span><span class="hljs-comment">  reduce: ƒ reduce()</span><span class="hljs-comment">  reduceRight: ƒ reduceRight()</span><span class="hljs-comment">  toLocaleString: ƒ toLocaleString()</span><span class="hljs-comment">  toString: ƒ toString()</span><span class="hljs-comment">  Symbol(Symbol.iterator): ƒ values()</span><span class="hljs-comment">  Symbol(Symbol.unscopables): &#123;copyWithin: true, entries: true, fill: true, find: true, findIndex: true, …&#125;</span><span class="hljs-comment">  __proto__: Object</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span></code></pre><p>这样你就明白了随便声明一个数组，它为啥能用那么多方法了。</p><p>并且它的原型链（__proto__）中还有对象的方法。</p><p>当我们创建一个函数时：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&quot;xing&quot;</span>,<span class="hljs-string">&quot;return xing;&quot;</span>); <span class="hljs-comment">//当然你也可以这么创建 f = function(x)&#123; return x &#125;</span><span class="hljs-built_in">console</span>.log(f.arguments) <span class="hljs-comment">// arguments 方法从哪里来的？</span><span class="hljs-built_in">console</span>.log(f.call(<span class="hljs-built_in">window</span>)) <span class="hljs-comment">// call 方法从哪里来的？</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span>.prototype) <span class="hljs-comment">// function() &#123;&#125; （一个空的函数）</span><span class="hljs-built_in">console</span>.dir(<span class="hljs-built_in">Function</span>.prototype);</code></pre><p>疑问来了，我们之前说过:</p><blockquote><p>所有<strong>函数对象</strong>proto都指向 <code>Function.prototype</code>，它是一个空函数（Empty function）</p></blockquote><p>嗯！ 我们确实证明了它就是一个空函数，但是你也别忘了我们之前说过的:</p><pre><code class="hljs javascript">所有对象的 __proto__ 都指向其构造器的 prototype</code></pre><p>我们下面再复习下这句话。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 先看看 JS 内置构造器：</span><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xing&#x27;</span>&#125;<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/hello/g</span><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span><span class="hljs-keyword">var</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;err&#x27;</span>) <span class="hljs-built_in">console</span>.log(obj.__proto__ === <span class="hljs-built_in">Object</span>.prototype) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(arr.__proto__ === <span class="hljs-built_in">Array</span>.prototype)  <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(reg.__proto__ === <span class="hljs-built_in">RegExp</span>.prototype) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(date.__proto__ === <span class="hljs-built_in">Date</span>.prototype)  <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(err.__proto__ === <span class="hljs-built_in">Error</span>.prototype)  <span class="hljs-comment">// true</span></code></pre><p>再看看自定义的构造器，这里定义了一个 <code>Person</code>：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;  <span class="hljs-built_in">this</span>.name = name;&#125;<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;xing&#x27;</span>)<span class="hljs-built_in">console</span>.log(p.__proto__ === Person.prototype) <span class="hljs-comment">// true</span></code></pre><p><code>p</code> 是 <code>Person</code> 的实例对象，<code>p</code> 的内部原型总是指向其构造器 <code>Person</code> 的原型对象 <code>prototype</code>。</p><p>每个对象都有一个 <code>constructor</code> 属性，可以获取它的构造器，因此以下打印结果也是恒等的：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = name&#125;<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;xing&#x27;</span>)<span class="hljs-built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="hljs-comment">// true</span></code></pre><p>上面的<code>Person</code>没有给其原型添加属性或方法，这里给其原型添加一个<code>getName</code>方法：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = name&#125;<span class="hljs-comment">// 修改原型</span>Person.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;xing&#x27;</span>)<span class="hljs-built_in">console</span>.log(p.__proto__ === Person.prototype) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="hljs-comment">// true</span></code></pre><p>可以看到<code>p.__proto__</code>与<code>Person.prototype</code>，<code>p.constructor.prototype</code>都是恒等的，即都指向同一个对象。</p><p>注意：如果换一种方式设置原型，结果就有些不同了。</p><blockquote><pre><code class="hljs javascript">&gt;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;   <span class="hljs-built_in">this</span>.name = name&gt;&#125;&gt;<span class="hljs-comment">// 重写原型</span>&gt;Person.prototype = &#123;   getName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;&gt;&#125;&gt;<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;xing&#x27;</span>)&gt;<span class="hljs-built_in">console</span>.log(p.__proto__ === Person.prototype) <span class="hljs-comment">// true</span>&gt;<span class="hljs-built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="hljs-comment">// false</span></code></pre></blockquote><p>这里直接重写了 <code>Person.prototype</code>（注意：上一个示例是修改原型）。输出结果可以看出<code>p.__proto__</code>仍然指向的是<code>Person.prototype</code>，而不是<code>p.constructor.prototype</code>。</p><p>这也很好理解，给<code>Person.prototype</code>赋值的是一个对象直接量<code>&#123;getName: function()&#123;&#125;&#125;</code>，使用对象直接量方式定义的对象其构造器（<code>constructor</code>）指向的是根构造器<code>Object</code>，<code>Object.prototype</code>是一个空对象<code>&#123;&#125;</code>，<code>&#123;&#125;</code>自然与<code>&#123;getName: function()&#123;&#125;&#125;</code>不等。如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> p = &#123;&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype) <span class="hljs-comment">// 为一个空的对象&#123;&#125;</span><span class="hljs-built_in">console</span>.log(p.constructor === <span class="hljs-built_in">Object</span>) <span class="hljs-comment">// 对象直接量方式定义的对象其constructor为Object</span><span class="hljs-built_in">console</span>.log(p.constructor.prototype === <span class="hljs-built_in">Object</span>.prototype) <span class="hljs-comment">// 为true</span></code></pre><h4 id="复习原型链"><a href="#复习原型链" class="headerlink" title="复习原型链"></a>复习原型链</h4><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person();<span class="hljs-built_in">console</span>.log(person1.__proto__ === Person.prototype); <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(Person.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype) <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.__proto__) <span class="hljs-comment">//null</span>Person.__proto__ == <span class="hljs-built_in">Function</span>.prototype; <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span>.prototype)<span class="hljs-comment">// function()&#123;&#125; (空函数)</span><span class="hljs-keyword">var</span> num = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>()<span class="hljs-built_in">console</span>.log(num.__proto__ == <span class="hljs-built_in">Array</span>.prototype) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">Array</span>.prototype.__proto__ == <span class="hljs-built_in">Object</span>.prototype) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.prototype) <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.__proto__) <span class="hljs-comment">//null</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.__proto__ == <span class="hljs-built_in">Function</span>.prototype)<span class="hljs-comment">// true</span></code></pre><p>疑问一：</p><pre><code class="hljs coffeescript"><span class="hljs-built_in">Object</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype <span class="hljs-regexp">//</span> <span class="hljs-literal">true</span><span class="hljs-regexp">//</span> <span class="hljs-built_in">Object</span> 是函数对象，是通过<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>()创建的，所以<span class="hljs-built_in">Object</span>.__proto__指向<span class="hljs-built_in">Function</span>.prototype。(所有函数对象的__proto__都指向<span class="hljs-built_in">Function</span>.prototype)</code></pre><p>疑问点二：</p><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype <span class="hljs-comment">// true</span><span class="hljs-comment">// Function 也是对象函数，也是通过new Function()创建，所以Function.__proto__指向Function.prototype。</span></code></pre><blockquote><p>自己是由自己创建的，好像不符合逻辑，但仔细想想，现实世界也有些类似，你是怎么来的，你妈生的，你妈怎么来的，你姥姥生的，……类人猿进化来的，那类人猿从哪来，一直追溯下去……，就是无，（NULL生万物）<br>正如《道德经》里所说“无，名天地之始”。</p></blockquote><p>疑问点三：</p><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype <span class="hljs-comment">//true</span><span class="hljs-comment">// Function.prototype是个函数对象，理论上他的__proto__应该指向 Function.prototype，就是他自己，自己指向自己，没有意义。这里 鸡生蛋还是蛋生鸡 ? Object.prototype 可以看作是对象的祖先 ， Object 是有 Function （包括它自己）创建出来的，但是 Function 作为一个对象 又可以看作是由Object创建出来的。所以 Object 就当成了祖宗 ， 原型链也就有了终点。</span></code></pre><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul><li>原型和原型链是JS实现继承的一种模型。</li><li>原型链的形成靠的是<code>__proto__</code> 而非<code>prototype</code>，正如我们之前说的那句话，实例和 原型对象 存在一个连接；不过要明确一点重要信息就是，这个链接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。</li></ul><p><img src="/images/js.png"></p><p>最后献上一张原型链图，相信阅读完后的你看这张图会有一定的清晰度了.</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原型与原型链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习备忘录</title>
    <link href="/articles/2020/09/01/Git%E5%AD%A6%E4%B9%A0%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <url>/articles/2020/09/01/Git%E5%AD%A6%E4%B9%A0%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="git-是目前最火的版本控制工具下面我们来学习下如何使用它"><a href="#git-是目前最火的版本控制工具下面我们来学习下如何使用它" class="headerlink" title="git 是目前最火的版本控制工具下面我们来学习下如何使用它"></a>git 是目前最火的版本控制工具下面我们来学习下如何使用它</h2><h3 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h3><ol><li><p>创建新的文件夹, 在该文件夹下打开终端,执行命令创建新的 git 仓库:</p><pre><code> git init</code></pre><p>   执行命令后,会在当前文件夹下出现一个隐藏的<code>.git</code>文件夹,这个目录是 Git 来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把 Git 仓库给破坏了。</p><pre><code> 一般我们在公司除非让你新建一个新的项目，否则这一步我们基本都不用操作。</code></pre></li><li><p>现在我们通过<code>git init</code> 初始化本地的仓库了,接下来我们便来问这个文件夹添加点内容。</p><ul><li><p>新建一个文件，给这个文件简单的写点东西。</p></li><li><p>保存你编写的文件，然后执行命令：</p><pre><code>git add &lt;file&gt;  // file 代表你刚刚创建的文件名称</code></pre></li><li><p>接着执行命令：</p><pre><code>git commit -m &#39;备注信息&#39;</code></pre></li></ul></li></ol><p>接下来我为你一一解释下这些命令的意思是什么：</p><pre><code>git add &lt;文件&gt; // git add 是把你刚刚所编写的内容提交到git 暂存区当中去。git commit -m &#39;备注&#39; // 这个命令是把你刚刚做了什么事情备注下，并提交到本地的版本库当中。</code></pre><h4 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结 - 1"></a>小总结 - 1</h4><ul><li><code>git init</code> 是初始化仓库，一般用于刚创建项目的时候用 git 来管理版本</li><li><code>git add &lt;file&gt;</code> 是把文件添加到暂存区</li><li><code>git commit -m &#39;备注&#39;</code> 是把你刚刚所做的事情记录一下并把它们提交到本地仓库中。</li></ul><hr><h3 id="git-工作流"><a href="#git-工作流" class="headerlink" title="git 工作流"></a>git 工作流</h3><ol><li><p>接下来我们来讲讲<code>git</code>的工作流，希望能够让大家更清晰的知道<code>git</code>到底是怎么工作的,你的本地仓库是由<code>git</code>维护的 “三棵树” 组成:</p><ul><li>第一个是你的 <strong>工作区</strong> , 也就是你当前所操作的所有本地文件或者文件夹。</li><li>第二个是 <strong>暂存区（index）</strong> ,它像个缓存区域，临时保存你的文件改动 , 记住这句话对你的理解会很有帮助的, git 其实保存的是你的修改而不是文件。</li><li>最后是 <strong>HEAD</strong> , 它指向你最后一次提交的结果。</li></ul></li><li><p>接下来我们来解释下这 <strong>三棵树</strong> 到底指的是什么:</p><ul><li>“第一颗树”:<br>  工作区： 这个应该好理解吧，说白了就是你的项目，这个存放项目的整个文件夹就是你工作的地方，这整个文件夹就被称作为<code>工作区</code></li><li>“第二颗树”:<br>  暂存区： 嗯~ o(<em>￣ ▽ ￣</em>)o ，让我想想这个该怎么来跟你解释呢？ <code>.git</code>文件夹上面我们讲过对吧，这个 <code>.git</code> 文件夹其实就是我们的本地版本库，它里面存放了很多的东西，其中有一个最最重要的就是成为 <code>stage</code>的暂存区，再有一个就是分支和指针 HEAD ，这个我们稍后再说。 这个暂存区你可以理解为存放的都是所有准备提交的文件，那这些文件是从哪里来的呢？其实就是通过 <code>git add &lt;file&gt;</code> 添加进去的。</li><li>“第三颗树”:<br>  HEAD： 这个 HEAD 我们可以简单粗暴的理解为当前版本，我们通过<code>git add &lt;file&gt;</code>把更改过的文件提交到了暂存区，然后我们接着执行命令<code>git commit -m &#39;备注&#39;</code>把缓存区的代码提交到当前分支，如果我们没有创建分支默认就是 master，而这个 HEAD 指向的就是我们这个分支的。</li></ul></li></ol><h4 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结 - 2"></a>小总结 - 2</h4><ul><li>git 跟踪的并不是文件，而是修改。</li><li>git 有三颗树， 工作区 -&gt; 暂存区 -&gt; 本地仓库</li><li>可以把他们想象成两大部分， 一个是工作区域，一个是版本库区域，我们在工作区域做的工作通过<code>git add</code> 提交到版本库中的缓存区(index) ， 你可以把所有的修改都先提交到缓存区然后再通过<code>git commit</code> 一次性提交到分支，而 HEAD 是一个指针，它指向的是你当前的版本库</li></ul><hr><h3 id="git-管理修改"><a href="#git-管理修改" class="headerlink" title="git 管理修改"></a>git 管理修改</h3><p>有添加就有修改，接下来我们来看看如何修改版本库中的文件。</p><ol><li>当我们把第一次修改的文件使用命令<code>git add</code>提交到暂存区后，我们再此修改该文件，然后保存，之后使用命令<code>git commit</code>把文件提交到本地仓库，这个时候你可以使用<code>git diff HEAD -- &lt;file&gt;</code>查看文件，你会发现第一次提交的内容是到了仓库的，但是第二次提交却没有，这是为什么呢？ 其实很简单，因为你第一次提交的时候你使用了<code>git add</code>，但是第二次你并没有使用这个命令，所以它并没有被提交到暂存区，所以啊，这个时候你想要把第二次提交也提交到仓库中就必须把第二次的修改也提交到暂存区，然后再执行<code>git commit</code> ,这样就可以修改文件了。</li><li>永远不要忘了，git 跟踪的是你对文件的修改而不是文件，所以，你可以每次修改后都提交到缓存区，然后一次性把所有修改都提交到仓库中。</li></ol><h4 id="小总结-3"><a href="#小总结-3" class="headerlink" title="小总结 - 3"></a>小总结 - 3</h4><ul><li>每次修改，如果不用<code>git add</code>提交到暂存区，那么<code>git commit</code>的时候是不会包含进去的哦。</li><li>git 跟踪的是你的修改.</li></ul><hr><h3 id="git-撤销修改"><a href="#git-撤销修改" class="headerlink" title="git 撤销修改"></a>git 撤销修改</h3><p>我们在工作中难免会出现错误，当我们出现错误的时候，如果及时发现可以立马在工作区中修改删除掉它，但是如果已经提交到了暂存区或者仓库中，怎么办呢？</p><h4 id="丢弃工作区的修改"><a href="#丢弃工作区的修改" class="headerlink" title="丢弃工作区的修改"></a>丢弃工作区的修改</h4><ul><li><p><code>git checkout -- &lt;file&gt;</code> 可以帮助你在工作区的修改全部撤销掉，不过这里有两种情况哦： - 1. 一种是文件自然修改后<strong>还没有被放到缓存区</strong>中，那么，撤销修改就回到了和<strong>版本库</strong>一摸一样的状态 - 2. 一种是文件<strong>已经被提交到了缓存区</strong>中，又作了修改，那么，撤销修改就回到了添加到<strong>缓存区</strong>后的状态，也就是你已经提交的内容还会回来，但是没有提交的内容就不见了哦。  </p><blockquote><p>总之就是让这个文件回到<code>git add</code> 或者 <code>git commit</code>时的状态。<br>注意上面的命令 – 很重要哦， 如果没有了就是切换分支了。</p></blockquote></li></ul><h4 id="丢弃暂存区的修改"><a href="#丢弃暂存区的修改" class="headerlink" title="丢弃暂存区的修改"></a>丢弃暂存区的修改</h4><ul><li>假如你把这些错误的内容提交到了暂存区中，也就是使用了<code>git add</code>后 ， 你可以使用命令 <code>git reset HEAD &lt;file&gt;</code> 把暂存区中的修改撤销掉重新回到工作区中， <code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区中。 HEAD 表示最新的版本。</li></ul><h4 id="丢弃仓库中的修改（版本回退与重返）"><a href="#丢弃仓库中的修改（版本回退与重返）" class="headerlink" title="丢弃仓库中的修改（版本回退与重返）"></a>丢弃仓库中的修改（版本回退与重返）</h4><ul><li><p>这个其实就是版本回退的问题了，因为你已经把文件提交到了仓库中；使用命令<code>git reset</code>命令，是不是很熟悉，上面已经介绍过这个命令了，接下来我们来看看如何实现版本回退。</p><ul><li>想要实现版本回退你必须要知道你提交的<code>commit id</code> ，这个 ID 是你每次提交版本库的时候，git 自动生成的，那么如何获取这个 ID 号呢？</li><li>使用命令<code>git log</code>可以查看提交的版本 ID 号，你会发现控制台输出了很多的东西，眼花缭乱，你可以给这个命令加个参数<code>git log --pretty=oneline</code>参数，这样控制台就会清爽很多的输出<code>commit id</code>了。</li><li>获取到了<code>commit id</code>之后记住它或者直接复制，然后控制台输入命令<code>git reset --hard &lt;commit id&gt;</code> ， 这样就会回到这个<code>commit id</code>的版本内容了; 如果你想要回到上一个版本或者上上个版本，可以不用找 ID , 直接控制台输入 <code>git reset --hard HEAD^</code> ; HEAD 我们说过，它指向的是我们当前的版本，而 ^ 符号是指上一个版本， ^^ 是上上个版本， 如果要回到 100 个版本你可以输入 100 个^ ； 哈哈，开玩笑， git 贴心的提供了 <code>git reset --hard HEAD~100</code></li><li>如果你回退之后后悔了怎么办？？？ 这个时候你在打印 log 日志是找不到你回退之前的那个版本号了，我的天，是不是完蛋了，NO!!! git 给我们提供了后悔药，你就算是第二天醒来后悔了都没得问题， 输入命令<code>git reflog</code>命令，你就会发现，你回退之前的 ID 号也在这里出现了，既然找到了 ID 号，那相信小伙伴们也知道该如何做了啊。</li></ul></li></ul><h4 id="小总结-4"><a href="#小总结-4" class="headerlink" title="小总结 - 4"></a>小总结 - 4</h4><ul><li>HEAD 指向的版本就是当前版本，因此，git 允许我们在版本的历史之间穿梭，使用命令 <code>git reset --hard &lt;commit id&gt;</code></li><li>回退前，使用<code>git log</code> 可以查看提交的历史，以便我们确定要回退到哪个版本中。</li><li>重返未来， 使用 <code>git reflog</code> 查看命令历史，这个命令记录了我们每一次的命令。</li></ul><hr><h3 id="git-删除文件"><a href="#git-删除文件" class="headerlink" title="git 删除文件"></a>git 删除文件</h3><ul><li>删除其实也可以理解为是对文件的修改，你可以直接在文件管理器中删除文件或者使用命令<code>rm</code>删除。</li><li>你只要一删除文件，git 就知道。因此工作区和版本库就不一致了，所以你有两个选择，第一就是你确实要删除该文件，并且执行命令 <code>git commit</code>； 第二个就是删除文件了，那你可以使用命令<code>git checkout -- &lt;file&gt;</code>, 或者直接区垃圾回收站把文件给恢复过来</li><li>这里给大家提醒个事情，我的建议是如果大家误删除了文件，这个文件有新添加的内容在里面并没有提交到版本库中，那么我建议还是直接去系统的垃圾箱里面恢复文件，这样那些没有提交到版本库中的内容是还存在的，但是如果你是通过返回之前的版本库或者 vscode 的撤销操作来恢复文件的话，哪些没有被添加到版本库中的内容是不会存在在文件中哦!!!</li></ul><h4 id="小总结-5"><a href="#小总结-5" class="headerlink" title="小总结 - 5"></a>小总结 - 5</h4><ul><li>从来没有被添加到版本库中就被删除的文件是无法恢复的哦!!!</li><li>如果一个文件已经被提交到版本库中，那么你就永远不用担心被误删，但是要小心的是，你恢复的文件是最新被提交到版本库中的，你会丢失掉最后一次修改后的所有内容。</li></ul><hr><h3 id="git-添加远程仓库"><a href="#git-添加远程仓库" class="headerlink" title="git 添加远程仓库"></a>git 添加远程仓库</h3><p>添加到远程仓库有两种情况，一种是你还没有创建本地仓库，一种是你创建了本地仓库。</p><h4 id="还没有创建本地仓库"><a href="#还没有创建本地仓库" class="headerlink" title="还没有创建本地仓库"></a>还没有创建本地仓库</h4><p>如果你还没有创建本地仓库，那么你可以先去码云或者 GitHub 上面先创建一个远端仓库，然后把地址复制下来，使用命令<code>git clone &lt;远程仓库地址&gt;</code>,把项目给克隆下来，然后进行文件的修改，并提交到版本库当中去，最后使用命令<code>git push -u origin master</code>就可以了，如果是第一次 clone 项目，会让你输入账号密码，这个账号密码就是你登录仓库的账号和密码。</p><h4 id="创建了本地仓库"><a href="#创建了本地仓库" class="headerlink" title="创建了本地仓库"></a>创建了本地仓库</h4><p>如果你创建了本地仓库，那么也是把地址复制下来，然后在你现有的本地仓库中打开终端输入命令<code>git git remote add origin &lt;远程仓库地址&gt;</code>,关联了远程仓库之后，要把本地仓库的文件提交到远程仓库中去，需要使用命令<code>git push -u origin master</code> 或者 <code>git push</code>之后再次输入命令<code>git push --set-upstream origin master</code>, 相信大家会疑惑 –set-upstream 是什么意思? 其实是因为你在执行命令 <code>git push</code> 的时候 git 不知道你要提交到哪里去，它会报一个错误，告诉你当前分支没有对应的上游分支，需要执行<code>git push --set-upstream origin master</code>。</p><h4 id="关联远程仓库后的注意事项"><a href="#关联远程仓库后的注意事项" class="headerlink" title="关联远程仓库后的注意事项"></a>关联远程仓库后的注意事项</h4><p>这种关联远程仓库的方法中还会出现一个问题，那就是 假如你创建的仓库并不是一无所有而是会有几个文件，比如 README.MD ， 那么你在提交本地仓库的代码的时候会报错，告诉你推送失败了，这是因为你远端的仓库跟本地的仓库不一致导致的，你需要跟远程的仓库保持一致，所以你要先拉一下远程的仓库到本地，使用命令<code>git pull --rebase origin master</code> , 这条指令的意思是把远程库中的更新合并到本地库中，–-rebase 的作用是取消掉本地库中刚刚的 commit，并把他们接到更新后的版本库之中,执行完毕之后就可以正常的 push 代码到远程仓库中了。</p><hr><h3 id="git-分支管理"><a href="#git-分支管理" class="headerlink" title="git 分支管理"></a>git 分支管理</h3><h4 id="1-分支的创建与合并"><a href="#1-分支的创建与合并" class="headerlink" title="1. 分支的创建与合并"></a>1. 分支的创建与合并</h4><ul><li>学习到了这里，相信大家都知道，git 在我们每一次提交的时候都会把它们串成一条线，这条线就是一个分支，而 HEAD 指向的是分支，分支则是指向了提交。<ul><li>刚开始，我们只有一条默认分支 master ，我们每一次的提交，master 都会往前进一步，这样随着你不断的提交 master 这条线会越来越长。</li><li>当我们创建一个新的分支的时候，例如名字叫做 dev，git 会新建一个指针叫做 dev，并且指向了 master 相同的提交，然后再把 HEAD 指向 dev，这样就表示当前分支在 dev 上面。</li><li>所以接下来你做的所有文件修改都将是在 dev 上进行的，dev 分支在你每次提交的时候都往前进一步，而 master 指针则一直不变停留在原地，最后 dev 这条线就会把 master 线抛在身后。</li><li>假如我们在 dev 分支上的工作结束了，你就可以把 dev 合并到 master 分支上面，所以这个时候你就需要把 HEAD 指针指向 master,然后直接让 master 指向 dev 就行了。</li></ul></li></ul><h5 id="1-1-分支的创建"><a href="#1-1-分支的创建" class="headerlink" title="1.1 分支的创建"></a>1.1 分支的创建</h5><ul><li>我们了解了分支的创建和合并，那么我们是如何使用命令来创建我们的新分支呢？使用命令<code>git chekcout -b &lt;branch&gt;</code>创建分支。</li><li>然后使用命令<code>git branch</code> 即可查看当前所在的本地分支是哪个了。</li></ul><h5 id="1-2-分支的合并"><a href="#1-2-分支的合并" class="headerlink" title="1.2 分支的合并"></a>1.2 分支的合并</h5><ul><li>接下来我们要合并分支，首先我们要切换到我们想要合并的分支上，比如 master 想要合并 dev ，那么就要先切换到 master 分支上，然后使用命令<code>git merge dev</code>；</li><li><code>git merge &lt;branch&gt;</code>命令用于合并指定分支到当前分支。</li><li>当你切换到 master 分支上的时候，由于 master 分支是落后于 dev 的，所以切换的时候你会发现在 dev 上的内容全都不见了，不过别慌，等你执行完 merge 命令后，你就能够看到 dev 上的内容也出现到了 master 分支了。</li><li>在这合并的时候有可能会出现冲突，假如出现冲突，你就要先解决完冲突之后再一次提交到版本库中去。</li></ul><h5 id="1-3-分支的创建（switch）"><a href="#1-3-分支的创建（switch）" class="headerlink" title="1.3 分支的创建（switch）"></a>1.3 分支的创建（switch）</h5><ul><li>最新版本的 git 提供了另一种切换分支的命令： <code>git switch</code></li><li>切换并创建到新的 dev 分支，可以使用命令：<code>git switch -c dev</code></li><li>直接切换现有分支可以使用： <code>git switch master</code></li></ul><h5 id="1-4-远程仓库的分支的创建"><a href="#1-4-远程仓库的分支的创建" class="headerlink" title="1.4 远程仓库的分支的创建"></a>1.4 远程仓库的分支的创建</h5><ul><li>创建远程仓库的分支,首先是在本地创建好分支，然后使用命令:<code>git push --set-upstream origin dev</code> , 远程分支的名字建议和本地的分支名字保持一致。</li><li>查看远程分支： <code>git branch -a</code></li><li>有时候我们会出现这种情况，master 分支是线上的代码，但是我们有个版本还没上的代码在 dev 分支上，所以我们需要拉取的代码应该是 dev 上的，所以我们一般在克隆下来项目的时候，我们默认是在主分支上的，但是这个时候如果我们使用:<code>git checkout -b dev</code>你会发现你的代码其实是 master 上拉取出来的，意思就是你本地的 dev 分支的代码是 master 上的，跟远程的 dev 是不一致的，不过这个不是说一定是 master 上的，假如你是在 test 分支上拉出来的，那么 dev 就是 test 上的代码，反正就是你在哪个分支上切换并创建分支，那么切出来的分支代码就是和当前分支是也一致的，那怎么办呢？这里有两种情况:<ul><li><ol><li>第一种方式是:在你切分支的时候，如果是直接从 master 拉出来的，那么你就必须要先 pull 一下远程的 dev 代码到本地，如果你只是输入命令<code>git pull</code> 会提示没有当前分支没有跟踪信息，要你指定合并哪个分支，你可以按照提示输入命令: <code>git pull &lt;remote&gt; &lt;branch&gt;</code> 或者 <code>git branch --set-upstream-to=origin/&lt;branch&gt; dev</code>, 然后再次执行下<code>git pull</code>即可</li></ol></li><li><ol start="2"><li>第二种方式是：直接在创建切换分支的时候拉取远程仓库的代码到本地，使用命令: <code>git checkout -b dev origin/dev</code> , 这样就剩下了步骤啦。</li></ol></li></ul></li></ul><h5 id="1-5-远程仓库的分支的合并"><a href="#1-5-远程仓库的分支的合并" class="headerlink" title="1.5 远程仓库的分支的合并"></a>1.5 远程仓库的分支的合并</h5><ul><li>这个就没什么好说的拉，直接在本地合并分支之后 push 到远程仓库就好了。</li><li>当然，这里还是要提下，你在 push 的时候，一定要保证你的代码是最新的，也就是你每次 push 前最好都 pull 一下远程的代码，这是一个好的习惯。</li><li>这里说下另外一个命令，强制推送: <code>git push -f origin &lt;branch&gt;</code>， 这种方法慎用，很暴力，不推荐。这个操作一般都是本地代码回退版本后，常规的 push 用不了了，才会使用到，为什么用不了？？？ 因为本地仓库已经落后远程仓库了啊，所以要强制推送了。</li></ul><h5 id="1-6-远程仓库的回退方法"><a href="#1-6-远程仓库的回退方法" class="headerlink" title="1.6 远程仓库的回退方法"></a>1.6 远程仓库的回退方法</h5><p>在话题开始之前，我们先来聊聊版本回退的流程:</p><ol><li><p>本地版本库回退：</p><ul><li>输入命令<code>git log</code>或者<code>git reflog</code>找到 commit_id</li><li>输入命令<code>git reset --hard &lt;commit_id&gt;</code></li></ul></li><li><p>自己的远程分支版本回退:</p><ul><li>输入命令<code>git log</code>或者<code>git reflog</code>找到 commit_id</li><li>输入命令<code>git reset --hard &lt;commit_id&gt;</code></li><li>输入命令<code>git push -f origin &lt;branch&gt;</code></li></ul></li></ol><h5 id="1-7-远程仓库的公共分支版本回退方法"><a href="#1-7-远程仓库的公共分支版本回退方法" class="headerlink" title="1.7 远程仓库的公共分支版本回退方法"></a>1.7 远程仓库的公共分支版本回退方法</h5><p>上面的两种方式都和自己相关，一个人爱咋咋地，没得问题，但是如果你往公共分支推送了错误代码，那怎么办啊？？？</p><p>什么，有什么不一样？？？</p><p>不一样多了，最显而易见的一个问题也是最重要的一个问题就是，别人的代码也在那个分支上，你版本一回退别人的代码不就被你搞丢了吗？</p><h6 id="1-7-1-远程仓库的公共分支版本回退方法之-reset"><a href="#1-7-1-远程仓库的公共分支版本回退方法之-reset" class="headerlink" title="1.7.1 远程仓库的公共分支版本回退方法之 reset"></a>1.7.1 远程仓库的公共分支版本回退方法之 <strong>reset</strong></h6><ul><li><ol><li>假如现在 master 上有这样一条线， A1 - A2 - B1 ， A 和 B 代表两个人， 对应着这个提交，并且所有人的本地分支都已经更新到了最新的版本，和远程分支是一致的。</li></ol></li><li><ol start="2"><li>这个时候你发现了 A2 上面有错误，你使用 reset 回滚了当前分支到 A1 ,这样一来，B1 的提交也不见了， 这个时候其他同事的本地仓库代码就比远程仓库的分支超前了两次提交，因为远程的分支回退了。</li></ol></li><li><ol start="3"><li><p>这个时候如果你告诉你的同事，你刚刚回退了远程仓库的版本，B 同事的代码不见了，所以 B 同事应该要找回 B1 的那次提交并合并回 master 去， 所以他应该要找到他 B1 的那次提交的 commit_id，然后回退到 B1 版本提交，并且重新创建一个分支，具体步骤如下:</p><pre><code> git checkout B同事自己的分支   // 所以说，在开发中拥有自己的分支是多么重要的一件事情 git reflog   // 查看当前的commit_id,也就是已经被回退的A1的commit_id git reset --hard B1 // 自己的分支上先回退到被覆盖的提交B1上 git checkout -b 存放B1被覆盖的代码 // 然后切换创建一个分支用来存放被覆盖的B1代码 git checkout B同事自己的分支        //然后再切换回自己的分支上 git reset --hard &lt;commit_id&gt;       //这个commit_id 就是第二步获取到的ID，也就是当前代码的最前端 /*     通过上面的操作，B1的提交找回来了，这时候B同事就要使自己的master分支跟远程master分支保持一致， 使用命令 git reset --hard origin/master     这样B同事的master分支就真正的回滚了。     接着B同事再把丢失的B1操作再次合并到master： git merge 存放B1被覆盖的代码     然后B同事再push上去，就可以了。     但是其他的同事没有代码丢失则可以直接使用命令: git reset --hard origin/master , 但是假如有一个同事直接使用命令 : git push , 那么版本回退就回到了最初的状态 A1 - A2 - B1。 这就是分布式，每个人都有副本。 */</code></pre></li></ol></li></ul><h6 id="1-7-2-远程仓库的公共分支版本回退方法之-revert"><a href="#1-7-2-远程仓库的公共分支版本回退方法之-revert" class="headerlink" title="1.7.2 远程仓库的公共分支版本回退方法之 revert"></a>1.7.2 远程仓库的公共分支版本回退方法之 <strong>revert</strong></h6><p>使用 git reset 回退公共远程分支的版本后，需要其他所有人手动用远程 master 分支覆盖本地 master 分支，显然，这不是优雅的回退方法，下面我们使用另个一个命令来回退版本：</p><pre><code>      git revert HEAD                     //撤销最近一次提交      git revert HEAD~1                   //撤销上上次的提交，注意：数字从0开始      git revert 0ffaacc                  //撤销0ffaacc这次提交</code></pre><p>git revert 命令意思是撤销某次提交。它会产生一个新的提交，虽然代码回退了，但是版本依然是向前的，所以，当你用 revert 回退之后，所有人 pull 之后，他们的代码也自动的回退了。</p><p>但是，要注意以下几点：</p><ul><li>revert 是撤销一次提交，所以后面的 commit id 是你需要回滚到的版本的前一次提交</li><li>使用 revert HEAD 是撤销最近的一次提交，如果你最近一次提交是用 revert 命令产生的，那么你再执行一次，就相当于撤销了上次的撤销操作，换句话说，你连续执行两次 revert HEAD 命令，就跟没执行是一样的</li><li>用 revert HEAD~1 表示撤销最近 2 次提交，这个数字是从 0 开始的，如果你之前撤销过产生了 commi id，那么也会计算在内的。</li><li>如果使用 revert 撤销的不是最近一次提交，那么一定会有代码冲突，需要你合并代码，合并代码只需要把当前的代码全部去掉，保留之前版本的代码就可以了.</li><li>git revert 命令的好处就是不会丢掉别人的提交，即使你撤销后覆盖了别人的提交，他更新代码后，可以在本地用 reset 向前回滚，找到自己的代码，然后拉一下分支，再回来合并上去就可以找回被你覆盖的提交了。</li><li>revert 合并代码，解决冲突: 使用 revert 命令，如果不是撤销的最近一次提交，那么一定会有冲突</li><li>解决冲突很简单，因为我们只想回到某次提交，因此需要把当前最新的代码去掉即可，也就是 HEAD 标记的代码</li></ul><h6 id="1-7-3-远程仓库的公共分支版本回退方法之-简单粗暴的方法"><a href="#1-7-3-远程仓库的公共分支版本回退方法之-简单粗暴的方法" class="headerlink" title="1.7.3 远程仓库的公共分支版本回退方法之 简单粗暴的方法"></a>1.7.3 远程仓库的公共分支版本回退方法之 <strong>简单粗暴的方法</strong></h6><p>如果你们开发中，忽然发现前面很远的地方有一次错误的合并代码，把本来下一次才能发的功能的代码合并到了这一次来了，这个时候全体成员都觉得直接回滚比较快，因为他们都有备份，覆盖了无所谓，这个时候用 reset 的话对队友的要求比较高，用 revert 的话呢要大面积的解决冲突，也很麻烦呀，怎么办呢？</p><p>这个时候，可以使用简单粗暴的办法，直接从那个错误的提交的前一次拉取一份代码放到其他目录，然后将 master 代码全部删除，把那份新代码方进去，然后提交，果然简单粗暴啊，虽然这种方法不入流，但是，实践中发现很好使啊，所以，实践是检验真理的唯一标准。遇到问题还是要灵活应对。</p><p>这里丢两个链接给大家阅读，有兴趣的可以去参考阅读下这个章节的原文:</p><ul><li><a href="https://blog.csdn.net/fuchaosz/article/details/52170105">梧桐那时雨</a></li></ul><p>还有个讲解 reset、revert 的文章:</p><ul><li><a href="https://blog.csdn.net/yxlshk/article/details/79944535">游笑天涯</a></li></ul><h4 id="2-解决冲突"><a href="#2-解决冲突" class="headerlink" title="2. 解决冲突"></a>2. 解决冲突</h4><p>当我们在 master 上修改了 A 文件，然后又在 dev 上修改了 A 文件，然后都提交到了版本库当中，这样冲突就产生了，这时候你在 master 执行命令: <code>git merge dev</code> , 使用<code>git status</code>就能够查看到冲突的文件，这种情况我们就需要手动来解决这些冲突再提交了。</p><ul><li>用<code>git log --graph</code>命令可以看到分支合并图。</li></ul><h4 id="3-分支管理策略"><a href="#3-分支管理策略" class="headerlink" title="3. 分支管理策略"></a>3. 分支管理策略</h4><ul><li>合并分支时，加上<code>--no-ff</code> 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 <code>fast forward</code> 合并就看不出来曾经做过合并。</li><li>例如: <code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code></li></ul><h4 id="4-BUG-分支"><a href="#4-BUG-分支" class="headerlink" title="4. BUG 分支"></a>4. BUG 分支</h4><p>在实际开发中，BUG 紧急修复是很正常的一个现象，但是当前我正在 dev 分支上进行开发，并且代码还不是完善的，没有办法提交，这个时候怎么办呢？</p><ul><li>可以是用<code>git stash</code> 把工作现场给”储藏”起来，等以后恢复现场后继续工作。</li><li>在使用 stash 命令之后，你就可以安心的去创建新的分支来修复 bug。</li><li>修复完成之后我们再切换到 dev 分支，使用<code>git stash list</code>命令查看可以看到我刚刚”储藏”起来的工作现场。</li><li>现在只需要恢复我的工作现场就可以了，这里有两个办法:<ul><li>一是用 git stash apply 恢复，但是恢复后，stash 内容并不删除，你需要用 git stash drop 来删除；</li><li>另一种方式是用 git stash pop，恢复的同时把 stash 内容也删了(推荐使用)</li></ul></li><li>我们现在来想个问题，我们现在当前的分支是从 master 上拉取出来的，这就意味这 master 上 bug 在当前分支上也是存在的，但是我们刚刚只是修复了 master 上的，而当前分支上的 bug 是没有修复的，现在该怎么办呢？ 有两种办法：<ul><li><ol><li>重复做刚刚我们在 master 上修复 bug 问题。</li></ol></li><li><ol start="2"><li>使用命令 : <code>git cherry-pick &lt;commit_id&gt;</code> 来复制一个特定的提交到当前的分支上，至于怎么找到哪个 commit_id 不用说了吧。</li></ol></li></ul></li><li>这个方法是不是很棒， 有了这个命令，我们其实可以在 dev 上修复，然后在 master 上复制特定的提交，不过仍然需要<code>git stash</code>命令保存现场，才能从 dev 分支切换到 master 分支。</li></ul><h4 id="5-删除分支"><a href="#5-删除分支" class="headerlink" title="5. 删除分支"></a>5. 删除分支</h4><ul><li><p>我们在开发中经常都需要自己独立开一个分支来写我们的功能，写完之后合并到主分支上去，或者修复 bug 的时候单独开 bugfix 来修复 bug，但是用完之后我们就需要把这个分支给删掉，使用命令<code>git branch -d &lt;branch&gt;</code> 删除分支 或者 强制删除分支 <code>git branch -D &lt;branch&gt;</code> ,强制删除一般都用在分支没有被合并过的时候</p></li><li><p>删除远程分支的命令则是: git push origin –delete &lt;branch&gt;</p></li></ul><h4 id="6-多人协作"><a href="#6-多人协作" class="headerlink" title="6. 多人协作"></a>6. 多人协作</h4><p>多人协作的工作模式通常是这样：</p><ul><li><ol><li>首先，可以试图用 git push origin &lt;branch-name&gt;推送自己的修改；</li></ol></li><li><ol start="2"><li>如果推送失败，则因为远程分支比你的本地更新，需要先用 git pull 试图合并;</li></ol></li><li><ol start="3"><li>如果合并有冲突，则解决冲突，并在本地提交；</li></ol></li><li><ol start="4"><li>没有冲突或者解决掉冲突后，再用 git push origin &lt;branch-name&gt;推送就能成功！</li></ol></li></ul><p>如果 <code>git pull</code> 提示 <code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令 <code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><p>当你从远程仓库克隆时，实际上 Git 自动把本地的 master 分支和远程的 master 分支对应起来了，并且，远程仓库的默认名称是 origin。</p><p>要查看远程库的信息，用<code>git remote</code> 或者用<code>git remote -v</code>显示更详细的信息</p><p><code>git remote -v</code>命令输出显示了可以抓取和推送的 origin 的地址。如果没有推送权限，就看不到 push 的地址。</p><p><code>git push origin &lt;branch&gt;</code> 推送到远程仓库的分支</p><p><code>git checkout -b dev origin/dev</code> 创建远程 origin 的 dev 分支到本地</p><h4 id="7-Rebase"><a href="#7-Rebase" class="headerlink" title="7. Rebase"></a>7. Rebase</h4><p>提交历史分叉了,rebase 就派上了用场。我们输入命令<code>git rebase</code>：</p><ul><li>rebase 操作的特点就是把分叉的提交历史“整理”成一条直线，看上去更直观</li><li>rebase 的缺点是本地的分叉提交已经被修改过了。</li><li>rebase 的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li></ul><hr><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git 的标签虽然是版本库的快照，但其实它就是指向某个 commit 的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p>Git 有 commit，为什么还要引入 tag？</p><p>因为<code>git log</code>打印出来的日志太过于凌乱不太好找，如果有标签的话，我们就可以根据标签来找到对应的 commit_id，简单点理解就是，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起。</p><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>在 Git 中打标签非常简单，首先，切换到需要打标签的分支上，然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签,可以用命令<code>git tag</code>查看所有标签。</p><p>默认标签是打在最新提交的 commit 上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的 commit id，然后打上就可以了，例如:<code>git tag v0.9 &lt;commit_id&gt;</code></p><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息。</p><p>创建带有说明的标签，用-a 指定标签名，-m 指定说明文字：<code>git tag -a &lt;标签名&gt; -m &quot;备注信息&quot; &lt;commit_id&gt;</code>,随后用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字。</p><p>注意：标签总是和某个 commit 挂钩。如果这个 commit 既出现在 master 分支，又出现在 dev 分支，那么在这两个分支上都可以看到这个标签。</p><h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><p>如果标签打错了，也可以删除: <code>git tag -d &lt;标签名&gt;</code>，因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>,或者，一次性推送全部尚未推送到远程的本地标签：<code>git push origin --tags</code>。</p><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除:</p><ul><li><ol><li>先本地删除标签名<code>git tag -d &lt;标签名&gt;</code></li></ol></li><li><ol start="2"><li>然后，从远程删除。删除命令也是 push，但是格式是: <code>git push origin :refs/tags/&lt;标签名&gt;</code></li></ol></li></ul><hr><h3 id="如何让本地仓库关联两个远程仓库"><a href="#如何让本地仓库关联两个远程仓库" class="headerlink" title="如何让本地仓库关联两个远程仓库"></a>如何让本地仓库关联两个远程仓库</h3><p>使用多个远程库时，我们要注意，git 给远程库起的默认名称是 origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p><p>步骤如下:</p><ul><li>先关联 GitHub 的远程库： <code>git remote add github &lt;github的远程仓库地址&gt;</code>，注意，远程库的名称叫 github，不叫 origin 了。</li><li>再关联码云的远程库: <code>git remote add gitee &lt;码云的远程仓库地址&gt;</code>,同样注意，远程库的名称叫 gitee，不叫 origin。</li></ul><p>现在，我们用<code>git remote -v</code>查看远程库信息，可以看到两个远程库.</p><p>如果要推送到 GitHub，使用命令： <code>git push github &lt;branch&gt;</code>。<br>如果要推送到码云，使用命令： <code>git push gitee &lt;branch&gt;</code>。<br>这样一来，我们的本地库就可以同时与多个远程库互相同步。</p><p>如果要删除已有的远程仓库可以使用命令: <code>git remote rm origin</code> ， 这里注意， origin 是默认的远程仓库的名称，假如你更改了这个名称，那么你就要输入你更改后的名称哦。</p><hr><h3 id="自定义-git"><a href="#自定义-git" class="headerlink" title="自定义 git"></a>自定义 git</h3><p>Git 有很多可配置项:</p><p><code>git config --global color.ui true</code> 该配置会让 Git 适当地显示不同的颜色</p><h3 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h3><p>在 Git 工作区的根目录下创建一个特殊的.gitignore 文件，然后把要忽略的文件名填进去，Git 就会自动忽略这些文件,这个文件不需要我们自己写，可以在<a href="https://github.com/github/gitignore">这里</a>组合一下就可以。</p><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>配置一个<code>git status</code>的简写：<code>git config --global alias.st status</code> , 之后输入命令则可以更改为<code>git st</code></p><p>配置一个<code>git chackout &lt;branch&gt;</code>的简写：<code>git config --global alias.co checkout</code> , 之后输入命令则可以更改为<code>git co &lt;branch&gt;</code></p><p>配置一个<code>git commit -m &#39;备注&#39;</code>的简写：<code>git config --global alias.ci commit</code> , 之后输入命令则可以更改为<code>git ci -m &#39;备注&#39;</code></p><p>配置一个<code>git branch</code>的简写：<code>git config --global alias.br branch</code> , 之后输入命令则可以更改为<code>git br&#39;备注&#39;</code></p><p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有 Git 仓库下都有用。</p><p>配置一个<code>git reset HEAD &lt;file&gt;</code>的简写：<code>git config --global alias.unstage &#39;reset HEAD&#39;</code> , 之后输入命令则可以更改为<code>git unstage &lt;file&gt;</code> , 这个命令是让暂存区的修改撤销重新放回工作区哦。</p><p>配置一个<code>git log -1</code>的简写: <code>git config --global alias.last &#39;log -1&#39;</code> , 之后输入命令则可以更改为<code>git last</code>, 这个命令是让其显示最后一次提交信息</p><p>配置一个<code>git log</code>的简写：<code>git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</code>, , 之后输入命令则可以更改为<code>git lg</code></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置 Git 的时候，加上–global 是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p><p>配置文件放哪了？每个仓库的 Git 配置文件都放在.git/config 文件中,别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。</p><p>而当前用户的 Git 配置文件放在用户主目录下的一个隐藏文件.gitconfig 中,配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p><p><a href="https://git-scm.com/book/zh/v1/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-%E9%85%8D%E7%BD%AE-Git">更多的 git 配置</a></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>1.git 的知识点还有很多，廖雪峰老师的教学中还有一章 git 搭建没有去实战过，因为感觉还不是特别需要，所以暂时先放下了。</li><li>本篇文章有自己的一些理解，但更多的是借鉴，感谢这些前辈们的无私奉献，才让我们这些底层的小白有进步的空间。</li></ul><p>这里贴出两位大佬的文章，个人感觉对初学者很是友好，简单易懂:</p><ul><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰老师的 git 教学</a></li><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html">罗杰·杜德勒老师的 git 教学</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git 学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter开发环境搭建</title>
    <link href="/articles/2020/09/01/Flutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/articles/2020/09/01/Flutter%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="安装Flutter-SDK"><a href="#安装Flutter-SDK" class="headerlink" title="安装Flutter SDK"></a>安装Flutter SDK</h2><p><a href="https://flutter.dev/docs/development/tools/sdk/releases?tab=macos#macos">官网地址</a> 可能需要科学上网</p><p>此文章针对 mac 系统进行配置,如需要配置window环境,可以查看 <a href="https://jspang.com/detailed?id=41">技术胖</a>的博客 或者去 <a href="https://flutterchina.club/setup-macos/">Flutter中文网</a>查看教程。</p><p>本人在配置过程中遇到最多的问题就是网络问题,建议科学上网操作一下全部流程。</p><h3 id="SDK下载完成"><a href="#SDK下载完成" class="headerlink" title="SDK下载完成"></a>SDK下载完成</h3><ol><li><p>解压安装包存放到你想放置的文件内,注意这一步很重要,因为在接下来的环境变量配置需要用到它. 例如: 我在Dektop下新建了一个Flutter文件夹存放解压后的Flutter SDK</p></li><li><p>配置环境变量: 打开终端 ls -a 查看是否有 .bash_profile 文件, 如果没有的话新建, 有的话打开该文件(打开的方式有很多,怎么方便怎么来吧)。</p><pre><code>         新建文件的命令是: touch 文件名</code></pre></li><li><p>打开或者新建了文件之后编写文件</p><pre><code>         export PUB_HOSTED_URL=https://pub.flutter-io.cn  # 国内用户需要设置         export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn  # 国内用户需要设置         export PATH=SDK-Path/flutter/bin:$PATH</code></pre><p> 注意: SDK-Path 为你flutter的路径，比如我刚刚在Desktop下新建了Flutter文件夹存放,那么我的SDK-Path 这里应该是 /Users/你的电脑用户名/Desktop/Flutter , 如果环境变量没有配置成功回来这里检查就对了. (如果想要快速查看这个文件存放位置, 可以进入该文件夹 打开终端输入pwd 查看)<br> 如果你的mac终端是 zsh 那么你肯定知道 终端启动时 ~/.bash_profile 将不会被加载，解决办法就是修改 ~/.zshrc ，在其中添加：source ~/.bash_profile</p></li><li><p>上一步配置完成后,重启终端或者运行 source $HOME/.bash_profile 刷新当前终端窗口.</p></li><li><p>到了这里Flutter SDK算是安装完成了,并且你可以在随处打开终端执行 flutter 命令了。</p></li><li><p>验证是否安装成功:</p><pre><code>         flutter -h</code></pre></li><li><p>如果环境配置成功会有输出,接下来检查Flutter开发环境, 输入命令:</p><pre><code>         flutter doctor</code></pre></li><li><p>不出所料可能会出现很多的 x , 例如:</p><pre><code>         To install, run:         brew install --HEAD libimobiledevice         brew install ideviceinstaller         ✗ ios-deploy not installed. To install:             brew install ios-deploy         ✗ CocoaPods not installed.             CocoaPods is used to retrieve the iOS platform side&#39;s plugin code that responds to your plugin usage on the Dart side.             Without resolving iOS dependencies with CocoaPods, plugins will not work on iOS.             For more info, see https://flutter.io/platform-plugins         To install:             brew install cocoapods             pod setup</code></pre><p> <strong>备注:</strong>  每台电脑的环境可能会有所不同, 大家根据自己的提示进行一系列安装. 上面输出大概意思就是我们需要这些软件，Flutter推荐你用brew命令进行安装。</p></li><li><p>安装完以上软件之后, 我们再来安装 Android Studio , 下载地址: <a href="http://www.android-studio.org/">http://www.android-studio.org/</a></p><p> 安装好之后运行 Android Studio , 然后打开另外终端 输入命令允许协议（android-licenses）:</p><pre><code>         flutter doctor --android-licenses</code></pre><p> 然后让你输入Y/N的时候，一路Y就可以了.</p></li><li><p>上面那一步安装好之后 再次输入 flutter doctor 进行环境检测 , 查看是否有这一行信息:</p><pre><code>        ✗ Flutter plugin not installed; this adds Flutter specific functionality.        ✗ Dart plugin not installed; this adds Dart specific functionality.</code></pre><p>如果有 说明你的 Android Studio 没有安装Flutter 插件, 打开 Android Studio 后 快捷键 :</p><pre><code>        command + ,</code></pre><p>选择 plugings 后搜索 Flutter 插件安装,安装完成之后重新启动 Android Studio, 然后再次输入检测命令:</p><pre><code>        flutter doctor</code></pre></li><li><p>如果有提示 vscode 的文字, 下载打开vscode ,查找Flutter插件以及dart插件 并安装好它们.</p></li><li><p>完成vscode的步骤之后, 再次输入命令 flutter doctor 检测环境,如果全部都 [✓] 符号, 只有出现下面这个提示 :</p><pre><code>        [!] Connected devices            ! No devices available</code></pre><p>那么恭喜你,环境已经搭建好了, 这个提示只是提示没有找到 调试设备, 可以不用管它.</p></li><li><p>接下来 安装 AVD 虚拟机 , 打开 Android Studio 后界面会出现一个 start a new Flutter project , 不犹豫 意思就是新建一个 Flutter项目 , 其实新建项目也可以使用终端:</p><pre><code>        flutter create myapp</code></pre><p>项目新建后我们就可以看到我们的目录结构了,这个不是重点, 我们在 Android Studio 编辑器上找到 Tools 选择 AVD manager 然后会弹出一个界面,如果你没有安装过 AVD虚拟机, 中间会出现创建按钮的.</p></li><li><p>虚拟机安装好之后我们就要来跑一下我们新建的Flutter项目了, 这里建议使用 vscode 来运行 Flutter 项目, 毕竟轻量级目前最火编辑器之一嘛.</p><p>打开 vscode 选择我们刚刚新建的Flutter 项目 , 打开 AVD 虚拟机 , 终端输入命令检查Android设备是否在运行:</p><pre><code>        flutter devices</code></pre><p>如果你开启了 虚拟机 ,终端会输出如下内容:</p><pre><code>        1 connected device:        AOSP on IA Emulator • emulator-5554 • android-x86 • Android 9 (API 28) (emulator)</code></pre><p>注意 每个人安装的虚拟机操作系统不一样,所以内容输出不是一模一样的哦 .</p><p>如果有输出 ,接下来可以执行命令:</p><pre><code>        flutter run</code></pre><p>假如你开了多个虚拟机, 你可以通过命令来达到你想要在哪台虚拟机上运行你的app:</p><pre><code>        flutter run -d emulator-5554</code></pre><p><strong>emulator-5554</strong> 这个是虚拟机的ID , 如果你只是运行了一台则可以忽略这段话.</p></li><li><p>到此为止, Flutter 开发环境已经配置完毕。</p></li></ol><h3 id="iOS开发环境设置"><a href="#iOS开发环境设置" class="headerlink" title="iOS开发环境设置"></a>iOS开发环境设置</h3><ol><li><p>安装Xcode 9.0</p></li><li><p>配置Xcode命令行工具以使用新安装的Xcode版本:</p><pre><code>         sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer</code></pre><p> 以上路径时对于最新版Xcode的路径。如果你需要使用不同的Xcode版本，需要指定相应路径。</p></li><li><p>确保Xcode许可协议是通过打开一次Xcode或通过命令sudo xcodebuild -license同意过了,接下来就可以使用Xcode，在iOS设备或模拟器上运行Flutter App了。</p></li><li><p>在终端输入如下命令打开一个iOS模拟器：</p><pre><code>         open -a Simulator</code></pre></li><li><p>打开虚拟机后 运行项目</p></li></ol><h2 id="如何将Flutter-项目跑在真机"><a href="#如何将Flutter-项目跑在真机" class="headerlink" title="如何将Flutter 项目跑在真机"></a>如何将Flutter 项目跑在真机</h2><p>目前没有尝试 , 推荐个文章给大家看看: <a href="https://www.devio.org/2019/04/03/development-environment-mac/">https://www.devio.org/2019/04/03/development-environment-mac/</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个过程耗时 3 个小时 , 因为网络原因导致很多的问题, 希望大家有个好的翻墙工具以及网络环境 来操作 可能时间会快很多</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos 7下安装配置Nginx</title>
    <link href="/articles/2020/09/01/Centos-7%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AENginx/"/>
    <url>/articles/2020/09/01/Centos-7%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AENginx/</url>
    
    <content type="html"><![CDATA[<p>本文基于Centos 7下安装配置Nginx操作实践记录整理。</p><h2 id="一、配置-EPEL源"><a href="#一、配置-EPEL源" class="headerlink" title="一、配置 EPEL源"></a>一、配置 EPEL源</h2><pre><code class="hljs bash">sudo yum install -y epel-releasesudo yum -y update</code></pre><h2 id="二、安装Nginx"><a href="#二、安装Nginx" class="headerlink" title="二、安装Nginx"></a>二、安装Nginx</h2><pre><code class="hljs bash">sudo yum install -y nginx</code></pre><p>安装成功后，默认的网站目录为： /usr/share/nginx/html</p><p>默认的配置文件为：/etc/nginx/nginx.conf</p><p>自定义配置文件目录为: /etc/nginx/conf.d/</p><h2 id="三、开启端口80和443"><a href="#三、开启端口80和443" class="headerlink" title="三、开启端口80和443"></a>三、开启端口80和443</h2><p>如果你的服务器打开了防火墙，你需要运行下面的命令，打开80和443端口。</p><pre><code class="hljs bash">sudo firewall-cmd --permanent --zone=public --add-service=httpsudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload</code></pre><p>如果你的服务器是阿里云ECS，你还可以通过控制台安全组，打开80和443端口，或者其他自定义端口。</p><p>具体操作路径： 阿里云ECS服务器 -》网络与安全 -》 安全组 -》 配置规则 -》 安全组规则 -》 入方向 -》 添加安全组规则</p><p>端口范围： 比如你要打开80端口，这里就填写 80/80 。</p><p>优先级： 优先级可选范围为1-100，默认值为1，即最高优先级。</p><h2 id="四、操作Nginx"><a href="#四、操作Nginx" class="headerlink" title="四、操作Nginx"></a>四、操作Nginx</h2><p>nginx 操作命令备注：</p><pre><code class="hljs bash"><span class="hljs-comment"># 1.启动 Nginx</span>systemctl start nginx<span class="hljs-comment"># 2.停止Nginx</span>systemctl stop nginx<span class="hljs-comment"># 3.重启Nginx</span>systemctl restart nginx<span class="hljs-comment"># 4.查看Nginx状态</span>systemctl status nginx<span class="hljs-comment"># 5.启用开机启动Nginx</span>systemctl <span class="hljs-built_in">enable</span> nginx<span class="hljs-comment"># 6.禁用开机启动Nginx</span>systemctl <span class="hljs-built_in">disable</span> nginx</code></pre><h2 id="五、配置Nginx"><a href="#五、配置Nginx" class="headerlink" title="五、配置Nginx"></a>五、配置Nginx</h2><h3 id="安装Https免费证书-以阿里云域名为例"><a href="#安装Https免费证书-以阿里云域名为例" class="headerlink" title="安装Https免费证书(以阿里云域名为例)"></a>安装Https免费证书(以阿里云域名为例)</h3><p>一键安装 acme.sh</p><pre><code class="hljs bash">curl https://get.acme.sh | sh<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;alias acme.sh=~/.acme.sh/acme.sh&#x27;</span> &gt;&gt; ~/.bashrc<span class="hljs-built_in">source</span> ~/.bashrc</code></pre><p>生成Https证书</p><pre><code class="hljs bash"><span class="hljs-built_in">export</span> Ali_Key=<span class="hljs-string">&quot;**********&quot;</span>  <span class="hljs-built_in">export</span> Ali_Secret=<span class="hljs-string">&quot;**********&quot;</span>  acme.sh --issue --dns dns_ali -d domain</code></pre><p>其中：</p><p>点击阿里云后台，右上角用户头像，菜单中选择accesskeys。</p><p>查看AccessKey ID 和 Access Key Secret，即对应上面的Ali_Key 和 Ali_Secret。</p><p>domain 对应该账户下购买的阿里云域名。</p><p>拷贝证书到nginx</p><pre><code class="hljs bash">mkdir -p /etc/nginx/sslacme.sh --install-cert -d domain \--key-file       /etc/nginx/ssl/domain.key  \--fullchain-file /etc/nginx/ssl/domain.cer \--reloadcmd     <span class="hljs-string">&quot;service nginx force-reload&quot;</span></code></pre><p>https证书拷贝成功。</p><p>目前https证书在 60 天以后会自动更新, 你无需任何操作. 今后有可能会缩短这个时间, 不过都是自动的, 你不用关心.</p><h3 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h3><p>删除/etc/nginx/nginx.conf中的server部分代码。</p><pre><code class="hljs vim">server &#123;    ...&#125;</code></pre><p>在/etc/nginx/conf.d 创建自定义配置文件default.conf</p><pre><code class="hljs vim">server &#123;    listen 80;    listen 443 ssl;    server_name  domain www.domain;    location / &#123;        root /usr/share/nginx/html;        index  index.html index.htm;    &#125;    ssl on;    ssl_certificate /etc/nginx/ssl/domain.crt;    ssl_certificate_key /etc/nginx/ssl/domain.key;    ssl_session_timeout  5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE;    ssl_prefer_server_ciphers  on;    error_page 497  https://$host$uri?$args;&#125;</code></pre><p>其中:<br>root /usr/share/nginx/html; 表示网站文件目录，后面的分号不可省略。</p><p>ssl_certificate和ssl_certificate_key 指向https证书。</p><p>error_page 497 <a href="https://hosturi/?$args">https://hosturi?$args</a>; 这句的作用是，强制http跳转到https。</p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于代码规范的配置</title>
    <link href="/articles/2020/09/01/%E5%85%B3%E4%BA%8E%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/articles/2020/09/01/%E5%85%B3%E4%BA%8E%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>配置一下这个代码规范的问题，在这里我们需要使用到的工具有: <strong>vetur</strong>，<strong>eslint</strong>，<strong>prettier</strong></p><p>好了，当我们创建了一个项目或者接手了一个项目的时候，为了能够让我们的代码规范起来，可以自行配置vscode的json配置，但是项目是多人开发的，所以我们应该把这个配置具体到我们的项目中，达到每个开发人员都能够统一规范。</p><p>首先我们要在项目中安装一个包：@vue/prettier</p><pre><code class="hljs bash">yarn add -D @vue/eslint-config-prettier</code></pre><p>安装好之后，在 .eslintrc.js 给它加上：</p><pre><code class="hljs javascript"><span class="hljs-string">&quot;extends&quot;</span>: [  <span class="hljs-string">&quot;plugin:vue/essential&quot;</span>,  <span class="hljs-string">&quot;eslint:recommended&quot;</span>,  <span class="hljs-string">&quot;@vue/prettier&quot;</span>],</code></pre><p>现在我们执行 npm run lint 的时候，可以看到eslint已经帮我们启动了代码规范， 但是很多东西都不能按照我们的想法来执行的，这个时候我们还需要做一些配置：</p><p>在项目的根目录下创建一个.prettierrc.js文件，然后在其中加入：</p><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;    semi: <span class="hljs-literal">false</span>,  <span class="hljs-comment">//行位是否使用分号，默认为true</span>    singleQuote: <span class="hljs-literal">true</span>, <span class="hljs-comment">//  是否使用单引号</span>    <span class="hljs-comment">// bracketSpacing: true, //对象大括号直接是否有空格，默认为true，效果：&#123; foo: bar &#125;</span>    <span class="hljs-comment">// &quot;printWidth&quot;: 80, //一行的字符数，如果超过会进行换行，默认为80</span>    <span class="hljs-comment">// &quot;tabWidth&quot;: 2, //一个tab代表几个空格数，默认为80</span>    <span class="hljs-comment">// &quot;useTabs&quot;: false, //是否使用tab进行缩进，默认为false，表示用空格进行缩减</span>    <span class="hljs-comment">// &quot;trailingComma&quot;: &quot;none&quot;, //是否使用尾逗号，有三个可选值&quot;&lt;none|es5|all&gt;&quot;</span>    <span class="hljs-comment">// parser: &quot;babylon&quot; //代码的解析引擎，默认为babylon，与babel相同。</span>&#125;</code></pre><p>到了这里，即时有上千个VUE文件，我们也可以通过npm run lint 处理我们的错误规范代码</p><p>配置到这里我们已经可以实现代码规范了， 但是为了能够在vscode编辑器看到我们的错误规范，我们还需要装一个插件，这个插件就叫Eslint。</p><p>安装好eslint后，因为eslint并不认识我们vue文件里面包含了js语法，所以我们还需要打开我们的vscode 配置文件，这里的配置只是配置我们个人的文件，并没有达到团队的配置效果，所以我们要在项目中创建一个.vscode文件夹，但是这里需要注意一个问题：.vscode 这个文件夹在.gitignore文件里面，所以千万要记得把.vscode删除</p><p>做好上面的一步之后，在.vscode里面创建文件settings.json文件，添加如下代码：</p><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;eslint.autoFixOnSave&quot;</span>: <span class="hljs-literal">true</span>,<span class="hljs-attr">&quot;eslint.validate&quot;</span>: [        <span class="hljs-string">&quot;javascript&quot;</span>,        <span class="hljs-string">&quot;javascriptreact&quot;</span>,        &#123;            <span class="hljs-attr">&quot;language&quot;</span>: <span class="hljs-string">&quot;vue&quot;</span>,            <span class="hljs-attr">&quot;autoFix&quot;</span>: <span class="hljs-literal">true</span>        &#125;    ],&#125;</code></pre><p>上面的配置就是在保存的时候校验并修改我们的代码，它会自动帮我们整理代码规范</p><p>配置到这里其实已经结束了，但是因为我们安装了很多插件，例如Prettier ， 因为我们不只开发vue项目，可能还有其它类型的js项目特别是传统js项目，需要用到prettier进行美化，而prettier的一些功能是会和eslint相冲突的，比如说我们在全局设置了prettier的formatOnSave，这个功能就会和eslint的autoFixOnSave打架，为了避免这个矛盾，我们通常还会在本项目的settings.json文件里再多加几个选项，类似于这样：</p><pre><code class="hljs json">&quot;editor.tabSize&quot;: 2,&quot;editor.formatOnSave&quot;: false,&quot;prettier.semi&quot;: false,&quot;prettier.singleQuote&quot;: true</code></pre><p>有了这些设置，基本上prettier就不会和eslint打架了。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云服务器安装docker，部署gitlab步骤</title>
    <link href="/articles/2020/09/01/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85docker%EF%BC%8C%E9%83%A8%E7%BD%B2gitlab%E6%AD%A5%E9%AA%A4/"/>
    <url>/articles/2020/09/01/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85docker%EF%BC%8C%E9%83%A8%E7%BD%B2gitlab%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<p>对服务器内存有要求 , 如果内存小于 4g 会卡顿甚至连接不上服务器或者 gitlab 显示 502 访问慢等问题。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>centos 8 亲测</li><li>本地 mac 10.15.6</li></ul><h2 id="ssh-无密码登录"><a href="#ssh-无密码登录" class="headerlink" title="ssh 无密码登录"></a>ssh 无密码登录</h2><p>步骤一：<br>登录阿里云 ECS 实例 ， 创建密钥对。<br>在 管理后台选 网络与安全 ， 选密钥对 ，右上角创建密钥对 ， 这里主要 ， 密钥对创建好了之后 ，浏览器会自动下载私钥文件 .pem , 如果丢失 ， 则无法找回。<br>密钥对创建好了之后 ， 在密钥对列表点击绑定密钥对 ，然后选中要绑定的 ecs 实例（如果实例为 window 实例不支持 ssh 密钥对）。<br>绑定后一定要重启实例 ，密钥对才会生效， 对了， 安全组记得开发 ssh 端口（SSH 协议默认的 22 端口）</p><p>步骤二：<br>找到创建后下载的 .pem 私钥路径 ，<br>然后在本地终端运行命令： chmod 400 [.pem 私钥文件在本地机上的存储路径]，<br>然后使用 ssh 命令连接远程实例： ssh -i [.pem 私钥文件在本地机上的存储路径] root@[公网 IP 地址]，</p><h2 id="ssh-配置文件"><a href="#ssh-配置文件" class="headerlink" title="ssh 配置文件"></a>ssh 配置文件</h2><p>每次连接命令输入有点长， 我们可以配置下 config 文件 来达到简短的命令输入：</p><p>步骤一：<br>终端 cd 进入 .ssh 目录，本人是把 .pem 私钥存放在这个目录的，建议你也存放在这里。<br>如果没有 config 文件 ， 则创建 ， 如果有的话 则 打开 该文件 ， 并输入以下内容：</p><pre><code class="hljs bash">Host ecs    <span class="hljs-comment"># 输入ECS实例的名称 , 你喜欢 取什么你决定</span>HostName 192.*.*.*   <span class="hljs-comment"># 输入ECS实例的公网IP地址</span>Port 22   <span class="hljs-comment"># 输入端口号，默认为22</span>User root   <span class="hljs-comment"># 输入登录账号</span>IdentityFile ~/.ssh/ecs.pem <span class="hljs-comment"># 输入.pem私钥文件在本机的地址</span></code></pre><p>保存这个文件。</p><p>步骤二：<br>打开本地终端 ， 输入 ssh 连接命令即可， 例如： ssh [ECS 实例的名称，也就是你 config 中的 host 的值]</p><h2 id="远程登录-实例后-，-我们准备安装-docker"><a href="#远程登录-实例后-，-我们准备安装-docker" class="headerlink" title="远程登录 实例后 ， 我们准备安装 docker"></a>远程登录 实例后 ， 我们准备安装 docker</h2><p>关于 docker 的概念 ， 可以自行查阅 ，这里不细说。</p><p>查看当前系统版本：</p><pre><code class="hljs bash">cat /etc/redhat-release</code></pre><p>添加新 docker 的 yum 源:</p><pre><code class="hljs bash">yum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repoyum-config-manager --<span class="hljs-built_in">enable</span> docker-ce-edgeyum-config-manager --<span class="hljs-built_in">enable</span> docker-ce-test</code></pre><p>自定义 docker 配置:</p><p>为了提升 Docker 镜像服务的安装速度，这里自定义 docker 的配置，让其从国内镜像源拉去镜像。</p><pre><code class="hljs bash">mkdir /etc/dockervi /etc/docker/daemon.json</code></pre><p>然后在 daemon.json 文件中输入如下内容。</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;graph&quot;</span>:<span class="hljs-string">&quot;/home/docker&quot;</span>, <span class="hljs-comment">// docker 的数据存放文件</span>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span>: [      <span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>, <span class="hljs-comment">// docker 国内官方镜像</span>    <span class="hljs-string">&quot;https://reg-mirror.qiniu.com&quot;</span>, <span class="hljs-comment">// 七牛云</span>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span>  <span class="hljs-comment">// 网易云</span>    ]&#125;</code></pre><p>保存后 ， 更新下这个文件(每次修改后都必要更新和重启docker)。</p><pre><code class="hljs bash">systemctl daemon-reload</code></pre><p>安装 docker-ce：</p><pre><code class="hljs bash">yum install docker-ce <span class="hljs-comment"># 或者使用 dnf -y  install docker-ce --nobest</span></code></pre><p>安装后 ， 如果你不是root用户 ， 那么使用docker都需要 sudo 来使用。<br>如果需要省略 sudo ，需要将用户添加到 docker 组。</p><pre><code class="hljs bash">sudo usermod -aG docker USER_NAME</code></pre><p>开机启动 docker 服务：</p><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> --now docker</code></pre><p>启动 docker ：</p><pre><code class="hljs bash">systemctl start docker</code></pre><p>查看是否安装成功：</p><pre><code class="hljs bash">docker info</code></pre><p>可以看到我们自定义的配置文件生效了。</p><h2 id="docker-安装-gitlab"><a href="#docker-安装-gitlab" class="headerlink" title="docker 安装 gitlab"></a>docker 安装 gitlab</h2><p>查看gitlab镜像：</p><pre><code class="hljs bash">docker search gitlab</code></pre><p>安装 gitlab(这里备注下： 官方的这个镜像安装之后docker启动后无法访问，看了日志报错是: Chef encountered an error attempting to load the node data for , 找不到解决办法 ，最后无奈删除这个镜像 ， 使用了 twang2218/gitlab-ce-zh 汉化版镜像)：</p><pre><code class="hljs bahs">docker pull twang2218&#x2F;gitlab-ce-zh</code></pre><p>检查是否下载了这个镜像：</p><pre><code class="hljs bash">docker images</code></pre><p>docker 运行 gitlab ：</p><pre><code class="hljs bash">docker run --detach \  --hostname 127.0.0.1 \  --publish 443:443 --publish 80:80 --publish 22:22 \  --name gitlab \  --restart always \  --volume /home/gitlab/config:/etc/gitlab \  --volume /home/gitlab/logs:/var/<span class="hljs-built_in">log</span>/gitlab \  --volume /home/gitlab/data:/var/opt/gitlab \  gitlab/gitlab-ce:latest</code></pre><ul><li>–detach：后台运行容器</li><li>–publish：端口映射，容器端口如何映射到宿主机（本文指我们的 Mac 电脑）端口</li><li>–name：指定容器的名称，这里我们指定容器名称为 gitlab</li><li>–restart always：设置当宿主机重启后，容器也会重启</li><li>–volume：这里使用 bind mount 的方式，设置 gitlab 容器的数据保存在目录 /home/gitlab/ 下</li></ul><p>config 文件夹保存 gitlab 配置<br>logs 文件夹保存 gitlab 输出日志<br>data 文件夹保存 gitlab 应用数据</p><p>输入以上命令后 ，返回一串字符串代表 docker 镜像启动成功了。<br>访问你需要在阿里云服务器把对应的安全组端口打开。</p><p>接下来我们来改一下 gitlab 的配置文件， 我们通过 volume 参数， 把 数据都存在目录 home/gitlab处，所以我们进入这个目录， 找到config下的gitlab.rb 文件,然后修改以下字段：</p><pre><code class="hljs bash">external_url <span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span> <span class="hljs-comment"># 不加端口号 默认 80</span></code></pre><p>接着再修改一些配置来优化我们的gitlab：</p><pre><code class="hljs bash">unicorn[<span class="hljs-string">&#x27;enable&#x27;</span>] = <span class="hljs-literal">true</span>unicorn[<span class="hljs-string">&#x27;worker_timeout&#x27;</span>] = 60unicorn[<span class="hljs-string">&#x27;worker_processes&#x27;</span>] = 2unicorn[<span class="hljs-string">&#x27;worker_memory_limit_min&#x27;</span>] = <span class="hljs-string">&quot;300 * 1 &lt;&lt; 20&quot;</span>unicorn[<span class="hljs-string">&#x27;worker_memory_limit_max&#x27;</span>] = <span class="hljs-string">&quot;500 * 1 &lt;&lt; 20&quot;</span>sidekiq[<span class="hljs-string">&#x27;concurrency&#x27;</span>] = 16postgresql[<span class="hljs-string">&#x27;shared_buffers&#x27;</span>] = <span class="hljs-string">&quot;256MB&quot;</span>postgresql[<span class="hljs-string">&#x27;max_worker_processes&#x27;</span>] = 8</code></pre>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo创建博客以及github搭建博客流程</title>
    <link href="/articles/2020/09/01/Hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8Agithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%B5%81%E7%A8%8B/"/>
    <url>/articles/2020/09/01/Hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8Agithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="使用hexo-脚手架搭建模板"><a href="#使用hexo-脚手架搭建模板" class="headerlink" title="使用hexo 脚手架搭建模板"></a>使用hexo 脚手架搭建模板</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>既然要使用hexo， 那么肯定少不了hexo 的<a href="https://hexo.io/zh-cn/">官方文档</a>。</p><p>安装hexo的前提（这个就不多废话啦，没有安装的点击进入安装就行）：</p><ul><li><a href="http://nodejs.org/">Node.js</a> (Should be at least nodejs 6.9)</li><li><a href="http://git-scm.com/">Git</a></li></ul><p>好了，安装好之后，我们就开始全局安装hexo了：</p><pre><code>npm install -g hexo-cli</code></pre><p>安装好之后，我们就开始建立我们的网站啦，接下来命令行输入：</p><pre><code>hexo init 项目名称cd 项目名称npm install</code></pre><p>上面三个命令很简单啦，第一步就是初始化我们的项目，项目名称随便你取，初始化完毕之后，我们进入这个项目，或者你可以忽略第二部，利用编辑器打开你的项目进行依赖安装，生成的目录结构如下：</p><pre><code>node_modules: 依赖包scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题_config.yml: 博客的配置文件</code></pre><p>接下来再执行命令：</p><pre><code>hexo ghexo server</code></pre><p>执行完毕后，控制台会输出端口4000的地址，打开我们就能看到博客了。</p><hr><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><p>那么，接下来我们就是需要配置我们的网站：</p><p>我们打开_config.yml文件：</p><pre><code><pre><code class="hljs yml"><span class="hljs-comment"># Hexo Configuration</span><span class="hljs-comment">## Docs: https://hexo.io/docs/configuration.html</span><span class="hljs-comment">## Source: https://github.com/hexojs/hexo/</span><span class="hljs-comment"># Site  这里修改成你们的东西即可</span><span class="hljs-attr">title:</span> <span class="hljs-string">Chalice</span> <span class="hljs-string">Lee</span>  <span class="hljs-attr">subtitle:</span> <span class="hljs-string">前端博客,JavaScript,html5,css3,Jquery,NodeJs</span><span class="hljs-attr">description:</span> <span class="hljs-string">前端博客,JavaScript,html5,css3,Jquery,NodeJs</span><span class="hljs-attr">keywords:</span> <span class="hljs-string">前端博客,JavaScript,html5,css3,Jquery,NodeJs</span><span class="hljs-attr">author:</span> <span class="hljs-string">Chalice</span> <span class="hljs-string">Lee</span><span class="hljs-attr">language:</span> <span class="hljs-string">zh</span><span class="hljs-attr">timezone:</span><span class="hljs-comment"># URL</span><span class="hljs-comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><span class="hljs-attr">url:</span> <span class="hljs-string">https://chalicelee92.github.io/</span> <span class="hljs-string">//</span> <span class="hljs-string">这里是网站url</span><span class="hljs-attr">root:</span> <span class="hljs-string">/</span>  <span class="hljs-string">//</span> <span class="hljs-string">根目录</span><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><span class="hljs-attr">permalink_defaults:</span><span class="hljs-comment"># Directory</span><span class="hljs-attr">source_dir:</span> <span class="hljs-string">source</span><span class="hljs-attr">public_dir:</span> <span class="hljs-string">public</span><span class="hljs-attr">tag_dir:</span> <span class="hljs-string">tags</span><span class="hljs-attr">archive_dir:</span> <span class="hljs-string">archives</span><span class="hljs-attr">category_dir:</span> <span class="hljs-string">categories</span><span class="hljs-attr">code_dir:</span> <span class="hljs-string">downloads/code</span><span class="hljs-attr">i18n_dir:</span> <span class="hljs-string">:lang</span><span class="hljs-attr">skip_render:</span><span class="hljs-comment"># Writing</span><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:title.md</span> <span class="hljs-comment"># File name of new posts</span><span class="hljs-attr">default_layout:</span> <span class="hljs-string">post</span><span class="hljs-attr">titlecase:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Transform title into titlecase</span><span class="hljs-attr">external_link:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Open external links in new tab</span><span class="hljs-attr">filename_case:</span> <span class="hljs-number">0</span><span class="hljs-attr">render_drafts:</span> <span class="hljs-literal">false</span><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">false</span><span class="hljs-attr">relative_link:</span> <span class="hljs-literal">false</span><span class="hljs-attr">future:</span> <span class="hljs-literal">true</span><span class="hljs-attr">highlight:</span><span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><span class="hljs-attr">auto_detect:</span> <span class="hljs-literal">false</span><span class="hljs-attr">tab_replace:</span><span class="hljs-comment"># Home page setting</span><span class="hljs-comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><span class="hljs-comment"># per_page: Posts displayed per page. (0 = disable pagination)</span><span class="hljs-comment"># order_by: Posts order. (Order by date descending by default)</span><span class="hljs-attr">index_generator:</span><span class="hljs-attr">path:</span> <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><span class="hljs-attr">order_by:</span> <span class="hljs-string">-date</span><span class="hljs-comment"># Category &amp; Tag</span><span class="hljs-attr">default_category:</span> <span class="hljs-string">uncategorized</span><span class="hljs-attr">category_map:</span><span class="hljs-attr">tag_map:</span><span class="hljs-comment"># Date / Time format</span><span class="hljs-comment">## Hexo uses Moment.js to parse and display date</span><span class="hljs-comment">## You can customize the date format as defined in</span><span class="hljs-comment">## http://momentjs.com/docs/#/displaying/format/</span><span class="hljs-attr">date_format:</span> <span class="hljs-string">YYYY-MM-DD</span><span class="hljs-attr">time_format:</span> <span class="hljs-string">HH:mm:ss</span><span class="hljs-comment"># Pagination</span><span class="hljs-comment">## Set per_page to 0 to disable pagination</span><span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><span class="hljs-attr">pagination_dir:</span> <span class="hljs-string">page</span><span class="hljs-comment"># Extensions</span><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><span class="hljs-attr">theme:</span> <span class="hljs-string">hexo-theme-aircloud-master</span>   <span class="hljs-string">//</span> <span class="hljs-string">这里是更换主题</span><span class="hljs-comment"># Deployment</span><span class="hljs-comment">## Docs: https://hexo.io/docs/deployment.html</span><span class="hljs-attr">deploy:</span><span class="hljs-attr">type:</span> <span class="hljs-string">git</span><span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/chalicelee92/chalicelee92.github.io.git</span><span class="hljs-attr">branch:</span> <span class="hljs-string">master</span></code></pre></code></pre><p>具体配置解释可以查看官网文档。</p><hr><h3 id="3-主题更换"><a href="#3-主题更换" class="headerlink" title="3. 主题更换"></a>3. 主题更换</h3><p>下面跟大家说下如何更换<a href="https://hexo.io/themes/">主题</a>，进入官网的主题页面，选择自己喜欢的风格，进入仓库后，把代码 <strong>clone</strong> 下来，然后复制粘贴到 <strong>theme</strong> 这个文件夹里面，然后再 <strong>_config.yml</strong> 配置文件里面配置<strong>theme</strong>字段，指定你下载主题的文件夹名字然后重启服务器，就可以了。</p><hr><h3 id="4-书写文章"><a href="#4-书写文章" class="headerlink" title="4. 书写文章"></a>4. 书写文章</h3><p>到此为止，我们的网站基本可以看到啦，接下来就是说说，如何写文章啦，命令行输入：</p><pre><code>hexo new [layout] &lt;title&gt;</code></pre><ul><li><p>layout ：默认为_posts</p></li><li><p>title: 要创建的文章名字</p></li></ul><p>然后你会发现，在/source/_posts下面，多了你创建的文件，然后，我们就可以愉快的书写你的博客日志啦。</p><p>书写完毕后输入命令：</p><pre><code>hexo cleanhexo ghexo d</code></pre><p>最后给大家案例一篇文章：本人小白技术，看不懂的可以移步到：</p><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">https://blog.csdn.net/sinat_37781304/article/details/82729029</a></p><hr><h3 id="主题使用详细介绍之-aircloud-主题的使用"><a href="#主题使用详细介绍之-aircloud-主题的使用" class="headerlink" title="主题使用详细介绍之 aircloud 主题的使用"></a>主题使用详细介绍之 aircloud 主题的使用</h3><p>接下来简单的说下如何使用Hexo主题(每个主题都有不同的配置,具体看作者的教程配置)：</p><p>选择好自己喜欢的Hexo 主题之后，把主题给clone 下来，然后复制粘贴到theme文件夹内，这个很简单，也就不多讲了。</p><p>那么接下来我们是要配置这个主题的内容啊，就比如aircloud这个主题，配置文件则是如下：</p><pre><code><pre><code class="hljs json"># Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Chalice Leesubtitle: 前端博客,JavaScript,html5,css3,Jquery,NodeJsdescription: 前端博客,JavaScript,html5,css3,Jquery,NodeJskeywords: 前端博客,JavaScript,html5,css3,Jquery,NodeJsauthor: Chalice Leelanguage: zhtimezone:# Site settings# 网站综合内容设置：# SEOTitle: Chalice Lee的博客 | Chalice Lee Blog# email: ChaliceLee92@163.com# description: &quot;Chalice Lee的博客&quot;# keyword: &quot;前端博客&quot;# URL## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;url: https://chalicelee92.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight:enable: trueline_number: trueauto_detect: falsetab_replace:# Home page setting# path: Root path for your blogs index page. (default = &#x27;&#x27;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator:path: &#x27;&#x27;per_page: 10order_by: -date# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-aircloud-master# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: https://github.com/chalicelee92/chalicelee92.github.io.gitbranch: mastersidebar-avatar: img/avatar.png# SNS settings  这里配置后，则会在网站底部出现对应的社交图标# 一些社交平台地址，支持以下几种：# weibo_username:# zhihu_username:github_username:    ChaliceLee92# twitter_username:# facebook_username:  # linkedin_username:  # Friends# 友情链接# friends: [#     &#123;#         title: &quot;&quot;,#         href: &quot;&quot;#     &#125;,&#123;#         title: &quot;&quot;,#         href: &quot;&quot;#     &#125;,&#123;#         title: &quot;&quot;,#         href: &quot;&quot;#     &#125;# ]# Build settingsanchorjs: true                          # if you want to customize anchor. check out line:181 of `post.html`#comment:#  type: gitment#  id: your-id-created-by-https://github.com/settings/applications/new#  secret: your-secret-created-by-https://github.com/settings/applications/new#  owner: aircloud#  repo: hexo-aircloud-blog# 赞赏功能donate:img: img/WechatIMG181.jpegcontent: 您的赞赏是对我最大的鼓励# 文章样式(是否首行缩进)：post_style:indent: default# 头像圆角avatar_style:radius: true# 搜索功能search:path: search.jsonfield: post</code></pre></code></pre><p>具体可以查看主题包的Readme , 都会有详细的使用说明的。</p><hr><h3 id="github-搭建博客"><a href="#github-搭建博客" class="headerlink" title="github 搭建博客"></a>github 搭建博客</h3><p>首先在GitHub上创建一个仓库，仓库的名字应该要对应你的GitHub用户名，例如我的仓库名则设置为：</p><p>ChaliceLee92.github.io</p><p>后缀是.github.io , 接下来就简单了，创建好仓库之后，把仓库关联你本地的项目，然后再提交到仓库主分支，过了一段时间，则可以访问你的GitHub仓库地址了。</p><p>访问地址为：<a href="https://chalicelee92.github.io/">https://chalicelee92.github.io/</a></p><hr><h3 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h3><p>然后书写文章，文章书写完毕后打包：</p><pre><code>hexo new 文章名称 // 创建文章hexo clean // 清除之前的打包hexo g  // 打包hexo serve // 启动项目hexo clean // 清除之前的打包hexo g // 打包hexo d // 发布到GitHub</code></pre>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
